<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>前端面试题 | Were all heroes</title><meta name="author" content="微风"><meta name="copyright" content="微风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="康哥将面试题 ECMAScript 6 入门 阮一峰 ECMAScript 6 入门 现代 JavaScript 教程 工具应用文档 Dan个人博客  01【概述】把握住答题技巧？ 面试题套路12345671.是什么?2.怎么用?3.解决了什么问题?4.有没有替代方案?5.好处是什么?6.场景是什么?7.原理是什么? HTML【CSS】EM 和 REM 的区别是什么？123456789# 是什么?">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试题">
<meta property="og:url" content="http://example.com/2023/07/31/2023/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E5%BF%85%E4%BC%9A%EF%BC%8C%E4%B8%8D%E4%BC%9A%E6%89%BE%E5%B7%A5%E4%BD%9C%E9%9A%BE/index.html">
<meta property="og:site_name" content="Were all heroes">
<meta property="og:description" content="康哥将面试题 ECMAScript 6 入门 阮一峰 ECMAScript 6 入门 现代 JavaScript 教程 工具应用文档 Dan个人博客  01【概述】把握住答题技巧？ 面试题套路12345671.是什么?2.怎么用?3.解决了什么问题?4.有没有替代方案?5.好处是什么?6.场景是什么?7.原理是什么? HTML【CSS】EM 和 REM 的区别是什么？123456789# 是什么?">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/yang-chang-jun/imges/blob/main/image_1/17.jpg">
<meta property="article:published_time" content="2023-07-31T13:40:20.000Z">
<meta property="article:modified_time" content="2023-08-03T14:32:18.892Z">
<meta property="article:author" content="微风">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/yang-chang-jun/imges/blob/main/image_1/17.jpg"><link rel="shortcut icon" href="https://img0.baidu.com/it/u=3487243724,4005355975&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500"><link rel="canonical" href="http://example.com/2023/07/31/2023/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E5%BF%85%E4%BC%9A%EF%BC%8C%E4%B8%8D%E4%BC%9A%E6%89%BE%E5%B7%A5%E4%BD%9C%E9%9A%BE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 微风","link":"链接: ","source":"来源: Were all heroes","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-03 22:32:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img0.baidu.com/it/u=3487243724,4005355975&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/yang-chang-jun/imges/blob/main/image_1/17.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Were all heroes"><span class="site-name">Were all heroes</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">前端面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">更新于</span><time datetime="2023-08-03T14:32:18.892Z" title="更新于 2023-08-03 22:32:18">2023-08-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="前端面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iW4y1k7Ci/?spm_id_from=333.999.0.0">康哥将面试题</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/es6-3rd/sidebar.md">ECMAScript 6 入门 阮一峰</a></p>
<p><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/set-map">ECMAScript 6 入门</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.javascript.info/">现代 JavaScript 教程</a></p>
<p><a target="_blank" rel="noopener" href="https://hello-nav.github.io/">工具应用文档</a></p>
<p><a target="_blank" rel="noopener" href="https://overreacted.io/zh-hans/">Dan个人博客</a></p>
<!-- 贺师俊、尤雨溪 -->
<p>01【概述】把握住答题技巧？</p>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h3 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.是什么?</span><br><span class="line">2.怎么用?</span><br><span class="line">3.解决了什么问题?</span><br><span class="line">4.有没有替代方案?</span><br><span class="line">5.好处是什么?</span><br><span class="line">6.场景是什么?</span><br><span class="line">7.原理是什么?</span><br></pre></td></tr></table></figure>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="【CSS】EM-和-REM-的区别是什么？"><a href="#【CSS】EM-和-REM-的区别是什么？" class="headerlink" title="【CSS】EM 和 REM 的区别是什么？"></a>【CSS】EM 和 REM 的区别是什么？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是什么?</span></span><br><span class="line">em和rem 都是根据字体大小发生改变</span><br><span class="line">em是相对的长度单位, 他的大小会根据元素字体大小的改变而变化, 先看自己的, 如果自己没有设置字体大小则看上级的如果上级也没有设置则继续向上级寻找,一直到html根元素.   rem则是只看根元素字体大小而改变, 不受父元素字体大小限制.</span><br><span class="line"><span class="comment"># 作用?</span></span><br><span class="line">rem加入媒体查询,可以用于响应式布局</span><br><span class="line"><span class="comment"># 替代方案</span></span><br><span class="line">rem属于老版本响应式, 需要引入js文件进行适配, vw/vh 属于新版本的响应式, 无需引入js文件适配</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">逐字稿： EM 是相对于元素 <span class="string">&#x27;自身&#x27;</span> 字体大小的一个单位， 而 REM 是相对于根元素（html）字体大小的一个单位。</span><br></pre></td></tr></table></figure>
<h3 id="说一下你对-REM-的理解"><a href="#说一下你对-REM-的理解" class="headerlink" title="说一下你对 REM 的理解?"></a>说一下你对 REM 的理解?</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是什么?</span></span><br><span class="line">是一个相对于根元素字体大小的单位</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment"># 怎么用?</span></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment"># 解决了什么问题?</span></span><br><span class="line"> 可以用来解决移动端适配的问题</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment"># 有没有替代方案?</span></span><br><span class="line">不过在开发当中, 也会用vw来进行适配, 在一定程度上来说 rem 做适配, 可以说就是对 vw 的一个模拟</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment"># 原理是什么?</span></span><br><span class="line">适配的原理是 利用媒体查询 或 js 动态监测设备的宽度, 不同的宽度下 设置对应的根元素的字体大小, 根元素的字体大小都发生变化了, 所有用 rem 做单位的元素都会跟着变化</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">逐字稿：利用媒体查询 或 js动态检测/获取设备的宽度，不同宽度下设置相应的根元素字体大小，当设备宽度变 =&gt; 根元素字体大小变 =&gt; 那么所有使用 REM 做单位的哪些元素都会跟着变化</span><br></pre></td></tr></table></figure>
<h3 id="【CSS】REM-适配的原理是什么？"><a href="#【CSS】REM-适配的原理是什么？" class="headerlink" title="【CSS】REM 适配的原理是什么？"></a>【CSS】REM 适配的原理是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">原理是什么?</span><br><span class="line">-- 把网页分成10等分, 每一份相当于 1rem ,和媒体查询配合可以做到响应式布局</span><br><span class="line">解决了什么问题?</span><br><span class="line">-- 电脑端应用, 移动端客户无法使用, 使用了rem后, 移动端用户也可以像pc端一样正常访问</span><br><span class="line">替代方案?</span><br><span class="line">-- vw/vh</span><br><span class="line">场景?</span><br><span class="line">-- bilibili(vw/vh)</span><br><span class="line">原理?</span><br><span class="line">把网页分成10等分, 每一份相当于1rem</span><br></pre></td></tr></table></figure>
<h3 id="【CSS】如何实现一个盒子水平垂直居中？"><a href="#【CSS】如何实现一个盒子水平垂直居中？" class="headerlink" title="【CSS】如何实现一个盒子水平垂直居中？"></a>【CSS】如何实现一个盒子水平垂直居中？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. flex布局</span></span><br><span class="line"><span class="attr">display</span>: flex;  <span class="comment">// 开启flex</span></span><br><span class="line">justify-<span class="attr">content</span>: center;  <span class="comment">// 主轴居中</span></span><br><span class="line">align-<span class="attr">items</span>: center;  <span class="comment">// 侧轴居中</span></span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 2.脱离标准流 + margin外边距</span></span><br><span class="line"><span class="comment">// 父盒子设置 </span></span><br><span class="line">	<span class="attr">position</span>: relative;  <span class="comment">// 相对定位</span></span><br><span class="line"><span class="comment">// 子盒子</span></span><br><span class="line">     <span class="attr">position</span>: absolute;  <span class="comment">// 绝对定位</span></span><br><span class="line">	<span class="comment">/* 脱离标准流 */</span></span><br><span class="line">      <span class="attr">top</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attr">bottom</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attr">left</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attr">right</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 脱离标准流后子盒子设置auto 自动水平垂直居中</span></span><br><span class="line">      <span class="attr">margin</span>: auto;</span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 3. margin外边距 + transform位移</span></span><br><span class="line"><span class="comment">// 父盒子设置</span></span><br><span class="line">	<span class="attr">overflow</span>: hidden; <span class="comment">// 防止盒子塌陷</span></span><br><span class="line"><span class="comment">// 子盒子</span></span><br><span class="line">	margin-<span class="attr">left</span>: <span class="number">50</span>%;</span><br><span class="line">	margin-<span class="attr">top</span>: <span class="number">50</span>%;</span><br><span class="line">	<span class="attr">transform</span>: <span class="title function_">translate</span>(-<span class="number">50</span>%,-<span class="number">50</span>%);  <span class="comment">// 位移回自身的一半</span></span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 4.position定位 + transform位移</span></span><br><span class="line"><span class="comment">// 父盒子</span></span><br><span class="line">	<span class="attr">position</span>: relative;</span><br><span class="line"><span class="comment">// 子盒子</span></span><br><span class="line">	  <span class="attr">position</span>: absolute;</span><br><span class="line">      <span class="attr">left</span>: <span class="number">50</span>%;</span><br><span class="line">      <span class="attr">top</span>: <span class="number">50</span>%;</span><br><span class="line">      <span class="attr">transform</span>: <span class="title function_">translate</span>(-<span class="number">50</span>%,-<span class="number">50</span>%);</span><br></pre></td></tr></table></figure>
<h3 id="【CSS】说一下你对-BFC-的理解？"><a href="#【CSS】说一下你对-BFC-的理解？" class="headerlink" title="【CSS】说一下你对 BFC 的理解？"></a>【CSS】说一下你对 BFC 的理解？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是怎么?</span></span><br><span class="line">BFC(块级格式化上下文)是一种css渲染方式</span><br><span class="line">BFC决定了块级盒子的渲染方式,以及其他元素的互动方式, 主要作用有: 防止 margin 重叠、清除浮动等  BFC 可以剥离并独立于外部环境，因此其内部元素与外部元素互相独立，不会影响其它区域的布局。</span><br><span class="line">----</span><br><span class="line">例如，当两个块级元素 margin 相遇时，它们的 margin 合并可能会导致布局问题，将其中一个元素置于一个 BFC 中可以解决这个问题。</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="comment"># 怎么用?  场景?</span></span><br><span class="line">`清除浮动`：当元素浮动时，BFC 可以防止浮动的元素溢出到父元素外部。可以通过在父元素上触发 BFC 来清除浮动。</span><br><span class="line">防止 margin `重叠` ：当两个相邻的块级元素 margin 发生重叠时，可以将它们置于不同的 BFC 中。</span><br><span class="line">强制元素在`一行显示`：可以将元素设为 display: inline-block 并触发 BFC，从而同时避免元素之间的缝隙和 margin 重叠。</span><br><span class="line">`自适应`两栏布局：将左侧元素置于一个 BFC 中，右侧元素也置于一个 BFC 中，就可以实现两栏布局。</span><br><span class="line">解决`文字环绕`问题：BFC 可以解决文字环绕问题，通过在文字周围创建一个新的 BFC 容器，来实现文字环绕效果。</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line"><span class="comment"># 替代方案?</span></span><br><span class="line">flex 布局：</span><br><span class="line">	Flexbox 布局提供了更直观的控制元素的排列和对齐方式的方法，主要用于解决一些列式布局的问题。</span><br><span class="line">Grid 布局：</span><br><span class="line">	Grid 布局是一种二维布局，能够非常方便的实现栅格化布局。</span><br><span class="line">Position 布局：</span><br><span class="line">	使用元素定位（position）来实现布局调整，通过对元素设置 position 属性及各种边缘值（top、right、bottom、left）来实现布局调整。但是这种方法不太适合用于整个布局的调整。</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line"><span class="comment"># 好处是什么?</span></span><br><span class="line">创建 BFC，可以有效的解决一些布局问题.  如避免 margin 重叠问题、清除浮动问题、自适应两栏布局、强制元素在一行显示、解决文字环绕问题等.  同时，BFC 还可以提高布局的容错性和灵活性，增强页面的可维护性。</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">原理是什么?</span><br><span class="line">可以让元素在一个相对独立的自我环境内进行布局、定位和绘制，避免由外部元素对其样式和位置的影响，同时也有助于解决一些常见的CSS布局问题。</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">逐字稿： </span><br><span class="line">1. 根元素（html）天生就有BFC特性</span><br><span class="line">2. 浮动元素（元素中的<span class="built_in">float</span>只要不是none就会触发BFC）</span><br><span class="line">3. 定位元素（元素中的 position 是 absolute 或 fixed 的时候也会触发BFC特性）</span><br><span class="line">4. 行内元素（元素的 display 为 inline-block）</span><br><span class="line">5. 表格单元素（元素的 display 为 table-cell, HTML表格单元素默认为改值就会触发）</span><br><span class="line">6. overflow 只要不是 visible就会触发BFC特性</span><br><span class="line">7. 更多说明 参考 MDN</span><br><span class="line">作用：</span><br><span class="line">1. 包含内部浮动元素</span><br><span class="line">2. 可以排除外部浮动带来的影响</span><br><span class="line">3. 阻止外边距重叠</span><br><span class="line">4. 解决margin盒子塌陷</span><br></pre></td></tr></table></figure>
<h3 id="【CSS】说一下-link-和-import-的区别？"><a href="#【CSS】说一下-link-和-import-的区别？" class="headerlink" title="【CSS】说一下 link 和 @import 的区别？"></a>【CSS】说一下 link 和 @import 的区别？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">`加载时间`和`性能`的区别：</span><br><span class="line">CSS文件使用<span class="string">&#x27;link&#x27;</span>标记时，`在页面加载时`就会<span class="string">&#x27;同时加载CSS文件&#x27;</span>；而使用`@import引入CSS文件时`，<span class="string">&#x27;需要等到页面DOM加载完成后&#x27;</span>才会加载CSS。因此，在页面性能方面，使用<span class="built_in">link</span>标记更好。</span><br><span class="line"></span><br><span class="line">`兼容性`的区别：</span><br><span class="line"><span class="string">&#x27;@import是CSS2.1中的属性，很多老版本的浏览器不支持&#x27;</span>@import。而<span class="string">&#x27;link标记是HTML4中定义的标签，几乎所有的浏览器&#x27;</span>都支持<span class="built_in">link</span>标记。</span><br><span class="line"></span><br><span class="line">`DOM操作`的区别：</span><br><span class="line"><span class="built_in">link</span>标记可以通过JavaScript来操作DOM并<span class="string">&#x27;更改CSS的属性&#x27;</span>，而@import无法通过JavaScript<span class="string">&#x27;操作DOM&#x27;</span>，因为它是在DOM加载完成后才加载的。</span><br><span class="line"></span><br><span class="line">`加载顺序`的区别：</span><br><span class="line"><span class="built_in">link</span>标记引入的CSS文件的加载顺序与HTML文档中<span class="built_in">link</span>标签的顺序有关，而@import引入的CSS文件的加载顺序与它们在样式表中的位置相关。</span><br></pre></td></tr></table></figure>
<h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><blockquote>
<p>标准盒子模型默认<code>content-box</code></p>
<p>通过<code>box-sizing:border-box</code>切换怪异盒子模型。</p>
</blockquote>
<h3 id="行内元素和块元素"><a href="#行内元素和块元素" class="headerlink" title="行内元素和块元素"></a>行内元素和块元素</h3><blockquote>
<p>块：artice、main、aside、header、footer、section…</p>
</blockquote>
<h3 id="深度作用选择器"><a href="#深度作用选择器" class="headerlink" title="深度作用选择器"></a>深度作用选择器</h3><blockquote>
<p>原生css使用   &gt;&gt;&gt;   深度选择器来修改</p>
<p>less需要使用    /deep/   或者   ::v-deep   深度选择器</p>
<p>vue3.0 中使用 /deep/ 会报错，更推荐使用 ::v-deep</p>
<p>对于使用了 css 预处理器（scss 、sass、 less）时，深度选择器 ::v-deep 比较通用</p>
</blockquote>
<h3 id="css画三角形"><a href="#css画三角形" class="headerlink" title="css画三角形"></a>css画三角形</h3><p>&gt;</p>
<h3 id="flex-1是什么意思？"><a href="#flex-1是什么意思？" class="headerlink" title="flex:1是什么意思？"></a>flex:1是什么意思？</h3><p>&gt;</p>
<h3 id="margin-top百分比是什么意思？"><a href="#margin-top百分比是什么意思？" class="headerlink" title="margin-top百分比是什么意思？"></a>margin-top百分比是什么意思？</h3><p>&gt;</p>
<h3 id="盒子垂直水平居中？"><a href="#盒子垂直水平居中？" class="headerlink" title="盒子垂直水平居中？"></a>盒子垂直水平居中？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 如果不考虑兼容性的话</span><br><span class="line">父盒子:&#123;</span><br><span class="line">  <span class="attr">display</span>: flex;</span><br><span class="line">  align-<span class="attr">content</span>: center;</span><br><span class="line">	justify-<span class="attr">content</span>: center</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 如果需要考虑兼容性问题的话</span><br><span class="line">子盒子&#123;</span><br><span class="line">  margin-<span class="attr">left</span>: <span class="number">50</span>%;</span><br><span class="line">  margin-<span class="attr">top</span>: <span class="number">50</span>%;</span><br><span class="line">  <span class="attr">transform</span>: <span class="title function_">translate</span>(-<span class="number">50</span>%,-<span class="number">50</span>%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何让谷歌浏览器支持小于12px的文字"><a href="#如何让谷歌浏览器支持小于12px的文字" class="headerlink" title="如何让谷歌浏览器支持小于12px的文字"></a>如何让谷歌浏览器支持小于12px的文字</h3><p>chrome谷歌浏览器默认的字体大小为16px，可以通过设置font-size来设置字体大小但是当设置到12px以下的时候字体大小不再改变;</p>
<blockquote>
<p>css：transform：scale();缩小字体大小，假设字体大小是12，缩小0.5就是6px</p>
</blockquote>
<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="DOM？"><a href="#DOM？" class="headerlink" title="DOM？"></a>DOM？</h3><blockquote>
<p>文档对象模型：DOM 通过创建表示文档的树，让开发者可以随心所欲地控制网页的内容和结构。使用 DOM API，<br>可以轻松地删除、添加、替换、修改节点。</p>
</blockquote>
<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM?"></a>BOM?</h3><blockquote>
<p>浏览器对象模型：开发者可以操控浏览器显示页面之外的部分。</p>
</blockquote>
<h3 id="script标签？"><a href="#script标签？" class="headerlink" title="script标签？"></a>script标签？</h3><blockquote>
<p>使用了 <script></script>引入外部脚本文件后，不应该在内部继续编写代码，因为浏览器只会下载并执行脚本文件而忽律内部代码。</p>
<p>通过 script 标签的src属性发送 GET 请求以取得相应资源，这个请求是不受浏览器同源策略限制，但返回并被执行的 JavaScript 则受限制。这个请求仍然受父页面 HTTP/HTTPS 协议的限制。</p>
</blockquote>
<h3 id="script标签为什么要写到-lt-body-gt-的上方？"><a href="#script标签为什么要写到-lt-body-gt-的上方？" class="headerlink" title="script标签为什么要写到&lt;/body&gt;的上方？"></a>script标签为什么要写到&lt;/body&gt;的上方？</h3><blockquote>
<p>一般放引入的 script 标签的时候我们都会放在 &lt;/body&gt; ，因为如果放在 <head> 标签里面的话。也就意味着必须把所有 JavaScript 代码都下载、解析和解释完成后，才能开始渲染页面，。对于需要很多 JavaScript 的页面，这会导致页面渲染的明显延迟，在此期间浏览器窗口完全空白。</p>
<p><code>解决方法一：</code>一般放到 body 标签的内容底部，这样一来页面处理 js 代码之前就完全渲染页面。用户会感觉页面加载更快了，因为浏览器白屏的空白页面的时间缩短了。</p>
<p><code>解决方法二：</code>给 script 标签添加一个 <code>defer</code>的属性。表示脚本文件立即下载，但是会被延迟到整个页面都解析完毕后在执行，就是所谓的延迟执行，并且添加了 <code>defer</code>属性的 script 标签会按顺序加载文件。</p>
<p><code>解决方法三：</code> HTML5为 script 元素添加了 <code>async</code>属性，从而改变脚本的执行方式，和 <code>defer</code>属性一样只对外部脚本文件有效，都会告诉浏览器立即下载延迟执行，但是 <code>async</code> 不能保证执行顺序，所以第二个脚本可能优先于第一个脚本，它们之间没有依赖关系，而且 <code>async</code> 属性会告诉浏览器不必等下载完毕在执行，也不必等到下载或执行后在加载其他脚本，所以异步脚本不应该在加载期间修改 DOM。</p>
</blockquote>
<h3 id="动态加载脚本"><a href="#动态加载脚本" class="headerlink" title="动态加载脚本"></a>动态加载脚本</h3><blockquote>
<p>以通过向 DOM 中动态添加 script 元素同样可以加载指定的脚本。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;gibberish.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script); </span><br></pre></td></tr></table></figure>
<p>在XHTML中编写代码的规则比 HTML 中严格，这会影响使用 script 元素嵌入 javascript 代码。</p>
<h3 id="编写js时为什么需要从外部文件引入？"><a href="#编写js时为什么需要从外部文件引入？" class="headerlink" title="编写js时为什么需要从外部文件引入？"></a>编写js时为什么需要从外部文件引入？</h3><blockquote>
<p><code>可维护性：</code>如果<code>js</code>代码被分配到很多个HTML页面，会导致维护困难。而如果所有页面保存的是一个js文件，则这更容易维护。</p>
<p><code>缓存：</code>浏览器会根据特定的设置缓存所有外部文件，如果多个页面都用的是同一个 js 文件，则该文件只需要下载一次，这意味着页面加载更快。</p>
</blockquote>
<h3 id="文档模式"><a href="#文档模式" class="headerlink" title="文档模式"></a>文档模式</h3><blockquote>
<p><code>混杂模式：</code>支持非标准的特性，在所有文件中都省略文档开头的   !DOCTYPE   这中约定并不合理，因为不同浏览器差异非常大，不使用黑科技没有一直性可言。</p>
<p><code>标准模式：</code>除混合模式以外的模式。</p>
</blockquote>
<h3 id="元素"><a href="#元素" class="headerlink" title="元素"></a><noscript>元素</h3><blockquote>
<p>早期浏览器不支持 javascript ，需要做页面降级，noscript 元素出现解决了这个问题，现在浏览器已经100%支持 <code>javascript</code> 对于禁用 <code>javascript</code> 的浏览器来说，任然有用。</p>
<p>总结：通过使用元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则元素中的任何内容都不会被渲染。</p>
</blockquote>
<h3 id="【JS】说一下-new-一个构造函数的执行过程？"><a href="#【JS】说一下-new-一个构造函数的执行过程？" class="headerlink" title="【JS】说一下 new 一个构造函数的执行过程？"></a>【JS】说一下 new 一个构造函数的执行过程？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1- new在声明函数的时候会自动在函数内部创建一个空对象</span><br><span class="line">2- 将新对象的原型设置为构造函数的原型对象(函数内部的this指向这个空对象)</span><br><span class="line"><span class="comment"># 把构造函数的 this 关键字绑定到新创建的对象上，这样构造函数内部的代码就可以访问到新对象的属性和方法</span></span><br><span class="line">3- 执行构造函数代码</span><br><span class="line">4- 执行完毕 <span class="string">&#x27;自动&#x27;</span> 返回结果</span><br><span class="line">5- 外部声明变量存储这个结果</span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下-call-和-apply-及-bind-的区别？"><a href="#【JS】说一下-call-和-apply-及-bind-的区别？" class="headerlink" title="【JS】说一下 call 和 apply 及 bind 的区别？"></a>【JS】说一下 call 和 apply 及 bind 的区别？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`call` 和 `apply` 都是函数对象的方法，它们的作用都是在特定的作用域中调用函数，它们的第一个参数都是代表该函数调用时的上下文对象，也就是该函数调用时 `this` 的指向，而后面的参数则是函数调用时的参数。</span><br><span class="line"></span><br><span class="line">`call` 和 `apply` 的不同之处在于传入参数的方式不同。`call` 方法接受的是<span class="string">&#x27;多个参数列表&#x27;</span>，而 `apply` 方法接受的是一个参数<span class="string">&#x27;数组&#x27;</span>。</span><br><span class="line"></span><br><span class="line">`<span class="built_in">bind</span>` 方法用于创建一个新函数，并将原函数的 `this` <span class="string">&#x27;绑定到指定的对象&#x27;</span>上。`<span class="built_in">bind</span>` 方法在函数式编程中十分实用，它不仅方便了函数的调用，同时也使得函数的 `this` 不再受到外界的影响，使得代码更加健壮。</span><br><span class="line"></span><br><span class="line">简单来说，`call` 和 `apply` 是直接调用一个函数，而 `<span class="built_in">bind</span>` 则是返回一个原函数的拷贝，并绑定指定的 `this` 值和参数。</span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下你对事件委托的理解？"><a href="#【JS】说一下你对事件委托的理解？" class="headerlink" title="【JS】说一下你对事件委托的理解？"></a>【JS】说一下你对事件委托的理解？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是什么?</span></span><br><span class="line">是一种JavaScript中常用的优化事件处理的技术，它利用事件冒泡机制将事件处理程序添加到相对静态的父元素上（比如页面中的顶层容器），而不是将事件处理程序直接添加到子元素上。</span><br><span class="line">---------------------------------------------------</span><br><span class="line"><span class="comment"># 解决了什么问题?</span></span><br><span class="line">它能够有效地减少事件处理程序的数量，从而提高页面性能和响应速度</span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="comment"># 好处是什么?</span></span><br><span class="line">1.性能高</span><br><span class="line">2.对后续新增的元素同样具有事件绑定的效果</span><br><span class="line">性能优化, 减少代码复杂性, 方便动态操作, 提高代码可维护性</span><br><span class="line">----------------------------------------------------</span><br><span class="line"><span class="comment"># 如何按需触发</span></span><br><span class="line">使用自定义事件</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;ul <span class="built_in">id</span>=<span class="string">&quot;oUl&quot;</span>&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">    &lt;li data-mark=<span class="string">&quot;black&quot;</span>&gt;2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">    &lt;li data-mark=<span class="string">&quot;black&quot;</span>&gt;4&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;5&lt;/li&gt;</span><br><span class="line">    &lt;li data-mark=<span class="string">&quot;black&quot;</span>&gt;6&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    oUl.addEventListener(<span class="string">&#x27;click&#x27;</span>,(e)=&gt;&#123;</span><br><span class="line">      <span class="keyword">if</span>(e.target.dataset.mark!==<span class="string">&#x27;black&#x27;</span>)<span class="built_in">return</span></span><br><span class="line">      console.log(<span class="string">&#x27;~~~~~~~~~`&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 好处是什么？</span></span><br><span class="line">只有点击到指定的自定义事件才会触发，减少误触的频率</span><br><span class="line">---------------------------------</span><br><span class="line"><span class="comment"># 原理</span></span><br><span class="line">事件委托则是将事件处理程序添加到父级元素上，利用冒泡机制实现在父元素上处理子元素的事件。</span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line">逐字稿: 把平常给子元素绑定的事件 统一给绑定到祖先元素身上， 比如说有很多个一样的事件， 这时候不需要给每一个子元素绑定事件， 我们会直接绑定到 父元素身上， 这样做性能就会很高 会对后续新增的元素也会有一样的效果， 底层原理是通过事件冒泡 冒泡到祖先元素身上。</span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下你对防抖和节流的理解？"><a href="#【JS】说一下你对防抖和节流的理解？" class="headerlink" title="【JS】说一下你对防抖和节流的理解？"></a>【JS】说一下你对防抖和节流的理解？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">防抖: 单位时间内高频事件, 只触发最后一次</span><br><span class="line">节流: 单位时间内高频事件, 只触发第一次</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line"><span class="comment"># 是什么？</span></span><br><span class="line">防抖和节流都是性能优化的一种手段，防抖就是持续触发（事件）不执行，不触发的一段时间后才执行：节流就是持续触发也执行，只不过执行的频率变低了。</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line"><span class="comment"># 在哪用?</span></span><br><span class="line">防抖：根据用户输入的内容发送请求。 场景：输入框</span><br><span class="line">节流：获取窗口滚动的位置。场景：滚动条</span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="comment"># 怎么做？</span></span><br><span class="line">一般可以结合定时器封装方法来实现，或者使用 lodash 提供的 throttle 方法。</span><br><span class="line">------------------------------------------------</span><br><span class="line">逐字稿： 防抖和节流都是性能优化的一种手段， 防抖就是持续触发（事件）不执行，不触发的一段时间后才执行；节流就是持续触发也执行，只不过执行的频率变低了。 有多低取决于节流时间是多少， 一般用的时候回考虑去封装函数来使用， 可能封装函数的时候回用到定时器相关的 或者使用 lodash 提供的 debounce 和 throttle 方法， 应用场景 根据用户输入的内容来发请求，这时候就可以用到防抖   <span class="comment"># 例如在窗口滚动的时候，希望获取到滚动位置，但是获取位置的频率不希望很高，这时候就可以考虑使用节流</span></span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下你对-EventLoop-衣闻特咯普-的理解？"><a href="#【JS】说一下你对-EventLoop-衣闻特咯普-的理解？" class="headerlink" title="【JS】说一下你对 EventLoop(衣闻特咯普) 的理解？"></a>【JS】说一下你对 EventLoop(衣闻特咯普) 的理解？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是什么?</span></span><br><span class="line">EventLoop又叫事件循环，是单线程语言js在运行代码是不被阻塞的一种机制</span><br><span class="line">--------------------------------------------</span><br><span class="line"><span class="comment"># 怎么用?</span></span><br><span class="line">--------------------------------------------</span><br><span class="line"><span class="comment"># 解决了什么问题？</span></span><br><span class="line">解决了js单线程的缺陷</span><br><span class="line">--------------------------------------------</span><br><span class="line"><span class="comment"># 好处是什么？</span></span><br><span class="line">代码永不堵塞</span><br><span class="line">------------------------------------</span><br><span class="line"><span class="comment"># 原理是什么？</span></span><br><span class="line">1-判断代码是<span class="string">&#x27;同步&#x27;</span>还是<span class="string">&#x27;异步&#x27;</span></span><br><span class="line">2-同步<span class="string">&#x27;立即执行&#x27;</span></span><br><span class="line">3-异步等<span class="string">&#x27;同步执行完毕&#x27;</span>在执行</span><br><span class="line">4-异步代码分<span class="string">&#x27;微任务和宏任务&#x27;</span></span><br><span class="line">5-<span class="string">&#x27;先&#x27;</span>执行微任务</span><br><span class="line">6-<span class="string">&#x27;后&#x27;</span>执行宏任务</span><br><span class="line">7-执行完毕, 如果还有宏任务没有执行, 则继续执行上面操作</span><br><span class="line">----------------------------------------------</span><br><span class="line">逐字稿：EventLoop是js的一种解决代码阻塞的运行机制，因为js是单线程运行，如果代码过多会形成上一个代码未运行完毕，下一个代码到了运行时间形成代码堵塞会大大降低代码的运行速度，所以EventLoop专门处理这个事情，他会将代码分为同步代码和异步代码，同步代码执行，异步代码后执行，而异步代码比同步代码复杂，所以又将异步代码分为了微任务和宏任务，微任务比宏任务的运行速度更快，所以会先执行微任务在执行宏任务，宏任务又会进行分析代码是同步还是异步，重复以往操作。</span><br></pre></td></tr></table></figure>
<h3 id="EventLoop额外问答-vue-一定是一秒打印吗？"><a href="#EventLoop额外问答-vue-一定是一秒打印吗？" class="headerlink" title="EventLoop额外问答? vue 一定是一秒打印吗？"></a>EventLoop额外问答? vue 一定是一秒打印吗？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="string">&#x27;react&#x27;</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">	console.log(&#x27;vue&#x27;)</span><br><span class="line"># &#x27;vue&#x27; 是一秒打印的吗？</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">console.log(&#x27;angular&#x27;)</span><br><span class="line"></span><br><span class="line">答：不一定，并官网是这样解释的</span><br><span class="line"># !零延迟</span><br><span class="line">零延迟并不意味着`回调会立即执行`。以 <span class="number">0</span> 为第二参数调用 setTimeout 并不表示在 <span class="number">0</span> 毫秒后就立即调用回调函数。</span><br><span class="line">其等待的时间取决于队列里`待处理的消息数量`。在下面的例子中，&quot;这是一条消息&quot; 将会在回调获得处理之前输出到控制台，这是因为延迟参数是运行时处理请求所需的最小等待时间，但并不保证是准确的等待时间。</span><br><span class="line">基本上，setTimeout 需要等待当前队列中所有的消息都处理完毕之后才能执行，即使已经&#x27;超出了由第二参数所指定的时间&#x27;。</span><br></pre></td></tr></table></figure>
<h3 id="如何保证vue中的代码一秒打印-使用web-worker开启js的多线程"><a href="#如何保证vue中的代码一秒打印-使用web-worker开启js的多线程" class="headerlink" title="如何保证vue中的代码一秒打印? 使用web worker开启js的多线程"></a>如何保证vue中的代码一秒打印? 使用web worker开启js的多线程</h3><blockquote>
<p>JavaScript其中一个基本的特性就是<code>单线程</code>,比如浏览器<code>无法同时运行</code>两个事件处理程序，也无法在一个事件处理程序运行的时候触发定时器。之所以设置单线程的理论就是，客户端的JavaScript的函数不能运行太长时间，否则会导致<code>循环事件</code>，Web浏览器无法对用户输入做出响应，这也是为什么AJAX的API都是异步的，以及为什么客户端Javascript不能使用一个简单的异步load()或者require()函数来加载javascript库。<br>在<code>Web Worker</code>标准中，定义了解决客户端JavaScript<code>无法多线程的问题</code>，其中定义的 “ Worker “ 是指执行代码的并行线程，不过，<code>Web Worker</code>处在一个自包含的执行环境中，无法访问 Window 对象和 Document 对象，和主线程之间的通信也只能通过异步消息传递机制实现，这就意味着，并行的修改DOM是不可能的。</p>
</blockquote>
<h3 id="【JS】如何并发请求且根据请求的书写顺序拿到对应的结果？"><a href="#【JS】如何并发请求且根据请求的书写顺序拿到对应的结果？" class="headerlink" title="【JS】如何并发请求且根据请求的书写顺序拿到对应的结果？"></a>【JS】如何并发请求且根据请求的书写顺序拿到对应的结果？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是什么？</span></span><br><span class="line">-----------------------------------------</span><br><span class="line"><span class="comment"># 怎么用？</span></span><br><span class="line">promise.all([])   &lt;------ all，接收一个数组，数组里面可以接收无数个请求</span><br><span class="line">都成功后会触发 .<span class="keyword">then</span>(r=&gt;&#123;&#125;)   r 一定是所有数据的结果，返回的数据顺序一定是传入数组的顺序</span><br><span class="line">如果中间有任意一个出错了，会触发 catch </span><br><span class="line">-----</span><br><span class="line">`<span class="comment"># 如果在 catch 后面又有一个 .then() 这个 then 会被触发吗？`</span></span><br><span class="line">答：一定会被触发，但是这个 .<span class="keyword">then</span>() 里面的结果一定是 undefined ，因为 .<span class="keyword">then</span>() 写在 catch() 后面，而catch()</span><br><span class="line">--------------------------------------</span><br><span class="line"><span class="comment"># 解决了什么问题？</span></span><br><span class="line"><span class="comment"># 有没有替代方案？</span></span><br><span class="line"><span class="comment"># 好处是什么？</span></span><br><span class="line"><span class="comment"># 场景是什么?</span></span><br><span class="line">我们使用了<span class="string">&#x27;Promise.all()&#x27;</span>方法来并发异步请求，并使用<span class="string">&#x27;map()&#x27;</span>方法来保证结果输出的顺序和输入的顺序一致。使用Promise.all()方法可以有效提高请求的并发效率，让请求尽可能同时进行，而不是一个一个等待。</span><br><span class="line"></span><br><span class="line">当所有请求都得到响应以后，Promise.all()方法会返回一个由所有请求的响应结果组成的数组 results(维肉特)，可以根据这个数组按照请求的先后顺序重新排列结果，以保证结果顺序与请求的顺序一致。最后我们通过遍历这个排好序的数组来输出每个响应结果的数据。</span><br><span class="line"></span><br><span class="line">这种方式比较简单，同时也非常实用，可以适用于各种场景，比如处理同时发起的多个请求，并根据请求的先后顺序来处理响应结果。</span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下你对-Promise-的理解？"><a href="#【JS】说一下你对-Promise-的理解？" class="headerlink" title="【JS】说一下你对 Promise 的理解？"></a>【JS】说一下你对 Promise 的理解？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">promise是ES6中新增的构造函数</span><br><span class="line">作用: 解决回调地狱, 层层嵌套, 异步回调</span><br><span class="line">原理: promise 中有三种执行状态, 分别是 立即执行（pending）、执行成功（fulfilled 佛非而特）、执行失败（rejected）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是什么?</span></span><br><span class="line">promise是ES6新增加的特性, 他是一个函数(构造函数)</span><br><span class="line">----------------------------------------------------</span><br><span class="line">Promise相关的几个静态方法？</span><br><span class="line">1、`Promise.race()`：接收多个 Promise 实例，可以得到`最先处理完毕`的结果（可能是成功，也可能是失败）。</span><br><span class="line"><span class="string">&#x27;Promise.race([p1,p2,p3])&#x27;</span></span><br><span class="line">2、`Promise.all()`：接收多个 Promise 实例，都成功了才会被触发 <span class="keyword">then</span>，有一个失败就会触发 catch 。 </span><br><span class="line"><span class="string">&#x27;Promise.all([p1,p2,p3]).then( r =&gt; console.log(r) )&#x27;</span></span><br><span class="line">// [p1 的结果，p2 的结果，p3 的结果]</span><br><span class="line">3、`Promise.any()`：接收多个 Promise 实例，可以得到`最先处理成功`的结果，都失败了才会触发 catch 。</span><br><span class="line"><span class="string">&#x27;Promise.any([p1，p2，p3])&#x27;</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment"># 解决了什么问题？</span></span><br><span class="line">它解决了回调地狱的问题。</span><br><span class="line"><span class="comment"># 有没有替代方案</span></span><br><span class="line">promise虽然解决了回到地狱的问题, 但是不能简化代码, 所以一般用的时候, 会使用async和await来配合promise, 这样的话既解决了回调地狱的问题也简化了代码</span><br><span class="line">----------------------------------------------------</span><br><span class="line"><span class="comment"># 怎么用?</span></span><br><span class="line">一般当做构造函数来使用, 也就意味着一般要new一下使用, 创建一个 Promise实例 他里面有三种状态, [padding立即执行, fulfilled成功和rejected失败],</span><br><span class="line">成功触发<span class="keyword">then</span> , 失败触发catch，还有一个finally是永远都会被触发。</span><br><span class="line">----------------------------------------------------</span><br><span class="line"><span class="comment"># Promise相关的几个静态方法？</span></span><br><span class="line">Promise.race()接收多个 promise 实例，可以得到最先处理完毕的结果（可能是成功，也可能是失败）</span><br><span class="line">Promise.race([p1,p2,p3])</span><br><span class="line"></span><br><span class="line">Promise.all()：接收多个Promise实例，都成功了会触发<span class="keyword">then</span>，有一个失败就会触发 catch</span><br><span class="line">Promise.all([p1,p2,p3])</span><br><span class="line"></span><br><span class="line">Promise.any()：接收多个Promise实例，可以得到最先处理成功的结果，都失败了才会触发catch</span><br><span class="line">Promise.any([p1,p2,p3])</span><br><span class="line">----------------------------------------------------</span><br></pre></td></tr></table></figure>
<h3 id="【JS】函数传参简单数据类型和复杂数据类型有什么差异？"><a href="#【JS】函数传参简单数据类型和复杂数据类型有什么差异？" class="headerlink" title="【JS】函数传参简单数据类型和复杂数据类型有什么差异？"></a>【JS】函数传参简单数据类型和复杂数据类型有什么差异？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数传参实际上就是<span class="string">&#x27;实参&#x27;</span>赋值给<span class="string">&#x27;形参&#x27;</span></span><br><span class="line">简单数据类型就是拷贝数据给形参, 一旦发生修改对原数据没有影响</span><br><span class="line">复杂数据类型就是拷贝地址给形参, 一旦发生改变对原数据有影响</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">简单数据类型传递的是值的拷贝，函数内部对参数的修改不会影响外部；</span><br><span class="line">复杂数据类型传递的是引用的地址，函数内部对<span class="string">&#x27;参数内容&#x27;</span>的修改会影响到外部，对<span class="string">&#x27;参数引用&#x27;</span>的修改不会影响到外部。</span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下图片懒加载的实现原理？"><a href="#【JS】说一下图片懒加载的实现原理？" class="headerlink" title="【JS】说一下图片懒加载的实现原理？"></a>【JS】说一下图片懒加载的实现原理？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是什么?</span></span><br><span class="line">图片懒加载是一种通过<span class="string">&#x27;延迟加载图片&#x27;</span>来优化网页性能的技术。</span><br><span class="line">------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 怎么用?</span></span><br><span class="line">1. 首先，在HTML中将需要懒加载的图片的src属性设置为一个占位符或空字符串：  <span class="comment"># 其中 data-src 属性用于存放真实的图片地址，src 则设置为占位符或空字符串。</span></span><br><span class="line">2.在JavaScript代码中，使用 window.addEventListener 方法来监听页面的滚动事件：</span><br><span class="line">3.在滚动事件中，遍历需要懒加载的图片元素，判断其相对于视窗的位置： <span class="comment"># 这里使用 getBoundingClientRect() 方法获取图片相对于视窗的位置，如果其顶部位置小于视窗高度，则表示该图片已经进入了视窗范围内，需要开始加载。</span></span><br><span class="line">4.在开始加载图片时，将占位符或空字符串的 src 属性替换为真实图片地址： <span class="comment"># 这里使用 dataset 属性获取 data-src 存放的真实图片地址，并将其赋值给 src 属性，此时图片即开始加载。同时，将原来设置的 lazy 类名移除，避免重复加载。</span></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决了什么问题?</span></span><br><span class="line">1.带宽和服务器负担 <span class="comment">#在传统的图片加载方式中，所有图片都会在页面加载时一次性加载，无论用户是否浏览。当页面中存在大量图片时，这会导致页面响应时间变慢，用户等待的时间加长，同时还会占用更多的带宽和服务器资源 , 而使用图片懒加载，只有用户滚动到相应区域时才会加载图片，大量减少了初始加载时需要加载的图片数量，从而减轻了带宽和服务器负担。</span></span><br><span class="line">2.用户体验：<span class="comment"># 使用图片懒加载可以提高用户的体验，特别是在移动设备上。在移动设备上，用户通常会花费更少的时间在页面上，因此减少等待时间和提高响应速度非常重要。使用懒加载可以使页面更快地呈现出来，用户不需要等待所有图片加载完成即可开始浏览页面，这可以显著提高用户的满意度和留存率。</span></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有没有替代方案</span></span><br><span class="line">1.`压缩图片`：在保证图片质量的前提下，压缩图片可以直接减小图片的大小，从而加快图片的加载速度。</span><br><span class="line"></span><br><span class="line">2.将图片转换为 `WebP 格式`：WebP 格式是一种高效的图片格式，通常比 JPEG 格式的图片大小减小 25%-35%。将网页中的图片转换为 WebP 格式可以减少图片的大小，从而加快页面的加载速度。</span><br><span class="line"></span><br><span class="line">3.使用 CSS3 的 `background-image 属性`：在一些场景下，可以使用 CSS3 的 background-image 属性来代替 img 标签加载图片。这种方式可以减少 HTTP 请求的数量，从而加快页面的加载速度。</span><br><span class="line"></span><br><span class="line">4.`预加载图片`：对于一些关键的图片，可以使用预加载的方式将图片在用户进入页面之前全部加载完成，从而避免滚动时出现的图片加载延迟。</span><br><span class="line">-----------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 好处是什么?</span></span><br><span class="line">- 使用图片懒加载可以优化网页性能，提高用户体验，同时减轻服务器负担和节省用户成本</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.加快网页加载速度：使用图片懒加载可以减少初始加载时需要下载的图片数量，从而加快网页的加载速度。尤其是对于大型图片和大量图片的网页，优化加载方式可以显著地缩短用户等待的时间，从而提高用户体验。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.减轻服务器负担：一次性加载大量图片会占用服务器资源和网络带宽，使用图片懒加载可以在一定程度上减轻服务器负担，降低服务端成本。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.节省用户流量：在移动设备上，用户流量往往很宝贵，使用图片懒加载可以减少用户需要消耗的流量，节省用户成本。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.提高页面性能：使用图片懒加载可以缩短页面的响应时间和渲染时间，降低页面的 CPU 和内存占用，从而提高页面的性能。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.改善用户体验：优化页面加载速度可以改善用户体验，用户不需要等待所有图片加载完成即可开始浏览页面，可以显著提高用户的满意度和留存率。</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="comment"># 场景是什么?</span></span><br><span class="line">网页中包含大量图片：<span class="comment"># 当一个网页中包含大量图片时，一次性下载所有图片会占用很多带宽和服务器资源，加重了网页的加载负担，容易导致用户等待时间过长。使用图片懒加载可以优化图片加载方式，只有当用户浏览到相应的图片时才进行下载，从而缩短页面加载时间。</span></span><br><span class="line"></span><br><span class="line">移动端网页：<span class="comment"># 在移动设备上，页面的加载速度是一个非常关键的因素。由于移动设备的带宽和处理能力有限，使用懒加载可以提高页面的响应速度，提高用户体验。</span></span><br><span class="line"></span><br><span class="line">长页面：<span class="comment"># 当一个页面非常长时，一次性下载所有图片也会导致页面加载缓慢，影响用户体验。使用图片懒加载则可以优化加载方式，使得用户只需加载当前部分所需要的图片，避免一次性下载大量图片的问题。</span></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="comment"># 原理是什么?</span></span><br><span class="line">在HTML中 图片的src属性被设置为`空字符串`或者`占位符图片`，在页面滚动到相应图片位置时，通过`监听滚动事件`来判断图片是否在可见区域内。如果是，则修改img标签的src属性，让图片开始加载，如果不是，则不进行加载，从而避免了一次性加载大量图片造成的性能问题。这样可以提高网站的加载速度和用户的体验。</span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line">逐字稿：有两种方法：位置计算、和浏览器提供的 IntersectionObserver</span><br><span class="line"><span class="string">&#x27;位置计算&#x27;</span>：如果【图片顶部距离窗口数值】小于等于【可视区文档的高度】，说明进入了可视区。</span><br><span class="line">浏览器新增的 IntersectionObserver：通过浏览器提供的 IntersectionObserver 对象创建一个实例，调用实例的 observe 方法可以观测某个img元素；在 IntersectionObserver 的参数回调里面可以通过 `isIntersecting` 属性来判断这个 img 元素是否进入可视区；如果进入就把 img 元素上装地址的某个属性给图片真正的 src 属性。</span><br><span class="line">图片懒加载的原理是：如果图片进入了可视区就把图片上装地址的某个属性给图片真正的 src 属性，如何判断图片进入了可视区？1.位置的计算、2.利用浏览器提供的API IntersectionObserver</span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下-null-和-undefined-的差异是什么？"><a href="#【JS】说一下-null-和-undefined-的差异是什么？" class="headerlink" title="【JS】说一下 null 和 undefined 的差异是什么？"></a>【JS】说一下 null 和 undefined 的差异是什么？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">null表示一个对象被定义了, 值为<span class="string">&quot;空值&quot;</span></span><br><span class="line">undefined表示不存在这个值</span><br><span class="line"></span><br><span class="line">undefined表示没有声明,并且值为空, null表示声明了, 没有赋值, == 只比较值 所以在值类型里面null==undefined  // <span class="literal">true</span></span><br><span class="line">他们值相等, 但是类型并不一样, 一个是声明了, 一个是未声明</span><br><span class="line"></span><br><span class="line">null==undefined   // <span class="literal">true</span></span><br><span class="line">只比较值类型的话两个的值都属于空, 所以类型相同</span><br><span class="line"></span><br><span class="line">null===undefined   // <span class="literal">false</span></span><br><span class="line">比较完值类型后比较数据类型, null是空值, 而undefined 是声明了未定义</span><br><span class="line"></span><br><span class="line">null + 数字 = 0</span><br><span class="line">undefi + 数字 = NaN</span><br><span class="line"></span><br><span class="line">------------------------------------------</span><br><span class="line">typeof 的表现 不同</span><br><span class="line">typeof null   // <span class="string">&#x27;object&#x27;</span></span><br><span class="line">typeof undefined   // <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">和数字相加的表现</span><br><span class="line">null + 4   //4</span><br><span class="line">undefined + 7   // NaN</span><br><span class="line"><span class="comment"># null和undefined在内部会自动调用 Number 这个方法将null和nudefined转换成数字类型</span></span><br><span class="line">// Number(null) // 0</span><br><span class="line">// Number(undefined) //NaN</span><br><span class="line">-----------------------------------------</span><br><span class="line"><span class="comment"># JSON.stringify  把undefined和null转换成 JSON 型，undefined会被忽略掉，null则会被保留下来</span></span><br><span class="line">JSON.stringify(&#123;foo:undefined,bar:null&#125;) // <span class="string">&#x27;&#123;bar:null&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="如何判断属性的数据类型？"><a href="#如何判断属性的数据类型？" class="headerlink" title="如何判断属性的数据类型？"></a>如何判断属性的数据类型？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">typeof</span> 检测一些基本的数据类型</span><br><span class="line">语法：<span class="keyword">typeof</span> 后面加不加括号都是可以用的</span><br><span class="line">注意：正则、&#123;&#125;、[]、<span class="literal">null</span>输出结果为object</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> /\d/);<span class="comment">//object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;);<span class="comment">//object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []);<span class="comment">//object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> (<span class="literal">null</span>));<span class="comment">//object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">123</span>);<span class="comment">//number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>);<span class="comment">//boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;);<span class="comment">//function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> (<span class="literal">undefined</span>));<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"># <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>()     万能检测数据类型</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([])) <span class="comment">// [object Array]</span></span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下你对闭包的理解？"><a href="#【JS】说一下你对闭包的理解？" class="headerlink" title="【JS】说一下你对闭包的理解？"></a>【JS】说一下你对闭包的理解？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># 是什么？</span><br><span class="line"># 闭包-- 在一个函数内部调用另一个函数体里面的局部变量就会形成闭包, 他是js中的被动技能, 可以比喻成空气一般无处不在</span><br><span class="line">闭包：【一个函数】使用了其【外部函数】中的局部变量，使用变量的地方我们称为发生了【闭包现象】，变量定义所在的函数我们称为【闭包函数】。</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="keyword">let</span> age = <span class="number">18</span></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> 	<span class="variable language_">console</span>.<span class="title function_">log</span>(age + <span class="number">1</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="title function_">foo</span>()</span><br><span class="line"><span class="title function_">bar</span>()</span><br><span class="line">--------------------------------------------------</span><br><span class="line"># 有什么用？ 特性?</span><br><span class="line">普通函数调用完毕，内部局部变量马上销毁。</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line">闭包函数调用完毕，会使内部形成这个【闭包函数】的变量（age）常驻内存，所以 <span class="string">`滥用`</span> 闭包会造成内存浪费。</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">18</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    age += <span class="number">1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="title function_">foo</span>() <span class="comment">// foo 中的 age 在内存中没有释放</span></span><br><span class="line"><span class="title function_">bar</span>()<span class="comment">//19</span></span><br><span class="line"><span class="title function_">bar</span>()<span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;只要符合了以上概览都是闭包&#x27;</span></span><br><span class="line">--------------------------------------------------</span><br><span class="line">-# 测试题</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line">-----</span><br><span class="line">;(<span class="keyword">function</span>(<span class="params"></span>)&#123;h</span><br><span class="line">    <span class="keyword">let</span> age = <span class="number">18</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(age + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">foo</span>()</span><br><span class="line">&#125;)()</span><br><span class="line">-----------------------------------------</span><br><span class="line"># 官网解释：</span><br><span class="line">闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。换而言之，闭包让开发者可以从<span class="string">&#x27;内部函数访问外部函数的作用域&#x27;</span>。在 <span class="title class_">JavaScript</span> 中，闭包会随着函数的创建而被同时创建。</span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下-localstorage-和-sessionStorage-及-Cookie-的差异？"><a href="#【JS】说一下-localstorage-和-sessionStorage-及-Cookie-的差异？" class="headerlink" title="【JS】说一下 localstorage 和 sessionStorage 及 Cookie 的差异？"></a>【JS】说一下 localstorage 和 sessionStorage 及 Cookie 的差异？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 都是用来存储数据的,</span><br><span class="line"><span class="variable language_">localStorage</span>是存储在硬盘空间的, 属于永久存储</span><br><span class="line">seeionStorage是存储在内存中的,属于临时存储, 电脑一旦关闭数据就丢失</span><br><span class="line"><span class="title class_">Cookie</span>是存储在客户端, 网页一旦关闭数据就会丢失</span><br><span class="line">-----------------------------------------------</span><br><span class="line"># 差异？ </span><br><span class="line"># 生命周期不一样</span><br><span class="line"><span class="variable language_">localStorage</span>：永久存储，除非手动删除。</span><br><span class="line">seesionStorage：关闭当前<span class="string">`页面`</span>后会自动清除</span><br><span class="line">cookie：默认关闭<span class="string">`浏览器`</span>后失效，如果设置了过期时间，则到达过期时间后才失效。</span><br><span class="line"></span><br><span class="line"># 生效范围不一样</span><br><span class="line"><span class="variable language_">localStorage</span>： 同域都可以共享。</span><br><span class="line">seesionStorage：只有当前标签页才能访问。</span><br><span class="line">cookie：同域下且 <span class="string">`path`</span> 匹配的情况下才能访问。</span><br><span class="line"></span><br><span class="line">什么是 <span class="string">`path`</span> 匹配？</span><br><span class="line">例如：<span class="attr">http</span>:<span class="comment">//www.xxx.com/ 下创建的 cookie 的时候加了 &#x27;path=/&#x27;,同域下的任意路径都可以访问，因为任意路径都属于&#x27;/&#x27;的子路径，又称为和&#x27;/&#x27;是匹配的。</span></span><br><span class="line">例如：<span class="attr">http</span>:<span class="comment">//www.xxx.com/a 下创建的 cookie 或者设置 cookie 的时候加了 &#x27;path=/a&#x27;,同域下和&#x27;/a&#x27;匹配的任意路径都能访问，例如&#x27;/a&#x27;、&#x27;/a/b&#x27;、&#x27;/a/c&#x27;、&#x27;/a/b/c&#x27; 等都称为是和 &#x27;/a&#x27; 匹配，或者称为是 &#x27;/a&#x27; 的子路径。除此之外&#x27;/&#x27;、&#x27;/b&#x27;、&#x27;/c&#x27;都和&#x27;/a&#x27;是不同域的</span></span><br><span class="line"></span><br><span class="line"># 存储大小不一样</span><br><span class="line"><span class="variable language_">localStorage</span>：<span class="number">4.</span>98MB(不同浏览器下会有差异，例如 <span class="title class_">Safari</span> <span class="number">2.</span>49M)。</span><br><span class="line">seesionStorage：<span class="number">4.</span>98MB</span><br><span class="line">cookie：4KB</span><br><span class="line"></span><br><span class="line"># 操作主体不一样</span><br><span class="line"><span class="variable language_">localStorage</span> / <span class="variable language_">sessionStorage</span>：只有客户端才能设置。</span><br><span class="line">cookie：客户端（<span class="variable language_">document</span>.<span class="property">cookie</span>）和服务端（<span class="title class_">Set</span>-<span class="title class_">Cookie</span>响应头）都可以设置。</span><br><span class="line"></span><br><span class="line"># 请求是否会携带</span><br><span class="line"><span class="variable language_">localStorage</span> / <span class="variable language_">sessionStorage</span>：请求时不会自动携带。</span><br><span class="line">cookie：每次请求都会随着请求头带到后端（符合同域且 path 匹配的条件）。</span><br></pre></td></tr></table></figure>
<h3 id="【JS】如何判断对象为空？"><a href="#【JS】如何判断对象为空？" class="headerlink" title="【JS】如何判断对象为空？"></a>【JS】如何判断对象为空？</h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">JSON.stringify()</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># chatGPT 回答</span><br><span class="line"># <span class="number">1.</span> 判断对象是否没有任何属性 可以使用 <span class="title class_">Object</span>.<span class="title function_">keys</span>() 方法获取对象的所有属性，然后判断属性的数量来确定对象是否为空。如果属性数量为<span class="number">0</span>，则表示对象为空。</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isObjectEmpty</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;; <span class="comment">// 空对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isObjectEmpty</span>(obj1)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;; <span class="comment">// 非空对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isObjectEmpty</span>(obj2)); <span class="comment">// false</span></span><br><span class="line">--------------------------------------------------------</span><br><span class="line"># <span class="number">2.</span> 判断对象的属性值是否全部为 <span class="literal">null</span> 或 <span class="literal">undefined</span> 通过遍历对象的所有属性值，判断它们是否为 <span class="literal">null</span> 或 <span class="literal">undefined</span>。如果所有属性值都是 <span class="literal">null</span> 或 <span class="literal">undefined</span>，则表示对象为空。</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isObjectEmpty</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj[key] !== <span class="literal">null</span> &amp;&amp; obj[key] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">name</span>: <span class="literal">null</span>, <span class="attr">age</span>: <span class="literal">undefined</span> &#125;; <span class="comment">// 空对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isObjectEmpty</span>(obj1)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;; <span class="comment">// 非空对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isObjectEmpty</span>(obj2)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>、搭配使用,判断不可</span><br><span class="line"><span class="keyword">const</span> s = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  [s]:<span class="number">28</span>,</span><br><span class="line">  <span class="attr">name</span>:<span class="number">48</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(o).<span class="title function_">concat</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(<span class="number">0</span>).<span class="property">length</span>===<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下-for-in-和-for-of-的区别？"><a href="#【JS】说一下-for-in-和-for-of-的区别？" class="headerlink" title="【JS】说一下 for in 和 for of 的区别？"></a>【JS】说一下 for in 和 for of 的区别？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">in</span> 和<span class="keyword">for</span> of区别</span><br><span class="line">相同点: 都是用于循环对象的</span><br><span class="line">不同点: </span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">in</span> 循环的是对象的key值</span><br><span class="line">	<span class="keyword">for</span> of 循环的是对象的value值</span><br><span class="line">	<span class="keyword">for</span> of是ES6新增的一个语法, 用于弥补<span class="keyword">for</span> <span class="keyword">in</span> 的不足, 所以<span class="keyword">for</span> <span class="keyword">in</span>一般用于遍历对象, <span class="keyword">for</span> of 一般用于遍历数组</span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下箭头函数和普通函数的差异？"><a href="#【JS】说一下箭头函数和普通函数的差异？" class="headerlink" title="【JS】说一下箭头函数和普通函数的差异？"></a>【JS】说一下箭头函数和普通函数的差异？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 箭头函数没有this指向</span><br><span class="line">2. 箭头函数没有构造函数</span><br><span class="line">3. 箭头函数的this指向上级作用域</span><br><span class="line">4. 使用箭头函数如果只有一个形参可以省略 小括号() , 如果在一行显示可以省略 花括号&#123;&#125;和<span class="built_in">return</span></span><br><span class="line">5. 箭头函数没有 prototype 和 arguments</span><br><span class="line">6. 在不需要使用this时可以使用箭头函数, 简化代码,看着更加美观</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">逐字稿： </span><br><span class="line">1. 箭头函数没有原型对象 prototype，不能作为构造函数使用（不能被new）。</span><br><span class="line">2. 箭头函数没有 arguments ，可以使用   ...   （...运算符）拿到所有实参的集合数组。</span><br><span class="line">3. 箭头函数的 this 在定义时就已经确定，取决于父级的环境。</span><br><span class="line">4. 箭头函数不能通过 call、apply、<span class="built_in">bind</span> 方法修改它的 this 指向（会忽略第一个参数，其他功能还是可以正常使用）</span><br><span class="line">5. 箭头函数不能用作 Generator 函数，不能使用 yeild 关键字（<span class="keyword">function</span> *） <span class="comment"># Generator语法规定函数要带 *   【function *】</span></span><br></pre></td></tr></table></figure>
<h3 id="【JS】什么是重绘和回流-重排-，如何减少？"><a href="#【JS】什么是重绘和回流-重排-，如何减少？" class="headerlink" title="【JS】什么是重绘和回流(重排)，如何减少？"></a>【JS】什么是重绘和回流(重排)，如何减少？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重绘: 当页面中的元素的属性(如背景、字体颜色、等等)发生改变,并没有影响布局时,浏览器为了节省性能 避免影响使用, 浏览器会对那个元素进行重新绘制渲染.</span><br><span class="line">回流: 当页面中元素的属性发生改变, 会影响到布局时,浏览器会重新计算属性并且重新布局, 这个过程特别消耗性能.</span><br></pre></td></tr></table></figure>
<h3 id="什么是内存泄露？"><a href="#什么是内存泄露？" class="headerlink" title="什么是内存泄露？"></a>什么是内存泄露？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 什么是内存泄露</span></span><br><span class="line">内存泄露是指程序运行是，分配的内存没有被正确的释放，导致内存空间的浪费，最终可能导致程序崩溃或运行缓慢。</span><br><span class="line"><span class="comment">// </span></span><br></pre></td></tr></table></figure>
<h3 id="JSON-parse-JSON-stringify-有哪些特点？"><a href="#JSON-parse-JSON-stringify-有哪些特点？" class="headerlink" title="JSON.parse/JSON.stringify 有哪些特点？"></a>JSON.parse/JSON.stringify 有哪些特点？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span>、对象包装的布尔值、数字、字符串，在序列化过程中，自动转换成对应的原始值</span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">8</span>),</span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(o))<span class="comment">// num: 8，直接转换成 原始数值</span></span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>、非数组对象的属性不能保证 以特定的顺序出现</span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">8</span>),</span><br><span class="line">  <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(o))<span class="comment">// 对象内部属性出现的顺序不能保证</span></span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>、<span class="title function_">toJSON</span>() 方法，该方法定义什么值将被序列化。</span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">8</span>),</span><br><span class="line">  <span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line">  <span class="title function_">toJSON</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">9</span> <span class="comment">// 当遇到toJSON时会先运行内部代码而忽略其他代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(o))</span><br><span class="line"></span><br><span class="line"># <span class="number">4</span>、<span class="literal">undefined</span>、任意的函数以及 symbol 值，在序列化过程中会被忽略</span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">fn</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,</span><br><span class="line">  <span class="attr">s</span>: <span class="title class_">Symbol</span>(),</span><br><span class="line">  <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(o))<span class="comment">//&#123;&quot;age&quot;:18&#125;，其他代码直接忽略</span></span><br><span class="line"></span><br><span class="line"># <span class="number">5</span>、对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">name</span>:<span class="string">&#x27;obj1&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; <span class="attr">name</span>:<span class="string">&#x27;obj2&#x27;</span> &#125;</span><br><span class="line">obj1.<span class="property">other</span> = obj2</span><br><span class="line">obj2.<span class="property">other</span> = obj1</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj1))</span><br><span class="line"></span><br><span class="line"># <span class="number">6</span>、<span class="title class_">NaN</span> 和 <span class="title class_">Infinity</span> 格式的数值及 <span class="literal">null</span> 都会被当做 <span class="literal">null</span>。</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">num1</span>: <span class="title class_">NaN</span> , <span class="attr">num2</span>: <span class="title class_">Infinity</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj1)) <span class="comment">// &#123;&quot;num1&quot;:null,&quot;num2&quot;:null&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><blockquote>
<p>可达性：“可达”值是那些以某种方式可访问或可用的值。它们一定是存储在内存中的。</p>
<p>内部算法：</p>
<ul>
<li>垃圾收集器找到所有的根，并“标记”（记住）它们。</li>
<li>然后它遍历并“标记”来自它们的所有引用。</li>
<li>然后它遍历标记的对象并标记 它们的 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。</li>
<li>……如此操作，直到所有可达的（从根部）引用都被访问到。</li>
<li>没有被标记的对象都会被删除。</li>
</ul>
<p>我们还可以将这个过程想象成从根溢出一大桶油漆，它流经所有引用并标记所有可到达的对象。然后移除未标记的。</p>
<p>这是垃圾收集工作的概念。JavaScript 引擎做了许多优化，使垃圾回收运行速度更快，并且不会对代码执行引入任何延迟。</p>
</blockquote>
<p>后端对垃圾回收的话一般需要做栈和堆相关的配置来配合垃圾回收机制。</p>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="Vue2和Vue3有哪些不同？"><a href="#Vue2和Vue3有哪些不同？" class="headerlink" title="Vue2和Vue3有哪些不同？"></a>Vue2和Vue3有哪些不同？</h3><blockquote>
<p>体积小：删除了很多API</p>
<p>响应式：</p>
<p>​    <code>vue2</code> 的响应性主要依赖 <code>Object.defineProperty</code> 进行实现，但是 <code>Object.defineProperty</code> 只能监听 <strong>指定对象的指定属性的 getter 行为和 setter 行为</strong>。</p>
<p>缺点：假如我们给<code>date</code>新增了一个对象 <code>person</code>，一旦给对象新增了一个属性，那么这个属性就不会是响应式的，原因就是Vue2中的<code>Object.defineProperty</code>无法监听到我们新增的这个一个属性。</p>
<p>解决办法：Vue2中提供了 <code>Vue.$set</code>可以解决这个问题，但是这个方法并不合理。</p>
<p>​    <code>Vue3</code> 响应式原理基础是   <code>Proxy</code></p>
<p>所以Vue3中引入了<code>反射(reflect)</code>和<code>代理(Proxy)</code>的一个概览。<code>反射指的就是 Reflect</code>，<code>代理指的就是 Proxy</code>，利用Proxy直接代理一个普通对象得到Proxy实例(代理对象)，在Vue3当中这样的一个过程我们把它叫做 <code>reactive</code>方法。</p>
<p>缺点：Proxy只能代理<code>复杂数据类型</code>的响应式，所以Vue额外提供了<code>ref</code>的方法，用来处理简单数据类型的响应式，本质上没有进行数据的监听而是构建了一个叫做 Reflmpl 的类，通过set和get标记类里面的value方法，以此来实现。所以必须要使用 <code>.value</code>去触发，本质上就是在调用 value函数。</p>
</blockquote>
<h3 id="宿主环境"><a href="#宿主环境" class="headerlink" title="宿主环境"></a>宿主环境</h3><h3 id="在vue2中的Object-defineProperty有哪些属性？"><a href="#在vue2中的Object-defineProperty有哪些属性？" class="headerlink" title="在vue2中的Object.defineProperty有哪些属性？"></a>在vue2中的<code>Object.defineProperty</code>有哪些属性？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">enumerable</span>(俺<span class="keyword">new</span>位波): <span class="literal">true</span>, <span class="comment">// 可枚举（是否可通过for...in 或 Object.keys()进行访问）</span></span><br><span class="line"><span class="title function_">configurable</span>(扛飞各薄): <span class="literal">true</span>, <span class="comment">// 可配置（是否可使用delete删除，是否可再次设置属性）</span></span><br><span class="line"><span class="comment">// value: &#x27;&#x27;, // 任意类型的值，默认undefined</span></span><br><span class="line"><span class="comment">// writable: true, // 可重写</span></span><br><span class="line"># writable 和 value 与 getter 和 setter 不共存。</span><br><span class="line"><span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="attr">set</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据变化视图不更新？"><a href="#数据变化视图不更新？" class="headerlink" title="数据变化视图不更新？"></a>数据变化视图不更新？</h3><h3 id="【Vue】说一下你对-Vuex-的理解？"><a href="#【Vue】说一下你对-Vuex-的理解？" class="headerlink" title="【Vue】说一下你对 Vuex 的理解？"></a>【Vue】说一下你对 Vuex 的理解？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">是什么?</span><br><span class="line">Vue.js 官方提供的一个状态管理模式库, 用于实现组件之间的状态共享和数据流控制</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">怎么用?</span><br><span class="line">核心就是一个全局的状态管理仓库，用于存储和管理应用中的所有状态</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">解决了什么问题?</span><br><span class="line">通过 Vuex，我们能够轻松地追踪应用状态的变化，管理状态的更新和响应</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">好处是什么?</span><br><span class="line">Vuex 可以帮助我们管理应用的状态，降低组件之间的耦合度，提高开发效率</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">原理是什么?</span><br><span class="line">Vuex 的核心原理是状态集中管理。Vuex 提供了一个全局的状态管理仓库，用于存储和管理应用中的所有状态，同时也提供了一系列的 API，使得组件能够方便地进行状态的读取、修改和监听。</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">逐字稿: vuex是一个全局的`状态`管理js库, 解决了非关系组件之间的`数据传递`和`共享`的问题, 一般在使用的时候 里面有常见的六个配置项 state(斯德特)、mutation(幂特性)、action(哎可行)、getter(给得)、module(猫丢)、plugins（猫丢斯） 等配置项</span><br><span class="line"></span><br><span class="line">需求：例如点击按钮发请求，需要把请求的结果存储到 Vuex。</span><br><span class="line">进入视图 使用 dispatch =&gt; action 在axtion里面发送请求 并拿到数据 拿到数据之后使用 commit =&gt; mutation 存储到  state state里面数据是响应式的 一旦视图里面数据发生变化 视图当中用到这个数据自然也会发生变化</span><br><span class="line"></span><br><span class="line">在使用期间 组件关系比较 清晰/明确 的情况下，会使用其他的方案去传递和共享，会使用 props（普拉普斯）、ref、EventBus（伊文特不斯）、Provide（普外的） 等方法。</span><br><span class="line">-----------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="string">&#x27;衍生问题&#x27;</span></span><br><span class="line"><span class="comment"># mutation 里面为什么建议只写同步代码去修改 state？写异步会怎样？</span></span><br><span class="line">如果在 mutation 中写异步代码去修改 state，可能会导致</span><br><span class="line">可能会使得状态更新缺乏可追溯性。如果在 mutation 中使用异步代码，那么对于其他开发人员来说，很难确定哪些函数在哪个时间点对 state 进行了更改，因为异步操作的执行时间是不确定的。</span><br><span class="line"></span><br><span class="line">可能会造成状态不一致的问题。如果在 mutation 中使用异步操作，例如执行一个异步请求，那么在异步请求返回之前，可能已经有其他函数对 state 进行了修改，而这些修改是基于异步请求之前的状态的，这样就可能导致状态不一致的问题。</span><br></pre></td></tr></table></figure>
<h3 id="【Vue】v-for-和-v-if-为什么不建议放一行？"><a href="#【Vue】v-for-和-v-if-为什么不建议放一行？" class="headerlink" title="【Vue】v-for 和 v-if 为什么不建议放一行？"></a>【Vue】v-for 和 v-if 为什么不建议放一行？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在 Vue 模板中， v-for 和 v-if 不建议同时放在同一个元素上，这是因为它们会影响彼此的行为。`v-for 会优先渲染整个列表`，而`v-if 会根据条件过滤列表`。如果两者放在同一个标签上，<span class="string">&#x27;那么v-if 可能会影响 v-for 的性能表现，导致它的更新速度变慢&#x27;</span>。</span><br><span class="line"></span><br><span class="line">当应用中数据变化较频繁时，v-if 可能会多次检查条件是否满足，而v-for 在每次循环中都会重新渲染列表。将它们放在同一行可能会对应用程序的性能产生负面影响。</span><br><span class="line">另外，将 v-for 和 v-if 分别放在不同的元素上，还可以更清晰地表达模板的意图，提高代码的可读性和可维护性。</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">解决了什么问题?</span><br><span class="line">将 v-for 和 v-if 分别放置在不同的元素上，可以提高代码的可读性和可维护性。另外，还可以提高应用程序的性能表现，避免因为v-if 检查条件的频繁调用而对 v-for 循环的性能产生负面影响</span><br><span class="line">---------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<h3 id="【Vue】Vue-响应式四连问？"><a href="#【Vue】Vue-响应式四连问？" class="headerlink" title="【Vue】Vue 响应式四连问？"></a>【Vue】Vue 响应式四连问？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="【Vue】hash-和-history-模式的差异是什么？router路由的工作模式？"><a href="#【Vue】hash-和-history-模式的差异是什么？router路由的工作模式？" class="headerlink" title="【Vue】hash 和 history 模式的差异是什么？router路由的工作模式？"></a>【Vue】hash 和 history 模式的差异是什么？router路由的工作模式？</h3><p>hash 模式是用 <code>createWebHashHistory()</code> 创建的</p>
<p>相同点：两种都是用来实现前端路由的(前端路由就是页面地址和组件之间的对应关系)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、</span><br><span class="line"><span class="attr">hash</span>:</span><br><span class="line"><span class="attr">history</span>:</span><br></pre></td></tr></table></figure>
<h3 id="【Vue】父传子都有哪些方法？"><a href="#【Vue】父传子都有哪些方法？" class="headerlink" title="【Vue】父传子都有哪些方法？"></a>【Vue】父传子都有哪些方法？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父组件传 :xxx=<span class="string">&quot;xxx&quot;</span> ，子组件收  <span class="attr">props</span>:&#123; xxx &#125; <span class="comment">// props传参</span></span><br><span class="line">方法传参：</span><br><span class="line">ref</span><br></pre></td></tr></table></figure>
<h3 id="【Vue】子传父都有哪些方法？"><a href="#【Vue】子传父都有哪些方法？" class="headerlink" title="【Vue】子传父都有哪些方法？"></a>【Vue】子传父都有哪些方法？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;方法名&#x27;</span>) <span class="comment">// 子组件向父组件传值</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$parent</span>.父组件方法名  <span class="comment">// 子组件获取父组件所有方法和属性，前提条件：父组件在应用子组件的时候，位置不能随意放，例如不能放在element UI组件的插槽里, 通常要放在根元素div里</span></span><br></pre></td></tr></table></figure>
<h3 id="【Vue】说一下-Vue-中的兄弟组件通信？"><a href="#【Vue】说一下-Vue-中的兄弟组件通信？" class="headerlink" title="【Vue】说一下 Vue 中的兄弟组件通信？"></a>【Vue】说一下 Vue 中的兄弟组件通信？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="【Vue】Vue-nextTick-和-eventLoop？"><a href="#【Vue】Vue-nextTick-和-eventLoop？" class="headerlink" title="【Vue】Vue nextTick 和 eventLoop？"></a>【Vue】Vue nextTick 和 eventLoop？</h3><h3 id="【Vue】你会在哪个钩子里面发请求为什么？"><a href="#【Vue】你会在哪个钩子里面发请求为什么？" class="headerlink" title="【Vue】你会在哪个钩子里面发请求为什么？"></a>【Vue】你会在哪个钩子里面发请求为什么？</h3><h3 id="【Vue】如何监听组件某个生命周期钩子的触发？"><a href="#【Vue】如何监听组件某个生命周期钩子的触发？" class="headerlink" title="【Vue】如何监听组件某个生命周期钩子的触发？"></a>【Vue】如何监听组件某个生命周期钩子的触发？</h3><h3 id="【Vue】说一下-computed-和-methods-及-watch-之间的差异？"><a href="#【Vue】说一下-computed-和-methods-及-watch-之间的差异？" class="headerlink" title="【Vue】说一下 computed 和 methods 及 watch 之间的差异？"></a>【Vue】说一下 computed 和 methods 及 watch 之间的差异？</h3><h3 id="【Vue】说一下你对-Vue3-的理解？（可以先跳过）"><a href="#【Vue】说一下你对-Vue3-的理解？（可以先跳过）" class="headerlink" title="【Vue】说一下你对 Vue3 的理解？（可以先跳过）"></a>【Vue】说一下你对 Vue3 的理解？（可以先跳过）</h3><h3 id="【Vue】v-show-和-v-if-的异同？"><a href="#【Vue】v-show-和-v-if-的异同？" class="headerlink" title="【Vue】v-show 和 v-if 的异同？"></a>【Vue】v-show 和 v-if 的异同？</h3><h3 id="【Vue】说一下-Vue-有哪些内置组件，分别是什么意思？"><a href="#【Vue】说一下-Vue-有哪些内置组件，分别是什么意思？" class="headerlink" title="【Vue】说一下 Vue 有哪些内置组件，分别是什么意思？"></a>【Vue】说一下 Vue 有哪些内置组件，分别是什么意思？</h3><h3 id="【Vue】Vue-父子组件嵌套的话，生命周期顺序是什么？"><a href="#【Vue】Vue-父子组件嵌套的话，生命周期顺序是什么？" class="headerlink" title="【Vue】Vue 父子组件嵌套的话，生命周期顺序是什么？"></a>【Vue】Vue 父子组件嵌套的话，生命周期顺序是什么？</h3><h3 id="【Vue】和-Vue-相关性能优化的手段你了解哪些？"><a href="#【Vue】和-Vue-相关性能优化的手段你了解哪些？" class="headerlink" title="【Vue】和 Vue 相关性能优化的手段你了解哪些？"></a>【Vue】和 Vue 相关性能优化的手段你了解哪些？</h3><h3 id="【Vue】和Vue相关的性能优化的手段有哪些？"><a href="#【Vue】和Vue相关的性能优化的手段有哪些？" class="headerlink" title="【Vue】和Vue相关的性能优化的手段有哪些？"></a>【Vue】和Vue相关的性能优化的手段有哪些？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># v-if 和 v-show 区分使用场景</span></span><br><span class="line">当需要频繁切换元素的可见性时，使用v-show会更具性能优势，但如果元素不经常切换可见性，则应该使用v-if。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 路由懒加载</span></span><br><span class="line">当页面中存在大量图片时，可以使用懒加载的方式，将页面中的图片延迟加载，减少初始渲染时的性能开销</span><br><span class="line"></span><br><span class="line"><span class="comment"># v-for 和 key</span></span><br><span class="line">在使用v-for渲染列表时，为每个元素添加一个唯一的key，可以帮助Vue跟踪元素的状态，减少不必要的DOM操作</span><br><span class="line"></span><br><span class="line"><span class="comment"># v-for 和 v-if 不建议放一行</span></span><br><span class="line">Vue2中 ： v-for优先级高于v-if.  尽量避免v-for与v-if一起使用。  因为每一次执行v-for的时候， v-if也会被执行一次，浪费性能</span><br><span class="line"></span><br><span class="line"><span class="comment"># 区分 计算属性 和 侦听器 （方法）的使用场景</span></span><br><span class="line">计算属性 和 监听器 可以通过缓存结果或异步计算来提升性能，从而帮助应用程序更快地响应用户操作。</span><br><span class="line"></span><br><span class="line"><span class="comment"># keep-alive缓存组件</span></span><br><span class="line">使用keep-alive可以缓存已经渲染过的组件，当组件被切换时，可以直接从缓存中读取，减少不必要的性能开销</span><br></pre></td></tr></table></figure>
<h3 id="watch监听时遇到的问题"><a href="#watch监听时遇到的问题" class="headerlink" title="watch监听时遇到的问题"></a>watch监听时遇到的问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视图更新，但是监听器内部代码并没有运行，说明监听对象并没有被监听到</span></span><br><span class="line">&lt;script setup lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">ref</span>(&#123;</span><br><span class="line">  <span class="attr">eat</span>: <span class="string">&#x27;西瓜&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">watch</span>(obj, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue)</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; obj.eat &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;obj.eat = &#x27;面条&#x27;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>改成面条<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 解决方式 <span class="number">1</span>：修改第一层</span><br><span class="line"><span class="comment">// 因为 watch 对 ref 数据的监听默认是 浅监听 ， 既然是浅监听，那可以直接修改第一层就好啦，也就是 obj.value。</span></span><br><span class="line"><span class="comment">// 这里的第一层 就是被监听对象自己，自己就是第一层，内部值则是第二层，需要开启深度监听才可以监听到内部代码或值。</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;obj = &#123;eat:&#x27;面条&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>改成面条<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 解决方式 <span class="number">2</span>:开启深度监听</span><br><span class="line"><span class="title function_">watch</span>(obj, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue)</span><br><span class="line">&#125;,&#123;</span><br><span class="line">  <span class="attr">deep</span>:<span class="literal">true</span>   <span class="comment">// 开启深度监听，可以监听到被监听对象内部代码或值</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 解决方式 <span class="number">3</span>: obj.<span class="property">value</span>强制开启深度监听</span><br><span class="line"><span class="comment">// ref 的 value 是一个 reactive 类型的， obj.value 是一个 reactive 数据，而 reactive 数据是强制开启深度监听的，并且不能修改。</span></span><br><span class="line"><span class="comment">// 判断这个对象的 value 值是不是一个 reavtive 类型的，因为 ref 内部还是借助 reactive 来执行的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(obj.<span class="property">value</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(obj.<span class="property">value</span>, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意点：直接监听 reactive ，对 reactive 本身的修改是不会触发监听的。</span></span><br><span class="line">&lt;button @click=<span class="string">&quot;obj=&#123;eat: &#x27;面条&#x27;&#125;&quot;</span>&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">code</span>&gt;</span>不会打印<span class="tag">&lt;/<span class="name">code</span>&gt;</span></span>&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 解决方式 <span class="number">4</span>：watch指定函数，返回ref</span><br><span class="line"><span class="comment">// 视图和数据发生变化，但是任何情况下都不会触发监听，除非开启 &#123;deep:true&#125;</span></span><br><span class="line">&lt;script setup lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">ref</span>(&#123;</span><br><span class="line">  <span class="attr">eat</span>: <span class="string">&#x27;西瓜&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ()=&gt;obj 把监听对象转为普通类型,丢失响应式</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>obj, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue)</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; obj.eat &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;obj.eat = &#x27;面条&#x27;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>面条<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;obj=&#123;eat:&#x27;馒头&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>馒头<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 解决方式 <span class="number">5</span>： watch指定函数, 返回 reactive (ref中的对象)</span><br><span class="line"><span class="comment">// 对这个 reactive 本身的修改会触发监听，但是对内部数据的修改则不会触发监听，开启 &#123;deep:true&#125; 后，对着两种情况都会触发监听。</span></span><br><span class="line">&lt;script setup lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">ref</span>(&#123;</span><br><span class="line">  <span class="attr">eat</span>: <span class="string">&#x27;西瓜&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改本身触发*/</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>obj.<span class="property">value</span>, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 都会触发 </span></span><br><span class="line"><span class="comment">watch(()=&gt;obj.value, (newValue) =&gt; &#123;</span></span><br><span class="line"><span class="comment">  console.log(newValue)</span></span><br><span class="line"><span class="comment">&#125;,&#123;</span></span><br><span class="line"><span class="comment">  deep:true</span></span><br><span class="line"><span class="comment">&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; obj.eat &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;obj.eat = &#x27;面条&#x27;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>面条<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;obj=&#123;eat:&#x27;馒头&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>馒头<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 解决方式 <span class="number">6</span>：watch指定函数，返回普通值</span><br><span class="line"><span class="comment">// 任何影响到此值的修改并且是响应式的，都会触发监听。</span></span><br><span class="line">&lt;script setup lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">ref</span>(&#123;</span><br><span class="line">  <span class="attr">eat</span>: <span class="string">&#x27;西瓜&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>obj.<span class="property">value</span>.<span class="property">eat</span>, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue)   <span class="comment">// 打印的是新值</span></span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; obj.eat &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;obj.eat = &#x27;面条&#x27;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>面条<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;obj=&#123;eat:&#x27;馒头&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>馒头<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Vue中哪些方法不会改变原数组"><a href="#Vue中哪些方法不会改变原数组" class="headerlink" title="Vue中哪些方法不会改变原数组?"></a>Vue中哪些方法不会改变原数组?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">是什么?</span><br><span class="line">push</span><br><span class="line">pop</span><br><span class="line">shift</span><br><span class="line">unshift</span><br><span class="line"></span><br><span class="line">怎么用?</span><br><span class="line">解决了什么问题?</span><br><span class="line">有没有替代方案?</span><br><span class="line">好处是什么?</span><br><span class="line">场景是什么?</span><br><span class="line">原理是什么?</span><br></pre></td></tr></table></figure>
<h3 id="常见的数据处理"><a href="#常见的数据处理" class="headerlink" title="常见的数据处理"></a>常见的数据处理</h3><p>处理后端返回的数据或把数据处理成后端想要的格式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 问题<span class="number">1</span></span><br><span class="line"><span class="comment">// 考察 1：用内置方法实现。</span></span><br><span class="line"><span class="comment">// 考察 2：自己模拟这些内置方法实现（flat、reduce、unique、sort...）</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">8</span>,<span class="number">1</span>,[<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>],<span class="number">2</span>,<span class="number">2</span>,[<span class="number">6</span>],<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,[<span class="number">4</span>,<span class="number">3</span>,[<span class="number">5</span>,<span class="number">4</span>],<span class="number">7</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> r = arr.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r)</span><br></pre></td></tr></table></figure>
<h3 id="vue-导出文件为pdf格式"><a href="#vue-导出文件为pdf格式" class="headerlink" title="vue 导出文件为pdf格式"></a>vue 导出文件为pdf格式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">推荐包 ---&gt; vue-to-pdf</span><br></pre></td></tr></table></figure>
<h3 id="new-Vue-的过程？发生了什么事情？"><a href="#new-Vue-的过程？发生了什么事情？" class="headerlink" title="new Vue 的过程？发生了什么事情？"></a>new Vue 的过程？发生了什么事情？</h3><blockquote>
<p><code>new Vue(&#123;传递一个对象)</code>，解析参数；初始化事件、挂载生命周期；处理 watch 监听、computed 以及数据劫持、解析模版，把模版交给 render 函数处理成虚拟 DOM ；把虚拟 DOM 解析成真实 DOM 进行挂载。</p>
</blockquote>
<h3 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装?"></a>组件封装?</h3><blockquote>
<p>单一职责：组件没有太多功能（可组合）</p>
<p>低耦合/高内聚：高内聚（一样的功能，封装到组件内部），低耦合（组件可以独立运行，放到任意地方都可以跑）</p>
<p>可定制：根据传参的不同，实现对应的效果（提前封装/定制好的），通过传值定制不同的形式效果</p>
<p>可拓展：外界可以决定做什么事情</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">强制缓存</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对比缓存/又称协商缓存</span><br></pre></td></tr></table></figure>
<h3 id="restful-API"><a href="#restful-API" class="headerlink" title="restful   API"></a>restful   API</h3><blockquote>
<p>restful API 是后端设置接口的一种风格，很直观，即便相同的请求地址，能根据请求方式的不同，实现不同的功能</p>
</blockquote>
<h3 id="HTTP是什么？什么是HTTP"><a href="#HTTP是什么？什么是HTTP" class="headerlink" title="HTTP是什么？什么是HTTP?"></a>HTTP是什么？什么是HTTP?</h3><blockquote>
<p>是客户端和服务端进行数据交互的协议（标准）。</p>
</blockquote>
<h3 id="axios的请求方式有哪些？-根据后端文档-axios-传参"><a href="#axios的请求方式有哪些？-根据后端文档-axios-传参" class="headerlink" title="axios的请求方式有哪些？/ 根据后端文档 axios 传参"></a>axios的请求方式有哪些？/ 根据后端文档 axios 传参</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">get</span>：只支持params传参 <span class="comment">// 一般用户获取数据</span></span><br><span class="line">axios.<span class="property">request</span></span><br><span class="line">axios.<span class="property">delete</span>：只支持params传参 <span class="comment">// 用于删除数据</span></span><br><span class="line">axios.<span class="property">head</span>：只支持params传参</span><br><span class="line">axios.<span class="property">options</span></span><br><span class="line">axios.<span class="property">post</span>： 同时支持  data 和 params <span class="comment">// 用于提交数据（新建）</span></span><br><span class="line">axios.<span class="property">put</span>： 同时支持  data 和 params <span class="comment">// 用于更新数据（修改）</span></span><br><span class="line">axios.<span class="property">patch</span>： 同时支持  data 和 params <span class="comment">// 用于更新数据（修改）单个修改，类似于补丁</span></span><br><span class="line"></span><br><span class="line">？号传参，query 传参</span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user？id=888&#x27;</span>)</span><br><span class="line">地址栏传参，params 传参</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">请求体传参</span><br><span class="line"># 格式：applicition/json</span><br><span class="line"># post传参</span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;/地址&#x27;</span>,&#123;传参&#125;)</span><br><span class="line">或</span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,<span class="comment">//请求方法</span></span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;后台接口地址&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: data,</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//执行成功后代码处理</span></span><br><span class="line">&#125;)</span><br><span class="line"># formData传参</span><br><span class="line"> <span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,<span class="comment">//请求方法</span></span><br><span class="line">    <span class="attr">data</span>: fromData,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;后台接口地址&#x27;</span>,</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//执行成功后代码处理</span></span><br><span class="line">&#125;)</span><br><span class="line"># 格式：application/x-www-form-urlencoded</span><br><span class="line"><span class="title function_">http</span>(&#123;</span><br><span class="line">  <span class="attr">method</span>:<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>:<span class="string">&#x27;接口地址&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>:&#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">data</span>:<span class="string">&#x27;username=ifer&amp;age=18&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"># 格式：application/multipart-formdata 表示文件上传格式</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span><br><span class="line">f.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>,e.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>])</span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;/file&#x27;</span>,f)</span><br></pre></td></tr></table></figure>
<h3 id="axios请求"><a href="#axios请求" class="headerlink" title="axios请求"></a>axios请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="comment">// `url` 是用于请求的服务器 URL</span></span><br><span class="line">	<span class="attr">url</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">	<span class="comment">// `method` 是创建请求时使用的方法</span></span><br><span class="line">	<span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>, <span class="comment">// 默认值</span></span><br><span class="line">  <span class="comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span></span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="comment">// `transformRequest` 允许在向服务器发送前，修改请求数据,它只能用于 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法</span></span><br><span class="line">  <span class="attr">transformRequest</span>: [<span class="keyword">function</span>(<span class="params">参数<span class="number">1</span>，参数<span class="number">2</span></span>)&#123;</span><br><span class="line">     <span class="comment">// 对发送的 data 进行任意转换处理</span></span><br><span class="line">     <span class="keyword">return</span> data;</span><br><span class="line">  &#125;]</span><br><span class="line">  <span class="comment">// 在传递给 then/catch 前，允许修改响应数据</span></span><br><span class="line">  <span class="attr">transformResponse</span>: [<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// 对接收的 data 进行任意转换处理</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="comment">// timeout 指定请求超时的毫秒数,如果请求时间超过 `timeout` 的值，则请求会被中断</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span> <span class="comment">// 默认值是 `0` (永不超时)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="axios封装"><a href="#axios封装" class="headerlink" title="axios封装"></a>axios封装</h3><blockquote>
<p>1、创建一个axios实例。</p>
<p>2、封装 baseURL、timeout。</p>
<p>​       封装 transformResponse。</p>
<p>3、请求拦截器（统一携带token）</p>
<p>4、响应拦截器</p>
<p>​    成功回调做数据脱壳 或 统一的错误处理 =&gt; 业务错误</p>
<p>​    失败回调做统一的错误处理（HTTP 状态码的错误）</p>
<p>​        无感刷新：一般 token 出于安全性的考虑，有效期不会设的很长，这样就会导致用户浏览网站的时间并不长，并且频繁登录体验不好。</p>
<p>​        解决方法：token 还是设置有效期很短当过期的时候回 401 ，在响应拦截器错误额地方 refresh_Token 调用后端接口拿到新 token ，更新到 vuex 和本地，重新把错误的请求重新发送一次。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后端返回的数据都是 JSON 格式的字符串，但是我们用到的时候竟然可以当做对象直接使用，为什么呢？</span></span><br><span class="line"><span class="comment">// 原因就是 axios 内部通过 JSON.parse 进行了转换，所以可以当做对象去使用，但是如果后端返回的数据是 &#x27;&#123;&quot;id&quot;:111111111111111111111&#125;&#x27;，axios 转换后 &#123;id: 111111111111111110000&#125;，转换后与后端返回的完全不同，如果拿去发送请求则会立即404，因为后端返回的格式是大数字格式（超过了安全范围 Number.MAX_SAFE_INTEGER，或，Math.pow(2,53)-1 称为大数字），</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">JSON</span>big = <span class="built_in">require</span>(<span class="string">&#x27;json-bigint&#x27;</span>);</span><br><span class="line">axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">	baseURL,</span><br><span class="line">  timeout,</span><br><span class="line">  <span class="comment">// json-bigint包可以帮助我们解决大数字问题</span></span><br><span class="line">  <span class="attr">transformResponse</span>:[<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="comment">// 默认</span></span><br><span class="line">    <span class="comment">// return JSON.parse(data)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">JSON</span>big.<span class="title function_">parse</span>(data) <span class="comment">// 转换大数字</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="axios取消请求"><a href="#axios取消请求" class="headerlink" title="axios取消请求"></a>axios取消请求</h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort">官网取消请求</a>应用场景 —- 点击切换页面或导航栏会发生请求，假如这时候用户切换的特别快那么一次就会发生多个请求，而我们只需要显示用户当前页面的请求，其他请求则不需要返回这时候就会浪费性能。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42018166/article/details/120705730?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=axios%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-120705730.142^v91^insertT0,239^v12^control2&amp;spm=1018.2226.3001.4187">取消请求博客</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果该请求已被发出，可以使用原生的 XMLHttpRequest.abort() 方法将终止该请求。</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET or POST&#x27;</span>, url);</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br><span class="line"><span class="comment">// 取消请求使用 xhr.abort()</span></span><br><span class="line">使用方式：</span><br><span class="line">  <span class="comment">// 创建全局变量，目的是为了存储取消请求的那个函数</span></span><br><span class="line">  <span class="keyword">let</span> cancel = <span class="literal">null</span>;</span><br><span class="line">  oBtn.<span class="property">onclick</span> = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> r = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;https://api-hmugo-web.itheima.net/api/public/v1/home/swiperdata&#x27;</span>, &#123;</span><br><span class="line">      <span class="comment">// 配置 cancelToken 参数</span></span><br><span class="line">      <span class="attr">cancelToken</span>: <span class="keyword">new</span> axios.<span class="title class_">CancelToken</span>(<span class="keyword">function</span>(<span class="params">c</span>) &#123;</span><br><span class="line">      <span class="comment">// c =&gt; 就是关闭当前请求的函数</span></span><br><span class="line">      cancel = c;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(r.<span class="property">data</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  oCancel.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">cancel</span>()</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>什么是跨域？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、代理服务器（正向代理 =&gt; 正客（正向代理） 反服），如果 <span class="title class_">Vue</span> <span class="title class_">ClI</span> 创建的项目，可以在 vue.<span class="property">config</span>.<span class="property">js</span> 中配置 devServer 的 <span class="title function_">proxy</span>(破克醒) 选项。</span><br><span class="line"><span class="number">2</span>、<span class="variable constant_">CORS</span>，后端通过设置 <span class="title class_">Access</span>(阿克赛斯)-<span class="title class_">Control</span>(康却)-<span class="title class_">Allow</span>(恶劳)-<span class="title class_">Origin</span> 响应头来允许访问某些域名访问</span><br><span class="line"><span class="number">3</span>、<span class="title class_">JSON</span>，缺点：只能处理 <span class="variable constant_">GET</span> 请求，利用 script 标签不存在跨域限制这一特点去实现的，因为 &lt;script&gt; 标签可以无视跨域限制</span><br></pre></td></tr></table></figure>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="Promise静态方法"><a href="#Promise静态方法" class="headerlink" title="Promise静态方法"></a>Promise静态方法</h3><h2 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h2><h3 id="TS"><a href="#TS" class="headerlink" title="TS"></a>TS</h3><h4 id="type-和-interface-的异同"><a href="#type-和-interface-的异同" class="headerlink" title="type 和 interface 的异同"></a>type 和 interface 的异同</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">相同点：</span><br><span class="line"># <span class="number">1</span>、都能描述对象，但是 type 还能描述其他任意类型，例如 string、number 等基本类型、联合或交叉等类型</span><br><span class="line"># <span class="number">2</span>、都能进行类型拓展，interface 通过<span class="keyword">extends</span>来实现，type通过 &amp; 交叉运算符号形成交叉类型。</span><br><span class="line">interface I2d&#123;</span><br><span class="line">  <span class="attr">x</span>:number</span><br><span class="line">  <span class="attr">y</span>:number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface I3d <span class="keyword">extends</span> I2d &#123;</span><br><span class="line">  <span class="attr">z</span>:number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">the3</span>:I3d = &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="number">4</span>,</span><br><span class="line">  <span class="attr">y</span>:<span class="number">7</span>,</span><br><span class="line">  <span class="attr">Z</span>:<span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><h4 id="webpack是什么-什么是webpack"><a href="#webpack是什么-什么是webpack" class="headerlink" title="webpack是什么? / 什么是webpack"></a>webpack是什么? / 什么是webpack</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">是什么?</span><br><span class="line">webpack是<span class="string">&#x27;静态资源打包工具&#x27;</span></span><br><span class="line">可以处理一个或多个Javascript应用程序和库的依赖关系，并生成相应的静态资源</span><br><span class="line">如Javascript (js)文件、样式表、图片等。</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">怎么用?</span><br><span class="line">解决了什么问题?</span><br><span class="line">有没有替代方案?</span><br><span class="line">好处是什么?</span><br><span class="line">场景是什么?</span><br><span class="line">原理是什么?</span><br></pre></td></tr></table></figure>
<h4 id="什么是websocket协议"><a href="#什么是websocket协议" class="headerlink" title="什么是websocket协议?"></a>什么是websocket协议?</h4><blockquote>
<p>用于提供<code>低延迟</code>、<code>全双工</code>、<code>长期运行</code>的连接。</p>
<p>全双工：通信的两个参与方可以同时发送和接收数据，不需要等待对方的响应式或传输完成。</p>
<p>可以说websocket的出现就是为了解决实时通信的问题。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">传统的通信：电子邮箱、网页浏览、存在延迟，需要用户主动请求来获取更新数据</span><br><span class="line">实时通信：即使消息传递、音视频通话、在线会议和实时数据传输等，可以实现即时的数据传输和交流，不需要用户主动请求或刷新来获取更新数据</span><br><span class="line"></span><br><span class="line">在 websocket 之前通信方式：</span><br><span class="line"><span class="string">&#x27;轮询&#x27;</span>：就是客户端定期不间断的向后端发送请求，询问是否有新数据产生，服务器接收数据后检查是否有新数据并返回给前端。</span><br><span class="line"><span class="string">&#x27;缺点&#x27;</span>：会产生大量的请求和响应，导致不必要的网络开销和延迟。</span><br><span class="line"><span class="string">&#x27;思路&#x27;</span>：设置定时器不间断向服务器发送请求。</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;长轮询&#x27;</span>：基于<span class="variable constant_">HTTP</span>的技术，在客户端发出请求后，保持连接打开，在服务器有新数据可以使用时返回给前端，在关闭连接。解决了无效轮询的数量</span><br><span class="line"><span class="string">&#x27;缺点&#x27;</span>：需要频繁的建立连接和关闭连接</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;Comet&#x27;</span>(扣曼特)：基于<span class="variable constant_">HTTP</span>的技术，在客户端发出请求后继续保持连接，核心通过保持长连接模拟实时通信，并允许服务器通过<span class="string">&#x27;流式传输、frame &#x27;</span>等推送技术来主动向客户端推送数据。</span><br><span class="line"><span class="string">&#x27;缺点&#x27;</span>：推送方式还是通过延长响应或推送技巧来实现的。</span><br><span class="line"></span><br><span class="line">websocket对比优势：</span><br><span class="line"><span class="string">&#x27;双向实时通信&#x27;</span>：允许在单个、长时间的连接上进行双向实时通信。在需要快速实时更新的应用程序里比 <span class="variable constant_">HTTP</span> 更加高效。</span><br><span class="line"><span class="string">&#x27;降低延迟&#x27;</span>：链接一旦建立会保持开放，数据可以在客户端和服务器之间比 <span class="variable constant_">HTTP</span> 更低的延迟进行传输。</span><br><span class="line"><span class="string">&#x27;更高效的资源利用&#x27;</span>：减少重复请求和响应的开销，因为连接只需要建立一次。</span><br><span class="line"><span class="string">&#x27;优点&#x27;</span>：允许客户端或服务器之间通过单个 <span class="variable constant_">TCP</span> 连接进行双工通信，并且进行实时的数据交换。</span><br><span class="line"></span><br><span class="line">如何建立 websocket 连接？</span><br><span class="line">通过 <span class="variable constant_">HTTP</span> 发送一次常规的 get请求，在请求头中带上 <span class="title class_">Upgrade</span>，告诉服务器从 <span class="variable constant_">HTTP</span> 升级成 <span class="title class_">Websocket</span>，连接就建立成功</span><br></pre></td></tr></table></figure>
<h4 id="websocket心跳机制"><a href="#websocket心跳机制" class="headerlink" title="websocket心跳机制"></a>websocket心跳机制</h4><blockquote>
<p>为了保持 Websocket 稳定的长连接，在连接建立之后，服务器和客户端之间通过<code>心跳包</code>来保持连接状态，以防止连接因为长时间没有数据传输而被切断。</p>
<p><code>心跳包</code>：一种特殊的数据包，不包含任何实际数据，仅用来维持连接状态。</p>
<p>原理：定期发送一个空的数据帧，确保双方之间的连接仍然有效，避免长时间没有数据传输而中断，一段时间内没有收到对方的心跳包，就可以认为连接已经断开，需要重新建立连接。</p>
<p>缺点：</p>
<p>不提供加密功能，可使用 SSL 协议，设置黑白名单弥补。</p>
<p>不支持古老浏览器，如IE10以前版本，需要使用 AJAX 或其他方式替代。</p>
<p>长连接会过渡消耗资源，需要不断的维护和处理连接状态，需要优化性能。</p>
</blockquote>
<h3 id="Nginx？"><a href="#Nginx？" class="headerlink" title="Nginx？"></a>Nginx？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">如果是 history 的路由模式，上线的时候需要 <span class="title class_">Nginx</span> 做配置，否则会 <span class="number">404</span></span><br><span class="line">原因：history 的每一次跳转对于后端来说都是一个新的请求，后端如果没有匹配这个请求就会 <span class="number">404</span></span><br><span class="line">解决方法：把浏览器地址栏的请求转发到 index.<span class="property">html</span>，index.<span class="property">html</span> 中加载的有前端路由代码，所以就会交给前端路由去处理</span><br><span class="line"></span><br><span class="line"><span class="comment">/*location / &#123;</span></span><br><span class="line"><span class="comment">    # 设置不论请求什么地址，都返回 index.html</span></span><br><span class="line"><span class="comment">    try_files $uri $uri/ /index.html;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Nginx</span> 转发，代理配置</span><br><span class="line">包含 /prod-api，都转发到  <span class="attr">https</span>:<span class="comment">//heimahr-t.itheima.net;</span></span><br><span class="line"><span class="comment">/*location /prod-api  &#123;</span></span><br><span class="line"><span class="comment">  proxy_pass https://heimahr-t.itheima.net;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure>
<h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后端返回的是文件流</span></span><br><span class="line"><span class="number">1</span>、利用 a标签 的 download 属性可以下载（服务器环境下测试） &lt;a download&gt;&lt;/a&gt;</span><br><span class="line"><span class="number">2</span>、推荐这个包  ---&gt;   file-saver</span><br></pre></td></tr></table></figure>
<h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><h3 id="为什么使用-uni-app？"><a href="#为什么使用-uni-app？" class="headerlink" title="为什么使用 uni-app？"></a>为什么使用 uni-app？</h3><p>为了使用 Vue 的语法，上手成本低；一套代码可以多端使用（我们这一版主要针对的是小程序端，后续可能拓展的其他端）。</p>
<h3 id="小程序客服"><a href="#小程序客服" class="headerlink" title="小程序客服?"></a>小程序客服?</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置一个 &lt;buttn&gt; 按钮，给按钮添加 <span class="string">&#x27;open-type&#x27;</span> 属性为 <span class="string">&#x27;contact&#x27;</span>，进入客服会话。</span><br></pre></td></tr></table></figure>
<h3 id="小程序中分享怎么做的？"><a href="#小程序中分享怎么做的？" class="headerlink" title="小程序中分享怎么做的？"></a>小程序中分享怎么做的？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给按钮设置 share 触发用户转发</span></span><br><span class="line">&lt;button open-type=<span class="string">&quot;share&quot;</span>&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户点击按钮后触发 Page.onShareAppMessage 事件</span></span><br><span class="line"><span class="title function_">onShareAppMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;分享标题&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;查看路径&#x27;</span>,</span><br><span class="line">      <span class="attr">imageUrl</span>: <span class="string">&#x27;封面地址&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="小程序扫码功能实现"><a href="#小程序扫码功能实现" class="headerlink" title="小程序扫码功能实现"></a>小程序扫码功能实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定点击事件</span></span><br><span class="line">&lt;button <span class="keyword">class</span>=<span class="string">&quot;btn-bottom&quot;</span> <span class="attr">bind</span>:tap=<span class="string">&quot;saomasuy&quot;</span>&gt;扫码&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 wx.scanCode 唤醒用户相机</span></span><br><span class="line">wx.<span class="title function_">scanCode</span>(斯给扣得)(&#123; <span class="comment">//唤醒相机，调起客户端扫码界面进行扫码</span></span><br><span class="line">  <span class="title function_">onlyFromCamera</span>(安立否开幕): <span class="literal">false</span>, <span class="comment">// false 允许从相册扫码，true 不允许从相册扫码</span></span><br><span class="line">  <span class="title function_">success</span>(c格赛斯): <span class="keyword">function</span> (<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="comment">// console.log(a.scanType) // 获取扫码类型</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="小程序登录流程"><a href="#小程序登录流程" class="headerlink" title="小程序登录流程"></a>小程序登录流程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">逐字稿：</span><br><span class="line"><span class="number">1</span>、小程序端调用 wx.<span class="title function_">login</span>() 获取 code（临时登录凭证 ）。</span><br><span class="line"><span class="number">2</span>、通过 wx.<span class="title function_">request</span>() 发送 code 到后端。</span><br><span class="line"><span class="number">3</span>、后端调用 codeSession（登录凭证校验的函数）并且传递 appid（小程序 <span class="variable constant_">ID</span>）、<span class="title function_">appsecret</span>(app c扣瑞的)（小程序密钥）、code（临时登录凭证） 到微信的后台。</span><br><span class="line"><span class="number">4</span>、微信后台返回到后端 session_key、openid（用户唯一标识）。</span><br><span class="line"><span class="number">5.</span> 后端把 openid和session_key 进行关联,形成自定义登录态（生成 token）并返回 token 到前端。</span><br><span class="line"><span class="number">6.</span> 前端拿到数据并进行存储（持久化）token 到本地，后续再用 wx.<span class="title function_">request</span>() 发请求的时候携带 token。</span><br><span class="line"><span class="number">7.</span> 后端通过 token 查询关联的 openid，明确身份后返回信息给前端。</span><br></pre></td></tr></table></figure>
<h3 id="配置-webpack-的排除打包效果-CDN"><a href="#配置-webpack-的排除打包效果-CDN" class="headerlink" title="配置 webpack 的排除打包效果 CDN"></a>配置 webpack 的排除打包效果 CDN</h3><blockquote>
<p>externals 排除不需要的文件后，配合CDN将样式加载过来</p>
</blockquote>
<p>DOM Diff算法</p>
<blockquote>
<p>Diff算法又称快速 diff 算法</p>
<p>借鉴：ivi 和 inferno +纯文本 diff 算法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">diff算法的执行过程</span><br><span class="line"><span class="number">1</span>、预处理 前 置节点</span><br><span class="line"><span class="number">2</span>、预处理 后 置节点</span><br><span class="line"><span class="number">3</span>、处理 仅有新增 节点情况</span><br><span class="line"><span class="number">4</span>、处理 仅有卸载 节点情况</span><br><span class="line"><span class="number">5</span>、处理 其他 情况(新增/卸载/移动)</span><br></pre></td></tr></table></figure>
<h3 id="国际化语言"><a href="#国际化语言" class="headerlink" title="国际化语言"></a>国际化语言</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Echarts适配"><a href="#Echarts适配" class="headerlink" title="Echarts适配"></a>Echarts适配</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方案</span><br><span class="line">布局 =&gt; 百分比布局</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123; echarts.<span class="title function_">resize</span>() &#125;)<span class="comment">// resize(V晒日) 适配</span></span><br><span class="line">包 =&gt; v-scale-screen 大屏适配</span><br></pre></td></tr></table></figure>
<h3 id="切换主题和restfulApi"><a href="#切换主题和restfulApi" class="headerlink" title="切换主题和restfulApi"></a>切换主题和restfulApi</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、完善页面样式结构</span><br><span class="line">  .<span class="property">box</span>&#123;</span><br><span class="line">    <span class="attr">color</span>:red</span><br><span class="line">  &#125;</span><br><span class="line"><span class="number">2</span>、准备一个 &lt;button&gt; 按钮</span><br><span class="line">&lt;button&gt;&lt;/button&gt;</span><br><span class="line"><span class="number">3</span>、给按钮绑定页面样式</span><br><span class="line">&lt;button <span class="keyword">class</span>=<span class="string">&quot;theme&quot;</span>&gt;&lt;/button&gt;</span><br><span class="line">  .<span class="property">theme</span> .<span class="property">box</span>&#123;</span><br><span class="line">    <span class="attr">color</span>:blue</span><br><span class="line">  &#125;</span><br><span class="line"><span class="number">4</span>、给按钮绑定一个点击事件</span><br><span class="line">&lt;button <span class="keyword">class</span>=<span class="string">&quot;theme&quot;</span> id=<span class="string">&quot;oBtn&quot;</span>&gt;&lt;/button&gt;</span><br><span class="line">oBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;theme&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">逐字稿：首先我们准备多套样式，我们可以通过最外面的标签去添加样式，这个标签控制的就是网站所有的颜色样式，代码只需要去操控样式就可以了</span><br></pre></td></tr></table></figure>
<h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"># <span class="title class_">Vue2</span></span><br><span class="line">以下类型为  --&gt; 类型：<span class="title class_">Function</span></span><br><span class="line">-----四个阶段-八大钩子-----</span><br><span class="line">第一阶段-初始化阶段</span><br><span class="line">beforeCreate</span><br><span class="line">created</span><br><span class="line">第二阶段-渲染阶段</span><br><span class="line">beforeMount</span><br><span class="line">mounted</span><br><span class="line">第三阶段-更新阶段</span><br><span class="line">beforeUpdate</span><br><span class="line">updated</span><br><span class="line">第四阶段-卸载阶段</span><br><span class="line">beforeDestroy</span><br><span class="line"><span class="title function_">destroyed</span>(蒂斯状)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被 keep-alive 缓存的组件调用。</span></span><br><span class="line">activated -- 激活</span><br><span class="line">deactivated -- 失活</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue2新增钩子</span></span><br><span class="line">errorCaptured ---&gt; 在捕获一个来自后代组件的错误时被调用。</span><br><span class="line"></span><br><span class="line"># <span class="title class_">Vue3</span></span><br><span class="line">setup   ---&gt; 替换了 beforeCreate 和 created 比之前更快</span><br><span class="line">onBeforeMount</span><br><span class="line">onMounted</span><br><span class="line"></span><br><span class="line">onBeforeUpdate</span><br><span class="line">onUpdated</span><br><span class="line"></span><br><span class="line">onBeforeUnmount</span><br><span class="line">onUnmounted</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被 keep-alive 缓存的组件调用。</span></span><br><span class="line">onActivated</span><br><span class="line">onDeactivated</span><br><span class="line">onErrorCaptured</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 小程序</span><br><span class="line"># 应用生命周期</span><br><span class="line">onLaunch：初始化钩子，只触发一次</span><br><span class="line">onShow：回到当前页面时触发</span><br><span class="line">onHide：离开当前页时触发</span><br><span class="line">onError：错误监听函数</span><br><span class="line">onPageNotFound：页面不存在</span><br><span class="line">onUnhandledRejection：未处理的 <span class="title class_">Promise</span> 拒绝事件监听函数。</span><br><span class="line">onThemeChange：系统切换主题时触发</span><br><span class="line"></span><br><span class="line"># 页面生命周期</span><br><span class="line">onLoad：页面初始化钩子，只触发一次</span><br><span class="line">onShow：回到当前页面时触发</span><br><span class="line">onReady：页面初次渲染完成时触发，只触发一次</span><br><span class="line">onHide：离开当前页时触发</span><br><span class="line">onUnload：页面卸载时触发</span><br><span class="line">onRouteDone：路由动画完成时触发</span><br><span class="line">onPullDownRefresh：页面相关事件处理函数 比如 用户下拉刷新事件</span><br><span class="line">onReachBottom：页面上拉触底事件的处理函数</span><br><span class="line"><span class="string">&#x27;需要在 app.json 里面的 window 配置 onReachBottomDistance：距离px，默认50px&#x27;</span></span><br><span class="line"></span><br><span class="line">onShareAppMessage：右上角分享按钮</span><br><span class="line"></span><br><span class="line"># 组件生命周期</span><br><span class="line">created：组件实例被创建时触发</span><br><span class="line">attached：进入页面时触发</span><br><span class="line">detached：组件实例被从页面节点树移除时执行</span><br><span class="line">ready：组件在视图布局完成后执行</span><br><span class="line">move：组件实例被移动到节点树另一个位置时执行</span><br><span class="line">error：每当组件方法抛出错误时执行</span><br></pre></td></tr></table></figure>
<h3 id="什么是微前端？"><a href="#什么是微前端？" class="headerlink" title="什么是微前端？"></a>什么是微前端？</h3><blockquote>
<p>老牌：<a target="_blank" rel="noopener" href="https://qiankun.umijs.org/zh/guide">qiankun</a></p>
<p>新技术：iframe</p>
<p>2016 年首次出现将后端<strong>微服务</strong>的概念扩展到了前端世界，<strong>微前端不是单纯的前端框架或者工具，而是一套架构体系</strong>，可以按照一定的规则，拆分为不同的子应用，独立开发，独立部署，然后聚合成一个完整的应用</p>
<p><code>微前端核心</code>：</p>
<p>​    技术栈无关：不限制技术栈，具备自主权</p>
<p>​    独立开发、独立部署：仓库独立，前后端独立开发，部署完成后主框架自动完成同步更新</p>
<p>​    增量升级：在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略</p>
<p>​    独立运行时：每个微应用之间状态隔离，运行时状态不共享</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add qiankun # 或者 npm i qiankun -S</span><br></pre></td></tr></table></figure>
<h2 id="为什么用qukun不用iframe无界"><a href="#为什么用qukun不用iframe无界" class="headerlink" title="为什么用qukun不用iframe无界"></a>为什么用qukun不用iframe无界</h2><blockquote>
<p>iframe：在一个<code>web</code>应用中可以<strong>独立</strong>的运行另一个<code>web</code>应用。</p>
<p>优点：</p>
<ul>
<li><strong>非常简单</strong>，使用没有任何心智负担</li>
<li><strong>隔离完美</strong>，无论是 js、css、dom 都完全隔离开来</li>
<li><strong>多应用激活</strong>，页面上可以摆放多个<code>iframe</code>来组合业务</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>路由状态丢失</strong>，刷新一下，iframe 的 url 状态就丢失了</li>
<li><strong>dom 割裂严重</strong>，弹窗只能在 iframe 内部展示，无法覆盖全局</li>
<li><strong>通信非常困难</strong>，只能通过 postmessage 传递序列化的消息</li>
<li><strong>白屏时间太长</strong>，对于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8"><strong>SPA 应用</strong></a>应用来说无法接受</li>
</ul>
</blockquote>
<h2 id="什么是3D？3D模型解析"><a href="#什么是3D？3D模型解析" class="headerlink" title="什么是3D？3D模型解析"></a>什么是3D？3D模型解析</h2><p><a target="_blank" rel="noopener" href="https://pixijs.com/">pixijs</a> 3D框架偏2D为主</p>
<blockquote>
<p>@splinetool/runtime</p>
</blockquote>
<h2 id="Mock-js是什么？"><a href="#Mock-js是什么？" class="headerlink" title="Mock.js是什么？"></a>Mock.js是什么？</h2><p><a target="_blank" rel="noopener" href="https://gitee.com/ifercarly/mockjs">Mock语法</a></p>
<blockquote>
<p>一款模拟数据生成器，旨在帮助前端攻城师独立于后端进行开发，帮助编写单元测试。</p>
<p>功能：</p>
<ul>
<li><p>根据数据模板生成模拟数据</p>
</li>
<li><p>模拟 Ajax 请求，生成并返回模拟数据</p>
</li>
<li><p>基于 HTML 模板生成模拟数据</p>
</li>
</ul>
<p>书写格式：<code>&#39;属性名|生成规则&#39;</code>：属性值</p>
</blockquote>
<h2 id="项目打包优化手段"><a href="#项目打包优化手段" class="headerlink" title="项目打包优化手段"></a>项目打包优化手段</h2><p>cdn加载</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span>、按需加载 第三方库 比如：<span class="variable constant_">UI</span> 组件库</span><br><span class="line">首先安装     npm install babel-plugin-component -D</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./plugins/element.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// plugins/element.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">Pagination</span>,</span><br><span class="line">  <span class="title class_">Dialog</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Pagination</span>);</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Dialog</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把弹框组件挂着到了 vue 的原型对象上，这样每一个组件都可以直接通过 this 访问</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$message</span> = <span class="title class_">Message</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$confirm</span> = <span class="title class_">MessageBox</span>.<span class="property">confirm</span></span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>、按需导入工具包</span><br><span class="line"><span class="comment">// 按需加载第三方工具包（例如 lodash）或者使用 CDN 的方式进行处理。</span></span><br><span class="line">例如：工具包  </span><br><span class="line">	npm i babel-plugin-transform-remove-<span class="variable language_">console</span> -D</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="string">&#x27;工具&#x27;</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span></span><br><span class="line">！工具包在打包的时候处理一下</span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>、移除<span class="variable language_">console</span>.<span class="property">log</span>信息</span><br><span class="line">npm install babel-plugin-component -D</span><br><span class="line"><span class="comment">// babel.config.js</span></span><br><span class="line"><span class="keyword">const</span> prodPlugins = [] <span class="comment">// 把插件装到数组里面</span></span><br><span class="line"><span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">  prodPlugins.<span class="title function_">push</span>(<span class="string">&#x27;transform-remove-console&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [<span class="string">&#x27;@vue/cli-plugin-babel/preset&#x27;</span>],</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&#x27;component&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">libraryName</span>: <span class="string">&#x27;element-ui&#x27;</span>,</span><br><span class="line">        <span class="attr">styleLibraryName</span>: <span class="string">&#x27;theme-chalk&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    ...prodPlugins <span class="comment">// 这里应用一下，插件就生效了</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># <span class="number">4</span>、处理 sourcemap 代码调试</span><br><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">productionSourceMap</span>: <span class="literal">false</span>  <span class="comment">// 选择不生成 生产环境文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># <span class="number">5</span>、<span class="title class_">Externals</span> &amp;&amp; <span class="variable constant_">CDN</span></span><br><span class="line"><span class="comment">// 通过 externals 排除第三方 JS 和 CSS 文件打包，使用 CDN 加载。</span></span><br><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">productionSourceMap</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    config.<span class="title function_">when</span>(process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span>, <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> cdn = &#123; <span class="comment">// 生产环境对象</span></span><br><span class="line">        <span class="attr">js</span>: [  <span class="comment">// 第三方js</span></span><br><span class="line">          <span class="string">&#x27;https://cdn.staticfile.org/vue/2.6.11/vue.min.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;https://cdn.staticfile.org/vue-router/3.1.3/vue-router.min.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;https://cdn.staticfile.org/axios/0.18.0/axios.min.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;https://cdn.staticfile.org/echarts/4.1.0/echarts.min.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;https://cdn.staticfile.org/quill/1.3.4/quill.min.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;https://cdn.jsdelivr.net/npm/vue-quill-editor@3.0.4/dist/vue-quill-editor.js&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">css</span>: [  <span class="comment">// 第三方css</span></span><br><span class="line">          <span class="string">&#x27;https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;https://cdn.staticfile.org/quill/1.3.4/quill.core.min.css&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;https://cdn.staticfile.org/quill/1.3.4/quill.snow.min.css&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;https://cdn.staticfile.org/quill/1.3.4/quill.bubble.min.css&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">      config.<span class="title function_">set</span>(<span class="string">&#x27;externals&#x27;</span>, &#123;  <span class="comment">// 通过 externals 排除不希望打包的文件</span></span><br><span class="line">        <span class="attr">vue</span>: <span class="string">&#x27;Vue&#x27;</span>,   <span class="comment">// key值是有讲究的，key值需要和引入的一致---&gt; vue: &#x27;Vue&#x27; &lt;--- value也必须和引入的CDN地址包一致</span></span><br><span class="line">        <span class="string">&#x27;vue-router&#x27;</span>: <span class="string">&#x27;VueRouter&#x27;</span>,</span><br><span class="line">        <span class="attr">axios</span>: <span class="string">&#x27;axios&#x27;</span>,</span><br><span class="line">        <span class="attr">echarts</span>: <span class="string">&#x27;echarts&#x27;</span>,</span><br><span class="line">        <span class="attr">nprogress</span>: <span class="string">&#x27;NProgress&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;nprogress/nprogress.css&#x27;</span>: <span class="string">&#x27;NProgress&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;vue-quill-editor&#x27;</span>: <span class="string">&#x27;VueQuillEditor&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;quill/dist/quill.core.css&#x27;</span>: <span class="string">&#x27;VueQuillEditor&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;quill/dist/quill.snow.css&#x27;</span>: <span class="string">&#x27;VueQuillEditor&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;quill/dist/quill.bubble.css&#x27;</span>: <span class="string">&#x27;VueQuillEditor&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">      config.<span class="title function_">plugin</span>(<span class="string">&#x27;html&#x27;</span>).<span class="title function_">tap</span>(<span class="function">(<span class="params">args</span>) =&gt;</span> &#123; <span class="comment">// 挂载数据</span></span><br><span class="line">        args[<span class="number">0</span>].<span class="property">isProd</span> = <span class="literal">true</span></span><br><span class="line">        args[<span class="number">0</span>].<span class="property">cdn</span> = cdn</span><br><span class="line">        <span class="keyword">return</span> args</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// public/index.html</span></span><br><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;</span><br><span class="line">  &lt;title&gt;</span><br><span class="line">    &lt;%= htmlWebpackPlugin.options.title %&gt;</span><br><span class="line">  &lt;/title&gt;</span><br><span class="line">  &lt;% if(htmlWebpackPlugin.options.isProd)&#123; %&gt;  # &lt;-- 通过 isProd 进行判断是否渲染</span><br><span class="line">    &lt;% for(var css of htmlWebpackPlugin.options.cdn.css) &#123; %&gt;</span><br><span class="line">      &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%=css%&gt;&quot;&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">        &lt;% &#125; %&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;noscript&gt;</span><br><span class="line">    &lt;strong&gt;We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled.</span><br><span class="line">        Please enable it to continue.&lt;/strong&gt;</span><br><span class="line">  &lt;/noscript&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;!-- built files will be auto injected --&gt;</span><br><span class="line">  &lt;% if(htmlWebpackPlugin.options.isProd)&#123; %&gt;</span><br><span class="line">    &lt;% for(var js of htmlWebpackPlugin.options.cdn.js) &#123; %&gt;</span><br><span class="line">      &lt;script src=&quot;&lt;%=js%&gt;&quot;&gt;&lt;/script&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">        &lt;% &#125; %&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"># 6、懒加载   缺点：会增大文件体积，但是增加的并不多</span><br><span class="line">const routes = [&#123;</span><br><span class="line">  path:&#x27;/&#x27;,</span><br><span class="line">  redirect:&#x27;/login&#x27;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">  path:&#x27;/Home&#x27;,</span><br><span class="line">  component:&#x27;../components/Home.vue&#x27;</span><br><span class="line">&#125;]</span><br><span class="line">// 路由懒加载就是把上面的代码 `component:&#x27;../components/Home.vue&#x27;` 改成下面的代码 `component:()=&gt;import(&#x27;../components/Home.vue&#x27;)` 这样路由不会立即加载，只有触发该路径的时候才会发送路由请求，点击页面跳转路径的时候发送请求，说明已经做到了路由懒加载</span><br><span class="line">const routes = [&#123;</span><br><span class="line">  path:&#x27;/&#x27;,</span><br><span class="line">  redirect:&#x27;/login&#x27;</span><br><span class="line">	&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path:&#x27;/Home&#x27;,</span><br><span class="line">    component:()=&gt;import(&#x27;../components/Home.vue&#x27;)</span><br><span class="line">  &#125;]</span><br><span class="line"></span><br><span class="line">// 图片的压缩、雪碧图（精灵图）</span><br></pre></td></tr></table></figure>
<h3 id="路由缓存问题"><a href="#路由缓存问题" class="headerlink" title="路由缓存问题"></a>路由缓存问题</h3><blockquote>
<p>当路由地址的切换匹配的是同一个 path 时，Vue出于性能的考虑，对应的路由组件会被<code>复用</code>。也就意味着，即便路由参数每次发送了变化，路由组件中对应的生命钩子也就只会被触发1次。例如：当在 setup 中需要根据路由参数的变化发请求时，会发现拿到的永远是最初到的旧数据。我们希望点击tabbar栏切换id时发送请求，而不是只发送一次请求。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、</span><br><span class="line"># 给路由出口添加一个不一样的 key 值,这样vue检测到key值发生变化就会对这个组件进行重新初始化的一个操作，一般我们会写$route.<span class="property">fullPath</span></span><br><span class="line"><span class="comment">// $route.fullPath，类型: string，说明：完成解析后的 URL，包含查询参数和 hash 的完整路径。</span></span><br><span class="line">&lt;router-view :key=<span class="string">&quot;$route.fullPath&quot;</span>&gt;&lt;/router-view&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、</span><br><span class="line">通过watch监听 路由传过来的id的变化并进行发送请求</span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>route.<span class="property">params</span>.<span class="property">id</span>,<span class="function">(<span class="params">newId</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 发送请求...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、</span><br><span class="line">通过 <span class="title class_">VueRouter</span> 官方提供的 onBeforeRouteUpdate,添加一个导航守卫，不论当前位置何时被更新都会触发。</span><br><span class="line"><span class="title function_">onBeforeRouteUpdate</span>(<span class="function">(<span class="params">to</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 请求代码...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="大数字遇到的问题"><a href="#大数字遇到的问题" class="headerlink" title="大数字遇到的问题"></a>大数字遇到的问题</h3><p>什么是大数字?</p>
<blockquote>
<p>JS能表示的最大<code>安全</code>数值区间是 -Math.pow（2,53） +1 —-   Math.pow（2,53）-1，超过这个区间的数字称为大数字。</p>
<p>大白话：一段数值很大的数字类型，无小数点 和 逗号分隔，会导致后端传递数据后与前端接收到的数值不一致导致404。</p>
</blockquote>
<p>问题描述</p>
<blockquote>
<p><code>康哥</code>—-&gt;   后端返回的数据大部分是JSON格式的字符串 为了方便我们使用，axios 内部会对这个数据进行JSON.parse 反序列化的操作；而当这个JSON格式的字符串中包含大数字的时候，JSON.parse 是搞不定的，会出现转出来的结果和原来的不一致的问题；</p>
<p><code>个人</code>—-&gt;   点击按钮或列表某一项获取id并进入详情时，有的时候会出现404，因为如果后端传递的id是较大的number类型的数字 例如：900719925474099288 这超过了 Math.pow（2,53）-1属于大数字，那么前端浏览器获取到的则是 900719925474099300 与后端返回的不符，拿着这个id去发送详情 请求就会出现404。</p>
</blockquote>
<p>解决方法：</p>
<blockquote>
<p>和后端协商，让其返回的 ID 使用字符串的类型进行表示</p>
<p>前端配置 axios 的 transformResponse 选项，手动使用一些第三方包对后端返回的数据进行处理，例如： <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/json-bigint">json-bigint</a></p>
</blockquote>
<p>为什么 nextTick 中就能拿到 DOM 更新后的数据？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="setup-返回的一定是对象吗？"><a href="#setup-返回的一定是对象吗？" class="headerlink" title="setup 返回的一定是对象吗？"></a><strong>setup 返回的一定是对象吗？</strong></h3><blockquote>
<p>不一定，也可以是一个渲染函数（可以在没有模版的情况下，渲染内容）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="comment">// 渲染函数</span></span><br><span class="line">    <span class="comment">// 参数1：标签，参数2：内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span><span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>,<span class="string">&#x27;Hello world&#x27;</span>) <span class="comment">// 会在页面生成一个h1标签，右侧为显示的内容</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h2><p>页面跳转的方式有哪些？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># <span class="variable language_">window</span> 跳转方式</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span> = <span class="string">&quot;http://&quot;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">window.location.href = &quot;https//&quot;</span></span><br><span class="line"><span class="string">// 上面两种方法都是当前页面跳转； 不同之处在于 window.location 返回的是对象，如果没有.href，它的默认参数就是href</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">window.open(&quot;https://&quot;)</span></span><br><span class="line"><span class="string">window.open(&quot;https://&quot;, &quot;_self&quot;)</span></span><br><span class="line"><span class="string">// 上面两种方法不带参数_self，会走新开页面，加self在当前页面跳转，window.open(&quot;http://&quot;, &quot;_self&quot;)与window.location相比，window.location有IE浏览器兼容问题，会有缓存存在，所以项目中采用了，window.open(&quot;https://&quot;, &quot;_self&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">window.location.reload()；  // 重新加载当前页面</span></span><br><span class="line"><span class="string">window.location.replace();   // 重新加载且可以替换的当前页面为另一个页面；</span></span><br><span class="line"><span class="string">top.location.href=”url”        // 在顶层页面打开url（跳出框架）</span></span><br><span class="line"><span class="string">self.location.href=”url”        //仅在本页面打开url地址</span></span><br><span class="line"><span class="string">parent.location.href=”url”     // 在父窗口打开Url地址</span></span><br><span class="line"><span class="string">this.location.href=”url”       // 用法和self的用法一致</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># HTML跳转</span></span><br><span class="line"><span class="string">&lt;a href=&quot;页面路径&quot;&gt;&lt;/a&gt;  // 会有历史记录</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Vue跳转方式</span></span><br><span class="line"><span class="string">this.$router.push(&#x27;</span>页面路径<span class="string">&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># VueRouter跳转</span></span><br><span class="line"><span class="string">&lt;router-link to=&quot;页面路径&quot;&gt;&lt;/router-link&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 小程序跳转方式</span></span><br><span class="line"><span class="string">标签跳转</span></span><br><span class="line"><span class="string">&lt;navigator url=&quot;页面路径&quot;&gt;&lt;/navigator&gt;   // 注意，不能跳转 tabbar 页面 </span></span><br><span class="line"><span class="string">wx.switchTab   // 跳转到 tabBar 页面，并关闭所有非tabBar页面</span></span><br><span class="line"><span class="string">wx.reLaunch   // 关闭所有页面，打开到应用内的某个页面，无历史记录，无法通过左上角的箭头返回原页面。</span></span><br><span class="line"><span class="string">wx.redirectTo   // 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。</span></span><br><span class="line"><span class="string">wx.navigateTo   // 保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 wx.navigateBack 可以返回到原页面。小程序中页面栈最多十层。</span></span><br><span class="line"><span class="string">wx.navigateBack   // 关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages 获取当前的页面栈，决定需要返回几层。</span></span><br></pre></td></tr></table></figure>
<h2 id="注册事件-绑定事件"><a href="#注册事件-绑定事件" class="headerlink" title="注册事件/绑定事件"></a>注册事件/绑定事件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 原生<span class="variable constant_">JS</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;获取到的标签&#x27;</span>).<span class="title function_">addEventListener</span>(事件类型，事件回调函数)</span><br></pre></td></tr></table></figure>
<h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><h2 id="地图API"><a href="#地图API" class="headerlink" title="地图API"></a>地图API</h2><h2 id="Promise执行顺序"><a href="#Promise执行顺序" class="headerlink" title="Promise执行顺序"></a>Promise执行顺序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> 同步</span><br><span class="line"><span class="keyword">await</span> 异步</span><br><span class="line">.<span class="title function_">then</span>()下方如果有代码则返回默认返回一段代码   <span class="comment">// return Promise.resolve(undefined)</span></span><br><span class="line"><span class="built_in">setTimeout</span> 异步宏任务 <span class="comment">// 定时器</span></span><br></pre></td></tr></table></figure>
<h2 id="业务相关面试题"><a href="#业务相关面试题" class="headerlink" title="业务相关面试题"></a>业务相关面试题</h2><h3 id="【业务】路由级别的权限你是怎么做的？"><a href="#【业务】路由级别的权限你是怎么做的？" class="headerlink" title="【业务】路由级别的权限你是怎么做的？"></a>【业务】路由级别的权限你是怎么做的？</h3><h3 id="【业务】按钮级别的权限你是怎么做的？"><a href="#【业务】按钮级别的权限你是怎么做的？" class="headerlink" title="【业务】按钮级别的权限你是怎么做的？"></a>【业务】按钮级别的权限你是怎么做的？</h3><h3 id="上传二次封装？"><a href="#上传二次封装？" class="headerlink" title="上传二次封装？"></a>上传二次封装？</h3><h3 id="前端大文件上传（切割文件）"><a href="#前端大文件上传（切割文件）" class="headerlink" title="前端大文件上传（切割文件）"></a>前端大文件上传（切割文件）</h3><blockquote>
<p>File对象：他表示一组文件，我们使用<input type="file">选择文件时，这些文件被存储在 File 对象中</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> file = files[i] <span class="comment">// File对象</span></span><br><span class="line">files.<span class="property">name</span> <span class="comment">// 文件名</span></span><br><span class="line">files.<span class="property">size</span> <span class="comment">// 文件大小</span></span><br><span class="line">files.<span class="property">type</span> <span class="comment">// 文件类型</span></span><br><span class="line">files.<span class="property">lastModifiedDate</span> <span class="comment">// 文件最后修改时间</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Blob对象：表示二进制数据，常用来表示大数据对象（如照片、音频等）。File对象是Blob对象的一个子类，他继承了Blob对象的属性和方法。</p>
<p>formData对象：前端先把文件存储在formData 对象中，才能传给后端。</p>
<p>File对象一般不能直接传输给后端，需要将二进制传输给后端，通过 append方法 将file对象添加到formData对象中，此时file对象会被转化成二进制后传给后端。</p>
</blockquote>
<h3 id="mixin代码混入"><a href="#mixin代码混入" class="headerlink" title="mixin代码混入"></a>mixin代码混入</h3><blockquote>
<p>混入：Vue2中常用的代码复用的手段，混入数据和业务逻辑</p>
<p>缺点：数据来源不清晰，命名冲突</p>
<p>在 Vue3中虽然没有移除 mixin ，但是不推荐使用了，更推荐组合API</p>
</blockquote>
<h3 id="公司迭代时间"><a href="#公司迭代时间" class="headerlink" title="公司迭代时间"></a>公司迭代时间</h3><blockquote>
<p>半个月迭代一次</p>
</blockquote>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>&gt;</p>
<p>for of 就是专门负责处理可迭代数据的。</p>
<h3 id="伪数组转真数组，Array-from-和-三个点都可以，区别是什么？"><a href="#伪数组转真数组，Array-from-和-三个点都可以，区别是什么？" class="headerlink" title="伪数组转真数组，Array.from 和 三个点都可以，区别是什么？"></a>伪数组转真数组，Array.from 和 三个点都可以，区别是什么？</h3><p>&gt;</p>
<h3 id="weakset-和-weakmap"><a href="#weakset-和-weakmap" class="headerlink" title="weakset 和 weakmap"></a>weakset 和 weakmap</h3><blockquote>
<p>weakset 和 weakmap 里面放的内容是弱引用的，有时候用这两个可以节省内存的占用。</p>
</blockquote>
<h3 id="对象去重"><a href="#对象去重" class="headerlink" title="对象去重"></a>对象去重</h3><blockquote>
<p>任何两个对象都不可能重复（相等，何来去重一说呢？）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="模块化规范都有哪些"><a href="#模块化规范都有哪些" class="headerlink" title="模块化规范都有哪些?"></a>模块化规范都有哪些?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">是什么?</span><br><span class="line">怎么用?</span><br><span class="line">解决了什么问题?</span><br><span class="line">有没有替代方案?</span><br><span class="line">好处是什么?</span><br><span class="line">场景是什么?</span><br><span class="line">原理是什么?</span><br></pre></td></tr></table></figure>
<h3 id="长列表优化？"><a href="#长列表优化？" class="headerlink" title="长列表优化？"></a>长列表优化？</h3><blockquote>
<p>使用虚拟列表：只渲染可视化区域（滑上去的删除）</p>
</blockquote>
<h3 id="三方登录流程？"><a href="#三方登录流程？" class="headerlink" title="三方登录流程？"></a>三方登录流程？</h3><p>&gt;</p>
<h3 id="pinia持久化存储"><a href="#pinia持久化存储" class="headerlink" title="pinia持久化存储"></a>pinia持久化存储</h3><p><code>pinia</code> 和 <code>vuex</code> 一样，数据是短时的，只要一刷新页面，数据就会恢复成初始状态，为了避免这个问题，可以对其采用持久化保存方法。</p>
<p>持久化保存的原理是在 <code>pinia</code> 中数据更新时，同步保存到 <code>localStorage</code> 或 <code>sessionStorage</code> 中，刷新后从本地存储中读取数据，你可以选择自己去写，但是实现起来并不像想象中那么容易，当然，也没那么难。</p>
<p>一般我们可以借助插件进行持久化存储</p>
<blockquote>
<p>pnpm i pinia-plugin-persistedstate</p>
<p>或</p>
<p>yarn add pinia-plugin-persistedstate</p>
<p>或</p>
<p>npm i pinia-plugin-persistedstate</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">`persist`</span> <span class="keyword">from</span> <span class="string">`&#x27;pinia-plugin-persistedstate&#x27;`</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">`persist`</span> )</span><br></pre></td></tr></table></figure>
<h1 id="康哥讲面试"><a href="#康哥讲面试" class="headerlink" title="康哥讲面试"></a>康哥讲面试</h1><p>1、继承</p>
<blockquote>
<p>挂载到实例上面的称为实例属性、方法</p>
<p>挂载到原型上面的称为原型属性、方法</p>
<p>直接挂载到构造函数上的称为静态属性、方法，只能通过构造函数访问</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="comment">// this =&gt; 实例对象</span></span><br><span class="line">  <span class="comment">// 实例属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 方法不应该挂到实例上面，这样会存在内存空间浪费的问题</span></span><br><span class="line">  <span class="comment">/* this.show = function() &#123;</span></span><br><span class="line"><span class="comment">    console.log(&#x27;Hello World&#x27;)</span></span><br><span class="line"><span class="comment">  &#125; */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态属性</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">version</span> = <span class="number">18</span></span><br><span class="line"><span class="comment">// 原型属性</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">show</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法 then、catch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数通过 new 来使用</span></span><br><span class="line"><span class="keyword">const</span> wsc = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">show</span>() <span class="comment">// 自己没有会找原型</span></span><br><span class="line"><span class="comment">// 每一次调用方法都会在 堆 里面开辟一个空间存储方法，造成内存空间的浪费</span></span><br><span class="line">wsc.方法名</span><br><span class="line"></span><br><span class="line"># 借用继承</span><br><span class="line"># 原型继承（继承的是父类原型上的方法）</span><br><span class="line"><span class="comment">// 说一下对继承到的了解？ 说一下什么是组合继承？</span></span><br></pre></td></tr></table></figure>
<p>2、class</p>
<p>3、Event bus(发布订阅模式) / provide、inject（跨层级组件通信）</p>
<p>4、vuex =&gt; plugin</p>
<p>5、polyfill</p>
<p>6、 数据类型判断</p>
<p>7、数据处理</p>
<p>8、keep-alive组件缓存</p>
<p>9、</p>
<p>10、</p>
<p>11、</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">微风</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/31/2023/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E5%BF%85%E4%BC%9A%EF%BC%8C%E4%B8%8D%E4%BC%9A%E6%89%BE%E5%B7%A5%E4%BD%9C%E9%9A%BE/">http://example.com/2023/07/31/2023/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E5%BF%85%E4%BC%9A%EF%BC%8C%E4%B8%8D%E4%BC%9A%E6%89%BE%E5%B7%A5%E4%BD%9C%E9%9A%BE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Were all heroes</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/yang-chang-jun/imges/blob/main/image_1/17.jpg" data-sites="qq,wechat,weibo,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/29/2023/7%E6%9C%88%E6%96%87%E7%AB%A0/1_%E5%8F%91%E5%B8%83github404/" title="github部署网站404"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">github部署网站404</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/03/2023/8%E6%9C%88%E6%96%87%E7%AB%A0/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" title="垃圾回收机制"><img class="cover" src="https://gitee.com/yang-chang-jun/imges/blob/main/image_1/15.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">垃圾回收机制</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author_top is-center"><div class="avatar-img"><img src="https://img0.baidu.com/it/u=3487243724,4005355975&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">微风</div><div class="author-info__description">I ll catch up with you</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ychangjun" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E8%B7%AF"><span class="toc-number">1.0.1.</span> <span class="toc-text">套路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML"><span class="toc-number">1.1.</span> <span class="toc-text">HTML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90CSS%E3%80%91EM-%E5%92%8C-REM-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">【CSS】EM 和 REM 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9-REM-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.1.2.</span> <span class="toc-text">说一下你对 REM 的理解?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90CSS%E3%80%91REM-%E9%80%82%E9%85%8D%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">【CSS】REM 适配的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90CSS%E3%80%91%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%9B%92%E5%AD%90%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%EF%BC%9F"><span class="toc-number">1.1.4.</span> <span class="toc-text">【CSS】如何实现一个盒子水平垂直居中？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90CSS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9-BFC-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.1.5.</span> <span class="toc-text">【CSS】说一下你对 BFC 的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90CSS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B-link-%E5%92%8C-import-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.6.</span> <span class="toc-text">【CSS】说一下 link 和 @import 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.7.</span> <span class="toc-text">盒子模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.8.</span> <span class="toc-text">行内元素和块元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BD%9C%E7%94%A8%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">1.1.9.</span> <span class="toc-text">深度作用选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">1.1.10.</span> <span class="toc-text">css画三角形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flex-1%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-number">1.1.11.</span> <span class="toc-text">flex:1是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#margin-top%E7%99%BE%E5%88%86%E6%AF%94%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-number">1.1.12.</span> <span class="toc-text">margin-top百分比是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%92%E5%AD%90%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%EF%BC%9F"><span class="toc-number">1.1.13.</span> <span class="toc-text">盒子垂直水平居中？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%94%AF%E6%8C%81%E5%B0%8F%E4%BA%8E12px%E7%9A%84%E6%96%87%E5%AD%97"><span class="toc-number">1.1.14.</span> <span class="toc-text">如何让谷歌浏览器支持小于12px的文字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS"><span class="toc-number">1.2.</span> <span class="toc-text">JS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">DOM？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BOM"><span class="toc-number">1.2.2.</span> <span class="toc-text">BOM?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#script%E6%A0%87%E7%AD%BE%EF%BC%9F"><span class="toc-number">1.2.3.</span> <span class="toc-text">script标签？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#script%E6%A0%87%E7%AD%BE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%88%B0-lt-body-gt-%E7%9A%84%E4%B8%8A%E6%96%B9%EF%BC%9F"><span class="toc-number">1.2.4.</span> <span class="toc-text">script标签为什么要写到&lt;&#x2F;body&gt;的上方？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E8%84%9A%E6%9C%AC"><span class="toc-number">1.2.5.</span> <span class="toc-text">动态加载脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99js%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BB%8E%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6%E5%BC%95%E5%85%A5%EF%BC%9F"><span class="toc-number">1.2.6.</span> <span class="toc-text">编写js时为什么需要从外部文件引入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.7.</span> <span class="toc-text">文档模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.8.</span> <span class="toc-text">元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B-new-%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.2.9.</span> <span class="toc-text">【JS】说一下 new 一个构造函数的执行过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B-call-%E5%92%8C-apply-%E5%8F%8A-bind-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.2.10.</span> <span class="toc-text">【JS】说一下 call 和 apply 及 bind 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.2.11.</span> <span class="toc-text">【JS】说一下你对事件委托的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.2.12.</span> <span class="toc-text">【JS】说一下你对防抖和节流的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9-EventLoop-%E8%A1%A3%E9%97%BB%E7%89%B9%E5%92%AF%E6%99%AE-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.2.13.</span> <span class="toc-text">【JS】说一下你对 EventLoop(衣闻特咯普) 的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventLoop%E9%A2%9D%E5%A4%96%E9%97%AE%E7%AD%94-vue-%E4%B8%80%E5%AE%9A%E6%98%AF%E4%B8%80%E7%A7%92%E6%89%93%E5%8D%B0%E5%90%97%EF%BC%9F"><span class="toc-number">1.2.14.</span> <span class="toc-text">EventLoop额外问答? vue 一定是一秒打印吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81vue%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%80%E7%A7%92%E6%89%93%E5%8D%B0-%E4%BD%BF%E7%94%A8web-worker%E5%BC%80%E5%90%AFjs%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.15.</span> <span class="toc-text">如何保证vue中的代码一秒打印? 使用web worker开启js的多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E5%A6%82%E4%BD%95%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E4%B8%94%E6%A0%B9%E6%8D%AE%E8%AF%B7%E6%B1%82%E7%9A%84%E4%B9%A6%E5%86%99%E9%A1%BA%E5%BA%8F%E6%8B%BF%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%9F"><span class="toc-number">1.2.16.</span> <span class="toc-text">【JS】如何并发请求且根据请求的书写顺序拿到对应的结果？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9-Promise-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.2.17.</span> <span class="toc-text">【JS】说一下你对 Promise 的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%B7%AE%E5%BC%82%EF%BC%9F"><span class="toc-number">1.2.18.</span> <span class="toc-text">【JS】函数传参简单数据类型和复杂数据类型有什么差异？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">1.2.19.</span> <span class="toc-text">【JS】说一下图片懒加载的实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B-null-%E5%92%8C-undefined-%E7%9A%84%E5%B7%AE%E5%BC%82%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.20.</span> <span class="toc-text">【JS】说一下 null 和 undefined 的差异是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%B1%9E%E6%80%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">1.2.21.</span> <span class="toc-text">如何判断属性的数据类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.2.22.</span> <span class="toc-text">【JS】说一下你对闭包的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B-localstorage-%E5%92%8C-sessionStorage-%E5%8F%8A-Cookie-%E7%9A%84%E5%B7%AE%E5%BC%82%EF%BC%9F"><span class="toc-number">1.2.23.</span> <span class="toc-text">【JS】说一下 localstorage 和 sessionStorage 及 Cookie 的差异？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E4%B8%BA%E7%A9%BA%EF%BC%9F"><span class="toc-number">1.2.24.</span> <span class="toc-text">【JS】如何判断对象为空？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B-for-in-%E5%92%8C-for-of-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.2.25.</span> <span class="toc-text">【JS】说一下 for in 和 for of 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%B7%AE%E5%BC%82%EF%BC%9F"><span class="toc-number">1.2.26.</span> <span class="toc-text">【JS】说一下箭头函数和普通函数的差异？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81-%E9%87%8D%E6%8E%92-%EF%BC%8C%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%EF%BC%9F"><span class="toc-number">1.2.27.</span> <span class="toc-text">【JS】什么是重绘和回流(重排)，如何减少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%9F"><span class="toc-number">1.2.28.</span> <span class="toc-text">什么是内存泄露？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON-parse-JSON-stringify-%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">1.2.29.</span> <span class="toc-text">JSON.parse&#x2F;JSON.stringify 有哪些特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.30.</span> <span class="toc-text">垃圾回收机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue"><span class="toc-number">1.3.</span> <span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue2%E5%92%8CVue3%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">Vue2和Vue3有哪些不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%BF%E4%B8%BB%E7%8E%AF%E5%A2%83"><span class="toc-number">1.3.2.</span> <span class="toc-text">宿主环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8vue2%E4%B8%AD%E7%9A%84Object-defineProperty%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">在vue2中的Object.defineProperty有哪些属性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96%E8%A7%86%E5%9B%BE%E4%B8%8D%E6%9B%B4%E6%96%B0%EF%BC%9F"><span class="toc-number">1.3.4.</span> <span class="toc-text">数据变化视图不更新？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9-Vuex-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.3.5.</span> <span class="toc-text">【Vue】说一下你对 Vuex 的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91v-for-%E5%92%8C-v-if-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E6%94%BE%E4%B8%80%E8%A1%8C%EF%BC%9F"><span class="toc-number">1.3.6.</span> <span class="toc-text">【Vue】v-for 和 v-if 为什么不建议放一行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91Vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9B%9B%E8%BF%9E%E9%97%AE%EF%BC%9F"><span class="toc-number">1.3.7.</span> <span class="toc-text">【Vue】Vue 响应式四连问？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91hash-%E5%92%8C-history-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B7%AE%E5%BC%82%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9Frouter%E8%B7%AF%E7%94%B1%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.3.8.</span> <span class="toc-text">【Vue】hash 和 history 模式的差异是什么？router路由的工作模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E7%88%B6%E4%BC%A0%E5%AD%90%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.3.9.</span> <span class="toc-text">【Vue】父传子都有哪些方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E5%AD%90%E4%BC%A0%E7%88%B6%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.3.10.</span> <span class="toc-text">【Vue】子传父都有哪些方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B-Vue-%E4%B8%AD%E7%9A%84%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%EF%BC%9F"><span class="toc-number">1.3.11.</span> <span class="toc-text">【Vue】说一下 Vue 中的兄弟组件通信？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91Vue-nextTick-%E5%92%8C-eventLoop%EF%BC%9F"><span class="toc-number">1.3.12.</span> <span class="toc-text">【Vue】Vue nextTick 和 eventLoop？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E4%BD%A0%E4%BC%9A%E5%9C%A8%E5%93%AA%E4%B8%AA%E9%92%A9%E5%AD%90%E9%87%8C%E9%9D%A2%E5%8F%91%E8%AF%B7%E6%B1%82%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.13.</span> <span class="toc-text">【Vue】你会在哪个钩子里面发请求为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E7%BB%84%E4%BB%B6%E6%9F%90%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E7%9A%84%E8%A7%A6%E5%8F%91%EF%BC%9F"><span class="toc-number">1.3.14.</span> <span class="toc-text">【Vue】如何监听组件某个生命周期钩子的触发？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B-computed-%E5%92%8C-methods-%E5%8F%8A-watch-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82%EF%BC%9F"><span class="toc-number">1.3.15.</span> <span class="toc-text">【Vue】说一下 computed 和 methods 及 watch 之间的差异？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9-Vue3-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%EF%BC%88%E5%8F%AF%E4%BB%A5%E5%85%88%E8%B7%B3%E8%BF%87%EF%BC%89"><span class="toc-number">1.3.16.</span> <span class="toc-text">【Vue】说一下你对 Vue3 的理解？（可以先跳过）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91v-show-%E5%92%8C-v-if-%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="toc-number">1.3.17.</span> <span class="toc-text">【Vue】v-show 和 v-if 的异同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B-Vue-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-number">1.3.18.</span> <span class="toc-text">【Vue】说一下 Vue 有哪些内置组件，分别是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91Vue-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%B5%8C%E5%A5%97%E7%9A%84%E8%AF%9D%EF%BC%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.19.</span> <span class="toc-text">【Vue】Vue 父子组件嵌套的话，生命周期顺序是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E5%92%8C-Vue-%E7%9B%B8%E5%85%B3%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%89%8B%E6%AE%B5%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.3.20.</span> <span class="toc-text">【Vue】和 Vue 相关性能优化的手段你了解哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E5%92%8CVue%E7%9B%B8%E5%85%B3%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%89%8B%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.3.21.</span> <span class="toc-text">【Vue】和Vue相关的性能优化的手段有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watch%E7%9B%91%E5%90%AC%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.22.</span> <span class="toc-text">watch监听时遇到的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E4%B8%AD%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E4%B8%8D%E4%BC%9A%E6%94%B9%E5%8F%98%E5%8E%9F%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.23.</span> <span class="toc-text">Vue中哪些方法不会改变原数组?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">1.3.24.</span> <span class="toc-text">常见的数据处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E5%AF%BC%E5%87%BA%E6%96%87%E4%BB%B6%E4%B8%BApdf%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.25.</span> <span class="toc-text">vue 导出文件为pdf格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-Vue-%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85%EF%BC%9F"><span class="toc-number">1.3.26.</span> <span class="toc-text">new Vue 的过程？发生了什么事情？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85"><span class="toc-number">1.3.27.</span> <span class="toc-text">组件封装?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%BC%93%E5%AD%98"><span class="toc-number">1.4.</span> <span class="toc-text">HTTP缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#restful-API"><span class="toc-number">1.4.1.</span> <span class="toc-text">restful   API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFHTTP"><span class="toc-number">1.4.2.</span> <span class="toc-text">HTTP是什么？什么是HTTP?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axios%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-%E6%A0%B9%E6%8D%AE%E5%90%8E%E7%AB%AF%E6%96%87%E6%A1%A3-axios-%E4%BC%A0%E5%8F%82"><span class="toc-number">1.4.3.</span> <span class="toc-text">axios的请求方式有哪些？&#x2F; 根据后端文档 axios 传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axios%E8%AF%B7%E6%B1%82"><span class="toc-number">1.4.4.</span> <span class="toc-text">axios请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axios%E5%B0%81%E8%A3%85"><span class="toc-number">1.4.5.</span> <span class="toc-text">axios封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axios%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82"><span class="toc-number">1.4.6.</span> <span class="toc-text">axios取消请求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise"><span class="toc-number">1.5.</span> <span class="toc-text">Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.1.</span> <span class="toc-text">Promise静态方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85"><span class="toc-number">1.6.</span> <span class="toc-text">项目打包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TS"><span class="toc-number">1.6.1.</span> <span class="toc-text">TS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#type-%E5%92%8C-interface-%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">type 和 interface 的异同</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Webpack"><span class="toc-number">1.6.2.</span> <span class="toc-text">Webpack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#webpack%E6%98%AF%E4%BB%80%E4%B9%88-%E4%BB%80%E4%B9%88%E6%98%AFwebpack"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">webpack是什么? &#x2F; 什么是webpack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFwebsocket%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">什么是websocket协议?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#websocket%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">websocket心跳机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx%EF%BC%9F"><span class="toc-number">1.6.3.</span> <span class="toc-text">Nginx？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6"><span class="toc-number">1.6.4.</span> <span class="toc-text">下载文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.7.</span> <span class="toc-text">小程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-uni-app%EF%BC%9F"><span class="toc-number">1.7.1.</span> <span class="toc-text">为什么使用 uni-app？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%A2%E6%9C%8D"><span class="toc-number">1.7.2.</span> <span class="toc-text">小程序客服?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%88%86%E4%BA%AB%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F"><span class="toc-number">1.7.3.</span> <span class="toc-text">小程序中分享怎么做的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%89%AB%E7%A0%81%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.4.</span> <span class="toc-text">小程序扫码功能实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="toc-number">1.7.5.</span> <span class="toc-text">小程序登录流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-webpack-%E7%9A%84%E6%8E%92%E9%99%A4%E6%89%93%E5%8C%85%E6%95%88%E6%9E%9C-CDN"><span class="toc-number">1.7.6.</span> <span class="toc-text">配置 webpack 的排除打包效果 CDN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BD%E9%99%85%E5%8C%96%E8%AF%AD%E8%A8%80"><span class="toc-number">1.7.7.</span> <span class="toc-text">国际化语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Echarts%E9%80%82%E9%85%8D"><span class="toc-number">1.7.8.</span> <span class="toc-text">Echarts适配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98%E5%92%8CrestfulApi"><span class="toc-number">1.7.9.</span> <span class="toc-text">切换主题和restfulApi</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90"><span class="toc-number">1.8.</span> <span class="toc-text">生命周期钩子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E5%89%8D%E7%AB%AF%EF%BC%9F"><span class="toc-number">1.8.1.</span> <span class="toc-text">什么是微前端？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8qukun%E4%B8%8D%E7%94%A8iframe%E6%97%A0%E7%95%8C"><span class="toc-number">1.9.</span> <span class="toc-text">为什么用qukun不用iframe无界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF3D%EF%BC%9F3D%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">1.10.</span> <span class="toc-text">什么是3D？3D模型解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mock-js%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">Mock.js是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5"><span class="toc-number">1.12.</span> <span class="toc-text">项目打包优化手段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="toc-number">1.12.1.</span> <span class="toc-text">路由缓存问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E5%AD%97%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.12.2.</span> <span class="toc-text">大数字遇到的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setup-%E8%BF%94%E5%9B%9E%E7%9A%84%E4%B8%80%E5%AE%9A%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F"><span class="toc-number">1.12.3.</span> <span class="toc-text">setup 返回的一定是对象吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC"><span class="toc-number">1.13.</span> <span class="toc-text">页面跳转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6-%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.14.</span> <span class="toc-text">注册事件&#x2F;绑定事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6"><span class="toc-number">1.14.1.</span> <span class="toc-text">递归组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E5%9B%BEAPI"><span class="toc-number">1.15.</span> <span class="toc-text">地图API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.16.</span> <span class="toc-text">Promise执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.17.</span> <span class="toc-text">业务相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E4%B8%9A%E5%8A%A1%E3%80%91%E8%B7%AF%E7%94%B1%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9D%83%E9%99%90%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F"><span class="toc-number">1.17.1.</span> <span class="toc-text">【业务】路由级别的权限你是怎么做的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E4%B8%9A%E5%8A%A1%E3%80%91%E6%8C%89%E9%92%AE%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9D%83%E9%99%90%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F"><span class="toc-number">1.17.2.</span> <span class="toc-text">【业务】按钮级别的权限你是怎么做的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85%EF%BC%9F"><span class="toc-number">1.17.3.</span> <span class="toc-text">上传二次封装？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%EF%BC%88%E5%88%87%E5%89%B2%E6%96%87%E4%BB%B6%EF%BC%89"><span class="toc-number">1.17.4.</span> <span class="toc-text">前端大文件上传（切割文件）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mixin%E4%BB%A3%E7%A0%81%E6%B7%B7%E5%85%A5"><span class="toc-number">1.17.5.</span> <span class="toc-text">mixin代码混入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%8F%B8%E8%BF%AD%E4%BB%A3%E6%97%B6%E9%97%B4"><span class="toc-number">1.17.6.</span> <span class="toc-text">公司迭代时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.17.7.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E6%95%B0%E7%BB%84%E8%BD%AC%E7%9C%9F%E6%95%B0%E7%BB%84%EF%BC%8CArray-from-%E5%92%8C-%E4%B8%89%E4%B8%AA%E7%82%B9%E9%83%BD%E5%8F%AF%E4%BB%A5%EF%BC%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.17.8.</span> <span class="toc-text">伪数组转真数组，Array.from 和 三个点都可以，区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weakset-%E5%92%8C-weakmap"><span class="toc-number">1.17.9.</span> <span class="toc-text">weakset 和 weakmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%8E%BB%E9%87%8D"><span class="toc-number">1.17.10.</span> <span class="toc-text">对象去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.17.11.</span> <span class="toc-text">模块化规范都有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E5%88%97%E8%A1%A8%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">1.17.12.</span> <span class="toc-text">长列表优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.17.13.</span> <span class="toc-text">三方登录流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pinia%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8"><span class="toc-number">1.17.14.</span> <span class="toc-text">pinia持久化存储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%B7%E5%93%A5%E8%AE%B2%E9%9D%A2%E8%AF%95"><span class="toc-number">2.</span> <span class="toc-text">康哥讲面试</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/03/2023/8%E6%9C%88%E6%96%87%E7%AB%A0/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" title="垃圾回收机制">垃圾回收机制</a><time datetime="2023-08-03T14:15:25.000Z" title="发表于 2023-08-03 22:15:25">2023-08-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/31/2023/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E5%BF%85%E4%BC%9A%EF%BC%8C%E4%B8%8D%E4%BC%9A%E6%89%BE%E5%B7%A5%E4%BD%9C%E9%9A%BE/" title="前端面试题">前端面试题</a><time datetime="2023-07-31T13:40:20.000Z" title="发表于 2023-07-31 21:40:20">2023-07-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/29/2023/7%E6%9C%88%E6%96%87%E7%AB%A0/1_%E5%8F%91%E5%B8%83github404/" title="github部署网站404">github部署网站404</a><time datetime="2023-07-29T03:52:30.000Z" title="发表于 2023-07-29 11:52:30">2023-07-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/02/2023/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" title="如何搭建个人博客">如何搭建个人博客</a><time datetime="2023-06-02T07:14:30.000Z" title="发表于 2023-06-02 15:14:30">2023-06-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/01/2023/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%96%87%E7%AB%A0%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7/" title="文章配置属性">文章配置属性</a><time datetime="2023-06-01T07:37:00.000Z" title="发表于 2023-06-01 15:37:00">2023-06-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 微风</div><div class="footer_custom_text">本网站基于<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo框架</a>和butterfly主题搭建而成</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script defer src="/live2d-widget/autoload.js"></script><canvas async id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="/js/title.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="爱国,和谐,富强,友善,敬业,诚信,民主,文明,自由,平等,公正,公平,法治,社会" data-fontsize="15px" data-random="true" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":true,"model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>