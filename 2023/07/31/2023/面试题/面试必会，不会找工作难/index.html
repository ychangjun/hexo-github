<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>前端面试题 | Were all heroes</title><meta name="author" content="微风"><meta name="copyright" content="微风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="该内容过多！！！建议搜索关键词查询！！！  康哥讲面试题 ECMAScript 6 入门 阮一峰 ECMAScript 6 入门 现代 JavaScript 教程 工具应用文档 Dan个人博客 笔记类 最全面试宝典 小里小汤小康搬砖速成秘籍 深圳面试宝典   01【概述】把握住答题技巧？ 面试题套路12345671.是什么?2.怎么用?3.解决了什么问题?4.有没有替代方案?5.好处是什么?6.场">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试题">
<meta property="og:url" content="http://example.com/2023/07/31/2023/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E5%BF%85%E4%BC%9A%EF%BC%8C%E4%B8%8D%E4%BC%9A%E6%89%BE%E5%B7%A5%E4%BD%9C%E9%9A%BE/index.html">
<meta property="og:site_name" content="Were all heroes">
<meta property="og:description" content="该内容过多！！！建议搜索关键词查询！！！  康哥讲面试题 ECMAScript 6 入门 阮一峰 ECMAScript 6 入门 现代 JavaScript 教程 工具应用文档 Dan个人博客 笔记类 最全面试宝典 小里小汤小康搬砖速成秘籍 深圳面试宝典   01【概述】把握住答题技巧？ 面试题套路12345671.是什么?2.怎么用?3.解决了什么问题?4.有没有替代方案?5.好处是什么?6.场">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img0.baidu.com/it/u=3487243724,4005355975&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500">
<meta property="article:published_time" content="2023-07-31T13:40:20.000Z">
<meta property="article:modified_time" content="2023-08-22T12:28:39.697Z">
<meta property="article:author" content="微风">
<meta property="article:tag" content="前端面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img0.baidu.com/it/u=3487243724,4005355975&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500"><link rel="shortcut icon" href="https://img0.baidu.com/it/u=3487243724,4005355975&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500"><link rel="canonical" href="http://example.com/2023/07/31/2023/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E5%BF%85%E4%BC%9A%EF%BC%8C%E4%B8%8D%E4%BC%9A%E6%89%BE%E5%B7%A5%E4%BD%9C%E9%9A%BE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 微风","link":"链接: ","source":"来源: Were all heroes","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-22 20:28:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img0.baidu.com/it/u=3487243724,4005355975&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Were all heroes"><span class="site-name">Were all heroes</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">前端面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-31T13:40:20.000Z" title="发表于 2023-07-31 21:40:20">2023-07-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-22T12:28:39.697Z" title="更新于 2023-08-22 20:28:39">2023-08-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="前端面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><font color=red size=6>该内容过多！！！建议搜索关键词查询！！！</font>

<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iW4y1k7Ci/?spm_id_from=333.999.0.0">康哥讲面试题</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/es6-3rd/sidebar.md">ECMAScript 6 入门 阮一峰</a></p>
<p><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/set-map">ECMAScript 6 入门</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.javascript.info/">现代 JavaScript 教程</a></p>
<p><a target="_blank" rel="noopener" href="https://hello-nav.github.io/">工具应用文档</a></p>
<p><a target="_blank" rel="noopener" href="https://overreacted.io/zh-hans/">Dan个人博客</a></p>
<h1 id="笔记类"><a href="#笔记类" class="headerlink" title="笔记类"></a>笔记类</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://fanyouf.gitee.io/interview/">最全面试宝典</a></p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/liuxiaoli-tn4oj/hvbohy/pxrlsq#xpo2K">小里小汤小康搬砖速成秘籍</a></p>
<p><a target="_blank" rel="noopener" href="http://120.24.95.18/web/mianshi/20220424/">深圳面试宝典</a></p>
</blockquote>
<!-- 贺师俊、尤雨溪 -->
<p>01【概述】把握住答题技巧？</p>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h3 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.是什么?</span><br><span class="line">2.怎么用?</span><br><span class="line">3.解决了什么问题?</span><br><span class="line">4.有没有替代方案?</span><br><span class="line">5.好处是什么?</span><br><span class="line">6.场景是什么?</span><br><span class="line">7.原理是什么?</span><br></pre></td></tr></table></figure>
<h2 id="HTML、CSS"><a href="#HTML、CSS" class="headerlink" title="HTML、CSS"></a>HTML、CSS</h2><h3 id="【CSS】EM-和-REM-的区别是什么？"><a href="#【CSS】EM-和-REM-的区别是什么？" class="headerlink" title="【CSS】EM 和 REM 的区别是什么？"></a>【CSS】EM 和 REM 的区别是什么？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是什么?</span></span><br><span class="line">em和rem 都是根据字体大小发生改变</span><br><span class="line">em是相对的长度单位, 他的大小会根据元素字体大小的改变而变化, 先看自己的, 如果自己没有设置字体大小则看上级的如果上级也没有设置则继续向上级寻找,一直到html根元素.   rem则是只看根元素字体大小而改变, 不受父元素字体大小限制.</span><br><span class="line"><span class="comment"># 作用?</span></span><br><span class="line">rem加入媒体查询,可以用于响应式布局</span><br><span class="line"><span class="comment"># 替代方案</span></span><br><span class="line">rem属于老版本响应式, 需要引入js文件进行适配, vw/vh 属于新版本的响应式, 无需引入js文件适配</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">逐字稿： EM 是相对于元素 <span class="string">&#x27;自身&#x27;</span> 字体大小的一个单位， 而 REM 是相对于根元素（html）字体大小的一个单位。</span><br></pre></td></tr></table></figure>
<h3 id="说一下你对-REM-的理解"><a href="#说一下你对-REM-的理解" class="headerlink" title="说一下你对 REM 的理解?"></a>说一下你对 REM 的理解?</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是什么?</span></span><br><span class="line">是一个相对于根元素字体大小的单位</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment"># 解决了什么问题?</span></span><br><span class="line"> 可以用来解决移动端适配的问题</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment"># 有没有替代方案?</span></span><br><span class="line">不过在开发当中, 也会用vw来进行适配, 在一定程度上来说 rem 做适配, 可以说就是对 vw 的一个模拟</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment"># 原理是什么?</span></span><br><span class="line">适配的原理是 利用媒体查询 或 js 动态监测设备的宽度, 不同的宽度下 设置对应的根元素的字体大小, 根元素的字体大小都发生变化了, 所有用 rem 做单位的元素都会跟着变化</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">逐字稿：利用媒体查询 或 js动态检测/获取设备的宽度，不同宽度下设置相应的根元素字体大小，当设备宽度变 =&gt; 根元素字体大小变 =&gt; 那么所有使用 REM 做单位的哪些元素都会跟着变化</span><br></pre></td></tr></table></figure>
<h3 id="【CSS】REM-适配的原理是什么？"><a href="#【CSS】REM-适配的原理是什么？" class="headerlink" title="【CSS】REM 适配的原理是什么？"></a>【CSS】REM 适配的原理是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">原理是什么?</span><br><span class="line">-- 把网页分成10等分, 每一份相当于 1rem ,和媒体查询配合可以做到响应式布局</span><br><span class="line">解决了什么问题?</span><br><span class="line">-- 电脑端应用, 移动端客户无法使用, 使用了rem后, 移动端用户也可以像pc端一样正常访问</span><br><span class="line">替代方案?</span><br><span class="line">-- vw/vh</span><br><span class="line">场景?</span><br><span class="line">-- bilibili(vw/vh)</span><br><span class="line">原理?</span><br><span class="line">把网页分成10等分, 每一份相当于1rem</span><br></pre></td></tr></table></figure>
<h3 id="CSS-position-定位有哪些属性？"><a href="#CSS-position-定位有哪些属性？" class="headerlink" title="CSS position 定位有哪些属性？"></a>CSS position 定位有哪些属性？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">position</span>:<span class="keyword">static</span> <span class="comment">// 默认定位</span></span><br><span class="line"><span class="attr">position</span>:relative <span class="comment">// 相对定位</span></span><br><span class="line"><span class="attr">position</span>:absolute <span class="comment">// 绝对定位</span></span><br><span class="line"><span class="attr">position</span>:fixed <span class="comment">// 固定定位</span></span><br><span class="line"><span class="attr">position</span>:sticky <span class="comment">// 粘性定位</span></span><br></pre></td></tr></table></figure>
<h3 id="CSS-文本溢出"><a href="#CSS-文本溢出" class="headerlink" title="CSS 文本溢出"></a>CSS 文本溢出</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">white-<span class="attr">space</span>: nowrap;  <span class="comment">// 强制一行显示</span></span><br><span class="line"><span class="attr">overflow</span>: hidden;  <span class="comment">// 溢出隐藏</span></span><br><span class="line">text-<span class="attr">overflow</span>: ellipsis; <span class="comment">//默认一行省略，多行直接失效，可以设置多行省略</span></span><br></pre></td></tr></table></figure>
<h3 id="【CSS】如何实现一个盒子水平垂直居中？"><a href="#【CSS】如何实现一个盒子水平垂直居中？" class="headerlink" title="【CSS】如何实现一个盒子水平垂直居中？"></a>【CSS】如何实现一个盒子水平垂直居中？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. flex布局</span></span><br><span class="line"><span class="attr">display</span>: flex;  <span class="comment">// 开启flex</span></span><br><span class="line">justify-<span class="attr">content</span>: center;  <span class="comment">// 主轴居中</span></span><br><span class="line">align-<span class="attr">items</span>: center;  <span class="comment">// 侧轴居中</span></span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 2.脱离标准流 + margin外边距</span></span><br><span class="line"><span class="comment">// 父盒子设置 </span></span><br><span class="line"><span class="attr">position</span>: relative;  <span class="comment">// 相对定位</span></span><br><span class="line"><span class="comment">// 子盒子</span></span><br><span class="line"><span class="attr">position</span>: absolute;  <span class="comment">// 绝对定位</span></span><br><span class="line"><span class="comment">/* 脱离标准流 */</span></span><br><span class="line"><span class="attr">top</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attr">bottom</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attr">left</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attr">right</span>: <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 脱离标准流后子盒子设置auto 自动水平垂直居中</span></span><br><span class="line"><span class="attr">margin</span>: auto;</span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 3. margin外边距 + transform位移</span></span><br><span class="line"><span class="comment">// 父盒子设置</span></span><br><span class="line"><span class="attr">overflow</span>: hidden; <span class="comment">// 防止盒子塌陷</span></span><br><span class="line"><span class="comment">// 子盒子</span></span><br><span class="line">margin-<span class="attr">left</span>: <span class="number">50</span>%;</span><br><span class="line">margin-<span class="attr">top</span>: <span class="number">50</span>%;</span><br><span class="line"><span class="attr">transform</span>: <span class="title function_">translate</span>(-<span class="number">50</span>%,-<span class="number">50</span>%);  <span class="comment">// 位移回自身的一半</span></span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 4.position定位 + transform位移</span></span><br><span class="line"><span class="comment">// 父盒子</span></span><br><span class="line"><span class="attr">position</span>: relative;</span><br><span class="line"><span class="comment">// 子盒子</span></span><br><span class="line"><span class="attr">position</span>: absolute;</span><br><span class="line"><span class="attr">left</span>: <span class="number">50</span>%;</span><br><span class="line"><span class="attr">top</span>: <span class="number">50</span>%;</span><br><span class="line"><span class="attr">transform</span>: <span class="title function_">translate</span>(-<span class="number">50</span>%,-<span class="number">50</span>%);</span><br></pre></td></tr></table></figure>
<h3 id="【CSS】说一下你对-BFC-的理解？"><a href="#【CSS】说一下你对-BFC-的理解？" class="headerlink" title="【CSS】说一下你对 BFC 的理解？"></a>【CSS】说一下你对 BFC 的理解？</h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">格式化上下文</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是怎么?</span></span><br><span class="line">BFC(块级格式化上下文)是一种css渲染方式</span><br><span class="line">BFC决定了块级盒子的渲染方式,以及其他元素的互动方式, 主要作用有: 防止 margin 重叠、清除浮动等  BFC 可以剥离并独立于外部环境，因此其内部元素与外部元素互相独立，不会影响其它区域的布局。</span><br><span class="line">----</span><br><span class="line">例如，当两个块级元素 margin 相遇时，它们的 margin 合并可能会导致布局问题，将其中一个元素置于一个 BFC 中可以解决这个问题。</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="comment"># 怎么用?  场景?</span></span><br><span class="line">`清除浮动`：当元素浮动时，BFC 可以防止浮动的元素溢出到父元素外部。可以通过在父元素上触发 BFC 来清除浮动。</span><br><span class="line">防止 margin `重叠` ：当两个相邻的块级元素 margin 发生重叠时，可以将它们置于不同的 BFC 中。</span><br><span class="line">强制元素在`一行显示`：可以将元素设为 display: inline-block 并触发 BFC，从而同时避免元素之间的缝隙和 margin 重叠。</span><br><span class="line">`自适应`两栏布局：将左侧元素置于一个 BFC 中，右侧元素也置于一个 BFC 中，就可以实现两栏布局。</span><br><span class="line">解决`文字环绕`问题：BFC 可以解决文字环绕问题，通过在文字周围创建一个新的 BFC 容器，来实现文字环绕效果。</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line"><span class="comment"># 替代方案?</span></span><br><span class="line">flex 布局：</span><br><span class="line">	Flexbox 布局提供了更直观的控制元素的排列和对齐方式的方法，主要用于解决一些列式布局的问题。</span><br><span class="line">Grid 布局：</span><br><span class="line">	Grid 布局是一种二维布局，能够非常方便的实现栅格化布局。</span><br><span class="line">Position 布局：</span><br><span class="line">	使用元素定位（position）来实现布局调整，通过对元素设置 position 属性及各种边缘值（top、right、bottom、left）来实现布局调整。但是这种方法不太适合用于整个布局的调整。</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line"><span class="comment"># 好处是什么?</span></span><br><span class="line">创建 BFC，可以有效的解决一些布局问题.  如避免 margin 重叠问题、清除浮动问题、自适应两栏布局、强制元素在一行显示、解决文字环绕问题等.  同时，BFC 还可以提高布局的容错性和灵活性，增强页面的可维护性。</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">原理是什么?</span><br><span class="line">可以让元素在一个相对独立的自我环境内进行布局、定位和绘制，避免由外部元素对其样式和位置的影响，同时也有助于解决一些常见的CSS布局问题。</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">逐字稿： </span><br><span class="line">1. 根元素（html）天生就有BFC特性</span><br><span class="line">2. 浮动元素（元素中的<span class="built_in">float</span>只要不是none就会触发BFC）</span><br><span class="line">3. 定位元素（元素中的 position 是 absolute 或 fixed 的时候也会触发BFC特性）</span><br><span class="line">4. 行内元素（元素的 display 为 inline-block）</span><br><span class="line">5. 表格单元素（元素的 display 为 table-cell, HTML表格单元素默认为改值就会触发）</span><br><span class="line">6. overflow 只要不是 visible就会触发BFC特性</span><br><span class="line">7. 更多说明 参考 MDN</span><br><span class="line">作用：</span><br><span class="line">1. 包含内部浮动元素</span><br><span class="line">2. 可以排除外部浮动带来的影响</span><br><span class="line">3. 阻止外边距重叠</span><br><span class="line">4. 解决margin盒子塌陷</span><br></pre></td></tr></table></figure>
<h3 id="【CSS】说一下-link-和-import-的区别？"><a href="#【CSS】说一下-link-和-import-的区别？" class="headerlink" title="【CSS】说一下 link 和 @import 的区别？"></a>【CSS】说一下 link 和 @import 的区别？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">`加载时间`和`性能`的区别：</span><br><span class="line">CSS文件使用<span class="string">&#x27;link&#x27;</span>标记时，`在页面加载时`就会<span class="string">&#x27;同时加载CSS文件&#x27;</span>；而使用`@import引入CSS文件时`，<span class="string">&#x27;需要等到页面DOM加载完成后&#x27;</span>才会加载CSS。因此，在页面性能方面，使用<span class="built_in">link</span>标记更好。</span><br><span class="line"></span><br><span class="line">`兼容性`的区别：</span><br><span class="line"><span class="string">&#x27;@import是CSS2.1中的属性，很多老版本的浏览器不支持&#x27;</span>@import。而<span class="string">&#x27;link标记是HTML4中定义的标签，几乎所有的浏览器&#x27;</span>都支持<span class="built_in">link</span>标记。</span><br><span class="line"></span><br><span class="line">`DOM操作`的区别：</span><br><span class="line"><span class="built_in">link</span>标记可以通过JavaScript来操作DOM并<span class="string">&#x27;更改CSS的属性&#x27;</span>，而@import无法通过JavaScript<span class="string">&#x27;操作DOM&#x27;</span>，因为它是在DOM加载完成后才加载的。</span><br><span class="line"></span><br><span class="line">`加载顺序`的区别：</span><br><span class="line"><span class="built_in">link</span>标记引入的CSS文件的加载顺序与HTML文档中<span class="built_in">link</span>标签的顺序有关，而@import引入的CSS文件的加载顺序与它们在样式表中的位置相关。</span><br></pre></td></tr></table></figure>
<h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><blockquote>
<p>标准盒子模型默认<code>content-box</code></p>
<p>通过<code>box-sizing:border-box</code>切换怪异盒子模型。</p>
</blockquote>
<h3 id="行内元素和块元素"><a href="#行内元素和块元素" class="headerlink" title="行内元素和块元素"></a>行内元素和块元素</h3><blockquote>
<p>块元素：</p>
<p><code>p</code>、<code>h1~h6</code>、<code>div</code>、<code>ul</code>、<code>ol</code>、<code>li</code>、<code>table</code>、<code>tr</code>、<code>td</code>等……</p>
<p>行内元素：</p>
<p><code>span</code>、<code>a</code>、<code>em</code>、<code>img</code>、<code>strong</code>、<code>b</code>、<code>i</code>等……</p>
<p>行内块元素：</p>
<p><code>img</code>、<code>input</code></p>
</blockquote>
<h3 id="深度作用选择器"><a href="#深度作用选择器" class="headerlink" title="深度作用选择器"></a>深度作用选择器</h3><blockquote>
<p>原生css使用   <code>&gt;&gt;&gt;</code>   深度选择器来修改</p>
<p>less需要使用    <code>/deep/</code>   或者   <code>::v-deep</code>   深度选择器</p>
<p>vue3.0 中使用 <code>/deep/</code> 会报错，更推荐使用 <code>::v-deep</code></p>
<p>对于使用了 css 预处理器（scss 、sass、 less）时，深度选择器 <code>::v-deep</code> 比较通用</p>
</blockquote>
<h3 id="css画三角形"><a href="#css画三角形" class="headerlink" title="css画三角形"></a>css画三角形</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">利用css层叠性，直接全部设置透明，然后设置一方的颜色覆盖，就形成三角形</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">50px</span> solid transparent;</span><br><span class="line">	<span class="attribute">border-left</span>:<span class="number">50px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">上下左右全部设置透明，然后让其中一个想要什么方向的设置颜色，就出现什么方向的三角形</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="flex-1是什么意思？"><a href="#flex-1是什么意思？" class="headerlink" title="flex:1是什么意思？"></a>flex:1是什么意思？</h3><p><code>flex</code> 属性用于指定弹性子元素如何分配空间。</p>
<blockquote>
<p><code>flex-grow：</code>定义弹性盒子元素的扩展比率。</p>
<p><code>flex-shrink：</code>定义弹性盒子元素的收缩比率。</p>
<p><code>flex-basis：</code>定义弹性盒子元素的默认基准值。</p>
</blockquote>
<h3 id="margin-top百分比是什么意思？"><a href="#margin-top百分比是什么意思？" class="headerlink" title="margin-top百分比是什么意思？"></a>margin-top百分比是什么意思？</h3><p>&gt;</p>
<h3 id="盒子垂直水平居中？"><a href="#盒子垂直水平居中？" class="headerlink" title="盒子垂直水平居中？"></a>盒子垂直水平居中？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 如果不考虑兼容性的话</span><br><span class="line">父盒子:&#123;</span><br><span class="line">  <span class="attr">display</span>: flex;</span><br><span class="line">  align-<span class="attr">content</span>: center;</span><br><span class="line">	justify-<span class="attr">content</span>: center</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 如果需要考虑兼容性问题的话</span><br><span class="line">子盒子&#123;</span><br><span class="line">  margin-<span class="attr">left</span>: <span class="number">50</span>%;</span><br><span class="line">  margin-<span class="attr">top</span>: <span class="number">50</span>%;</span><br><span class="line">  <span class="attr">transform</span>: <span class="title function_">translate</span>(-<span class="number">50</span>%,-<span class="number">50</span>%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何让谷歌浏览器支持小于12px的文字"><a href="#如何让谷歌浏览器支持小于12px的文字" class="headerlink" title="如何让谷歌浏览器支持小于12px的文字"></a>如何让谷歌浏览器支持小于12px的文字</h3><p>chrome谷歌浏览器默认的字体大小为16px，可以通过设置font-size来设置字体大小但是当设置到12px以下的时候字体大小不再改变;</p>
<blockquote>
<p>css：transform：scale();缩小字体大小，假设字体大小是12，缩小0.5就是6px</p>
<p>缺点不建议说：适配问题，需要对不同的浏览器进行适配。</p>
</blockquote>
<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="DOM？"><a href="#DOM？" class="headerlink" title="DOM？"></a>DOM？</h3><blockquote>
<p>文档对象模型：DOM 通过创建表示文档的树，让开发者可以随心所欲地控制网页的内容和结构。使用 DOM API，<br>可以轻松地删除、添加、替换、修改节点。</p>
</blockquote>
<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM?"></a>BOM?</h3><blockquote>
<p>浏览器对象模型：开发者可以操控浏览器显示页面之外的部分。</p>
</blockquote>
<h3 id="script标签？"><a href="#script标签？" class="headerlink" title="script标签？"></a>script标签？</h3><blockquote>
<p>使用了 <script></script>引入外部脚本文件后，不应该在内部继续编写代码，因为浏览器只会下载并执行脚本文件而忽律内部代码。</p>
<p>通过 script 标签的src属性发送 GET 请求以取得相应资源，这个请求是不受浏览器同源策略限制，但返回并被执行的 JavaScript 则受限制。这个请求仍然受父页面 HTTP/HTTPS 协议的限制。</p>
</blockquote>
<h3 id="script标签为什么要写到-lt-body-gt-的上方？"><a href="#script标签为什么要写到-lt-body-gt-的上方？" class="headerlink" title="script标签为什么要写到&lt;/body&gt;的上方？"></a>script标签为什么要写到&lt;/body&gt;的上方？</h3><blockquote>
<p>一般放引入的 script 标签的时候我们都会放在 &lt;/body&gt; ，因为如果放在 <head> 标签里面的话。也就意味着必须把所有 JavaScript 代码都下载、解析和解释完成后，才能开始渲染页面，。对于需要很多 JavaScript 的页面，这会导致页面渲染的明显延迟，在此期间浏览器窗口完全空白。</p>
<p><code>解决方法一：</code>一般放到 body 标签的内容底部，这样一来页面处理 js 代码之前就完全渲染页面。用户会感觉页面加载更快了，因为浏览器白屏的空白页面的时间缩短了。</p>
<p><code>解决方法二：</code>给 script 标签添加一个 <code>defer</code>的属性。表示脚本文件立即下载，但是会被延迟到整个页面都解析完毕后在执行，就是所谓的延迟执行，并且添加了 <code>defer</code>属性的 script 标签会按顺序加载文件。</p>
<p><code>解决方法三：</code> HTML5为 script 元素添加了 <code>async</code>属性，从而改变脚本的执行方式，和 <code>defer</code>属性一样只对外部脚本文件有效，都会告诉浏览器立即下载延迟执行，但是 <code>async</code> 不能保证执行顺序，所以第二个脚本可能优先于第一个脚本，它们之间没有依赖关系，而且 <code>async</code> 属性会告诉浏览器不必等下载完毕在执行，也不必等到下载或执行后在加载其他脚本，所以异步脚本不应该在加载期间修改 DOM。</p>
</blockquote>
<h3 id="动态加载脚本"><a href="#动态加载脚本" class="headerlink" title="动态加载脚本"></a>动态加载脚本</h3><blockquote>
<p>以通过向 DOM 中动态添加 script 元素同样可以加载指定的脚本。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;gibberish.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script); </span><br></pre></td></tr></table></figure>
<p>在XHTML中编写代码的规则比 HTML 中严格，这会影响使用 script 元素嵌入 javascript 代码。</p>
<h3 id="编写js时为什么需要从外部文件引入？"><a href="#编写js时为什么需要从外部文件引入？" class="headerlink" title="编写js时为什么需要从外部文件引入？"></a>编写js时为什么需要从外部文件引入？</h3><blockquote>
<p><code>可维护性：</code>如果<code>js</code>代码被分配到很多个HTML页面，会导致维护困难。而如果所有页面保存的是一个js文件，则这更容易维护。</p>
<p><code>缓存：</code>浏览器会根据特定的设置缓存所有外部文件，如果多个页面都用的是同一个 js 文件，则该文件只需要下载一次，这意味着页面加载更快。</p>
</blockquote>
<h3 id="文档模式"><a href="#文档模式" class="headerlink" title="文档模式"></a>文档模式</h3><blockquote>
<p><code>混杂模式：</code>支持非标准的特性，在所有文件中都省略文档开头的   !DOCTYPE   这中约定并不合理，因为不同浏览器差异非常大，不使用黑科技没有一直性可言。</p>
<p><code>标准模式：</code>除混合模式以外的模式。</p>
</blockquote>
<h3 id="元素"><a href="#元素" class="headerlink" title="元素"></a><noscript>元素</h3><blockquote>
<p>早期浏览器不支持 javascript ，需要做页面降级，noscript 元素出现解决了这个问题，现在浏览器已经100%支持 <code>javascript</code> 对于禁用 <code>javascript</code> 的浏览器来说，任然有用。</p>
<p>总结：通过使用元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则元素中的任何内容都不会被渲染。</p>
</blockquote>
<h3 id="“use-strict”兼容旧代码"><a href="#“use-strict”兼容旧代码" class="headerlink" title="“use strict”兼容旧代码"></a>“use strict”兼容旧代码</h3><p>有利于兼容旧代码，但缺点是 JavaScript 创造者的任何错误或不完善的决定也将永远被保留在 JavaScript 语言中。</p>
<blockquote>
<p>处于脚本文件的<code>顶部时</code>，则整个脚本文件都将以“现代”模式进行工作。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码以现代模式工作</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很快我们就会学习到函数（一种组合命令的方式），所以让我们提前注意一下，<code>&quot;use strict&quot;</code> 可以被放在函数体的开头。这样则可以只在该函数中启用严格模式。但通常人们会在整个脚本中启用严格模式。</p>
<p>请确保 <code>&quot;use strict&quot;</code> 出现在脚本的最顶部，否则严格模式可能无法启用。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;some code&quot;</span>);</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 下面的 &quot;use strict&quot; 会被忽略，必须在最顶部。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格模式没有被激活</span></span><br><span class="line">只有注释可以出现在 <span class="string">&quot;use strict&quot;</span> 的上面。</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>没有办法取消 <code>use strict</code></strong></p>
<p>没有类似于 <code>&quot;no use strict&quot;</code> 这样的指令可以使程序返回默认模式。</p>
<p>一旦进入了严格模式，就没有回头路了。</p>
</blockquote>
<p>浏览器默认是不启动<code>use strict</code> 的，可以通过几种方式启动</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;  <span class="comment">// 放在代码最顶部</span></span><br><span class="line"><span class="comment">// 此处多行回车，确保&#x27;use strict&#x27;和下方代码有一定距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  ...你的代码</span></span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">如果依然不行，例如你使用的是旧版本的浏览器</span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...你的代码...</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><a target="_blank" rel="noopener" href="https://zh.javascript.info/variables">变量命名</a></p>
<h4 id="了解老语法-var"><a href="#了解老语法-var" class="headerlink" title="了解老语法 var"></a>了解老语法 <code>var</code></h4><blockquote>
<p>1、var 的作用域</p>
<p>用 <code>var</code> 声明的变量，不是函数作用域就是全局作用域，也就是说，<code>var</code> 声明的变量只有函数作用域和全局作用域，没有块级作用域</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> age = <span class="number">19</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>)</span><br><span class="line">&gt;在外部声明的 <span class="keyword">var</span> 是直接挂载到 <span class="variable language_">window</span> 上面的 <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">age</span>)就可以访问到声明的变量</span><br><span class="line"></span><br><span class="line">&gt;-----------------------------------------------</span><br><span class="line">&gt;# <span class="keyword">var</span> 会忽略代码块</span><br><span class="line">&gt;<span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> test = <span class="literal">true</span>; <span class="comment">// 使用 &quot;var&quot; 而不是 &quot;let&quot;</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">alert</span>(test); <span class="comment">// true，变量在 if 结束后仍存在</span></span><br><span class="line"></span><br><span class="line">&gt;# 对于循环也是这样的，<span class="keyword">var</span> 声明的变量没有块级作用域也没有循环局部作用域</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">alert</span>(i);   <span class="comment">// 10，&quot;i&quot; 在循环结束后仍可见，它是一个全局变量</span></span><br><span class="line">&gt;<span class="title function_">alert</span>(one); <span class="comment">// 1，&quot;one&quot; 在循环结束后仍可见，它是一个全局变量</span></span><br></pre></td></tr></table></figure>
<p>在函数内部使用<code>var</code>声明，那么<code>var</code>将会把这个变量视为函数作用域</p>
<p><code>var</code>之所以没有块级作用域，这是因为在早期的 JavaScript 中，块没有词法环境，而 <code>var</code> 就是这个时期的代表之一。</p>
<p>2、var 的声明</p>
<p><code>var</code>可以重复声明一个变量，但是<code>新变量</code>会覆盖<code>旧变量</code>。</p>
<p><code>var</code>声明的变量会被提升到顶部，如果是函数内声明的，则会提升到函数作用域的顶部，和它在代码中的声明位置无关，但是<code>声明</code>会被提升，但是<code>赋值</code>不会。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;# <span class="keyword">if</span> (<span class="literal">false</span>) 分支永远都不会执行，但没关系，它里面的 <span class="keyword">var</span> 在函数刚开始时就被处理了，所以在执行 (*) 那行代码时，变量是存在的。</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line"> phrase = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> phrase;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">alert</span>(phrase); <span class="comment">// Hello</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure>
<p>在<code>let</code>、<code>const</code>出来之前只有var这一种声明方式，于是就发明了模仿块级作用域的方法，这方法被称为<code>立即调用函数表达式</code>，也就是常说的<code>立即执行函数</code>（括号内部属于一个作用域），注意点如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;普通函数</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 不是立即执行函数，必须要调用</span></span><br><span class="line"></span><br><span class="line">&gt;函数尾部添加 () 表示这是立即执行函数</span><br><span class="line">&gt;<span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;() <span class="comment">//报错，因为必须要有函数名，但是有了函数名又不是立即执行</span></span><br><span class="line"></span><br><span class="line">&gt;使用圆括号把该函数表达式包起来，以告诉 <span class="title class_">JavaScript</span>，这个函数是在另一个表达式的上下文中创建的，因此它是一个函数表达式：它不需要函数名，可以立即调用。不需要函数名直接执行即可。</span><br><span class="line">&gt;除了使用括号，还有其他方式可以告诉 <span class="title class_">JavaScript</span> 在这我们指的是函数表达式：</span><br><span class="line">&gt;(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;)();</span><br><span class="line">&gt;(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;());</span><br><span class="line">&gt;!<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;();</span><br><span class="line">&gt;+<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;();</span><br></pre></td></tr></table></figure>
<p>如果命名包括多个单词，通常采用驼峰式命名法</p>
</blockquote>
<h4 id="严格模式变量"><a href="#严格模式变量" class="headerlink" title="严格模式变量"></a>严格模式变量</h4><blockquote>
<p>不是严格模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;在早期进行变量声明可以使用赋值来创建一个变量，现在都习惯 定义声明。</span><br><span class="line">&gt;<span class="comment">// 注意：这个例子中没有 &quot;use strict&quot;</span></span><br><span class="line">&gt;num = <span class="number">5</span>; <span class="comment">// 如果变量 &quot;num&quot; 不存在，就会被创建</span></span><br><span class="line">&gt;<span class="title function_">alert</span>(num); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>严格模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">&gt;num = <span class="number">5</span>; <span class="comment">// 错误：num 未定义</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="let、const、var的区别？"><a href="#let、const、var的区别？" class="headerlink" title="let、const、var的区别？"></a>let、const、var的区别？</h4><blockquote>
<p>let和const只允许声明一次，而var可以被允许声明多次。</p>
<p>let和const都是块级作用域，而var则是全局或函数作用域。</p>
<p>let和var声明的变量可以修改，而使用 <code>const</code> 声明的变量称为“常量”，它们不能被修改，如果你尝试修改就会发现报错，但是这不是绝对不能修改。</p>
<p>比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>自增<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">const</span> o = &#123;</span><br><span class="line"> <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> o.<span class="property">age</span>++</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;btn.<span class="title function_">onclick</span>()</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="property">age</span>) <span class="comment">// 19</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// const如果记录的是数组或对象，则里面存储的是他们的地址，即使修改了只会对内部数据有影响对本身没有影响，如果是基础数据类型，存储的则是数据，是不允许修改的</span></span><br><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>自增<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">const</span> o = &#123;</span><br><span class="line"> <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> o = &#123;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;btn.<span class="title function_">onclick</span>()</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="property">age</span>)  <span class="comment">// 报错：Assignment to constant variable.at btn.onclick</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><a target="_blank" rel="noopener" href="https://zh.javascript.info/types">数据类型</a></p>
<blockquote>
<p>原始类型：它们的值只包含一个单独的内容</p>
<p>数字：Number</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Infinity</span>代表数学概念中的 无穷大 ∞。是一个比任何数字都大的特殊值。</span><br><span class="line">&gt;可以通过除以 <span class="number">0</span> 来得到</span><br><span class="line">&gt;或者在代码中直接使用</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">NaN</span> 代表一个计算错误。它是一个不正确的或者一个未定义的数学操作所得到的结果</span><br><span class="line">&gt;<span class="title class_">NaN</span> 是粘性的，任何对 <span class="title class_">NaN</span> 的进一步数学运算都会返回 <span class="title class_">NaN</span>，只有一个例外：<span class="title class_">NaN</span> ** <span class="number">0</span> 结果为 <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>大数字：BigInt</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;# 在 <span class="title class_">JavaScript</span> 中，“number” 类型无法安全地表示大于 (<span class="number">2</span>的<span class="number">53</span>次方-<span class="number">1</span>)（即 <span class="number">9007199254740991</span>），或小于 -(<span class="number">2</span>的<span class="number">53</span>次方-<span class="number">1</span>) 的整数。</span><br><span class="line">&gt;一旦超出安全整数范围 ±(<span class="number">2</span>的<span class="number">53</span>次方-<span class="number">1</span>) 会出现精度问题，因为并非所有数字都适合固定的 <span class="number">64</span> 位存储。因此，可能存储的是“近似值”。</span><br></pre></td></tr></table></figure>
<p>字符串：String</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;双引号：<span class="string">&quot;Hello&quot;</span></span><br><span class="line">&gt;单引号：<span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">&gt;反引号：<span class="string">`Hello`</span></span><br><span class="line">&gt;反引号允许$&#123;…&#125;嵌入到字符串中</span><br><span class="line">&gt;$&#123;&#125;模版运算符</span><br></pre></td></tr></table></figure>
<p>布尔：Boolean</p>
<p>仅包含两个值：<code>true</code> 和 <code>false</code></p>
<p>特殊：null</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="literal">null</span> 仅仅是一个代表“无”、“空”或“值未知”的特殊值。</span><br></pre></td></tr></table></figure>
<p>特殊：undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;如果一个变量已被声明，但未被赋值，那么它的值就是 <span class="literal">undefined</span></span><br><span class="line">&gt;从技术上讲，可以将 <span class="literal">undefined</span> 赋值给变量，但是不建议这样做。通常，使用 <span class="literal">null</span> 将一个“空”或者“未知”的值写入变量中，而 <span class="literal">undefined</span> 则保留作为未进行初始化的事物的默认初始值。</span><br></pre></td></tr></table></figure>
<p>对象：Object</p>
<p><code>object</code> 则用于储存数据集合和更复杂的实体</p>
<p>唯一性：<code>symbol</code> 类型用于创建对象的唯一标识符。</p>
<p>typeof：当我们想要分别处理不同类型值的时候，或者想快速进行数据类型检验时，非常有用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">typeof</span> <span class="literal">null</span> 的结果为 <span class="string">&quot;object&quot;</span>。这是官方承认的 <span class="keyword">typeof</span> 的错误，这个问题来自于 <span class="title class_">JavaScript</span> 语言的早期阶段，并为了兼容性而保留了下来。<span class="literal">null</span> 绝对不是一个 object。<span class="literal">null</span> 有自己的类型，它是一个特殊值。<span class="keyword">typeof</span> 的行为在这里是错误的。</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">typeof</span> alert 的结果是 <span class="string">&quot;function&quot;</span>，因为 alert 在 <span class="title class_">JavaScript</span> 语言中是一个函数。在 <span class="title class_">JavaScript</span> 语言中没有一个特别的 “<span class="keyword">function</span>” 类型。函数隶属于 object 类型。但是 <span class="keyword">typeof</span> 会对函数区分对待，并返回 <span class="string">&quot;function&quot;</span>。这也是来自于 <span class="title class_">JavaScript</span> 语言早期的问题。从技术上讲，这种行为是不正确的，但在实际编程中却非常方便。</span><br></pre></td></tr></table></figure>
<p>你可能还会遇到另一种语法：<code>typeof(x)</code>。它与 <code>typeof x</code> 相同。</p>
</blockquote>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><a target="_blank" rel="noopener" href="https://zh.javascript.info/operators">运算符</a></p>
<blockquote>
<p>数学运算符：</p>
<ul>
<li>加法 <code>+</code></li>
<li>减法 <code>-</code></li>
<li>乘法 <code>*</code></li>
<li>除法 <code>/</code></li>
<li>取余 <code>%</code></li>
<li>求幂 <code>**</code></li>
</ul>
</blockquote>
<h3 id="【JS】说一下-new-一个构造函数的执行过程？"><a href="#【JS】说一下-new-一个构造函数的执行过程？" class="headerlink" title="【JS】说一下 new 一个构造函数的执行过程？"></a>【JS】说一下 new 一个构造函数的执行过程？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1- new在声明函数的时候会自动在函数内部创建一个空对象</span><br><span class="line">2- 将新对象的原型设置为构造函数的原型对象(函数内部的this指向这个空对象)</span><br><span class="line"><span class="comment"># 把构造函数的 this 关键字绑定到新创建的对象上，这样构造函数内部的代码就可以访问到新对象的属性和方法</span></span><br><span class="line">3- 执行构造函数代码</span><br><span class="line">4- 执行完毕 <span class="string">&#x27;自动&#x27;</span> 返回结果</span><br><span class="line">5- 外部声明变量存储这个结果</span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下-call-和-apply-及-bind-的区别？"><a href="#【JS】说一下-call-和-apply-及-bind-的区别？" class="headerlink" title="【JS】说一下 call 和 apply 及 bind 的区别？"></a>【JS】说一下 call 和 apply 及 bind 的区别？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`call` 和 `apply` 都是函数对象的方法，它们的作用都是在特定的作用域中调用函数，它们的第一个参数都是代表该函数调用时的上下文对象，也就是该函数调用时 `this` 的指向，而后面的参数则是函数调用时的参数。</span><br><span class="line"></span><br><span class="line">`call` 和 `apply` 的不同之处在于传入参数的方式不同。`call` 方法接受的是<span class="string">&#x27;多个参数列表&#x27;</span>，而 `apply` 方法接受的是一个参数<span class="string">&#x27;数组&#x27;</span>。</span><br><span class="line"></span><br><span class="line">`<span class="built_in">bind</span>` 方法用于创建一个新函数，并将原函数的 `this` <span class="string">&#x27;绑定到指定的对象&#x27;</span>上。`<span class="built_in">bind</span>` 方法在函数式编程中十分实用，它不仅方便了函数的调用，同时也使得函数的 `this` 不再受到外界的影响，使得代码更加健壮。</span><br><span class="line"></span><br><span class="line">简单来说，`call` 和 `apply` 是直接调用一个函数，而 `<span class="built_in">bind</span>` 则是返回一个原函数的拷贝，并绑定指定的 `this` 值和参数。</span><br></pre></td></tr></table></figure>
<h3 id="注册事件-绑定事件"><a href="#注册事件-绑定事件" class="headerlink" title="注册事件/绑定事件"></a>注册事件/绑定事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 原生<span class="variable constant_">JS</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;获取到的标签&#x27;</span>).<span class="title function_">addEventListener</span>(事件类型，事件回调函数)</span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下你对事件委托的理解？"><a href="#【JS】说一下你对事件委托的理解？" class="headerlink" title="【JS】说一下你对事件委托的理解？"></a>【JS】说一下你对事件委托的理解？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是什么?</span></span><br><span class="line">是一种JavaScript中常用的优化事件处理的技术，它利用事件冒泡机制将事件处理程序添加到相对静态的父元素上（比如页面中的顶层容器），而不是将事件处理程序直接添加到子元素上。</span><br><span class="line">---------------------------------------------------</span><br><span class="line"><span class="comment"># 解决了什么问题?</span></span><br><span class="line">它能够有效地减少事件处理程序的数量，从而提高页面性能和响应速度</span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="comment"># 好处是什么?</span></span><br><span class="line">1.性能高</span><br><span class="line">2.对后续新增的元素同样具有事件绑定的效果</span><br><span class="line">性能优化, 减少代码复杂性, 方便动态操作, 提高代码可维护性</span><br><span class="line">----------------------------------------------------</span><br><span class="line"><span class="comment"># 如何按需触发</span></span><br><span class="line">使用自定义事件</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;ul <span class="built_in">id</span>=<span class="string">&quot;oUl&quot;</span>&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">    &lt;li data-mark=<span class="string">&quot;black&quot;</span>&gt;2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">    &lt;li data-mark=<span class="string">&quot;black&quot;</span>&gt;4&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;5&lt;/li&gt;</span><br><span class="line">    &lt;li data-mark=<span class="string">&quot;black&quot;</span>&gt;6&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    oUl.addEventListener(<span class="string">&#x27;click&#x27;</span>,(e)=&gt;&#123;</span><br><span class="line">      <span class="keyword">if</span>(e.target.dataset.mark!==<span class="string">&#x27;black&#x27;</span>)<span class="built_in">return</span></span><br><span class="line">      console.log(<span class="string">&#x27;~~~~~~~~~`&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 好处是什么？</span></span><br><span class="line">只有点击到指定的自定义事件才会触发，减少误触的频率</span><br><span class="line">---------------------------------</span><br><span class="line"><span class="comment"># 原理</span></span><br><span class="line">事件委托则是将事件处理程序添加到父级元素上，利用冒泡机制实现在父元素上处理子元素的事件。</span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line">逐字稿: 把平常给子元素绑定的事件 统一给绑定到祖先元素身上， 比如说有很多个一样的事件， 这时候不需要给每一个子元素绑定事件， 我们会直接绑定到 父元素身上， 这样做性能就会很高 会对后续新增的元素也会有一样的效果， 底层原理是通过事件冒泡 冒泡到祖先元素身上。</span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下你对防抖和节流的理解？"><a href="#【JS】说一下你对防抖和节流的理解？" class="headerlink" title="【JS】说一下你对防抖和节流的理解？"></a>【JS】说一下你对防抖和节流的理解？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">防抖: 单位时间内高频事件, 只触发最后一次</span><br><span class="line">节流: 单位时间内高频事件, 只触发第一次</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line"><span class="comment"># 是什么？</span></span><br><span class="line">防抖和节流都是性能优化的一种手段，防抖就是持续触发（事件）不执行，不触发的一段时间后才执行：节流就是持续触发也执行，只不过执行的频率变低了。</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line"><span class="comment"># 在哪用?</span></span><br><span class="line">防抖：根据用户输入的内容发送请求。 场景：输入框</span><br><span class="line">节流：获取窗口滚动的位置。场景：滚动条</span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="comment"># 怎么做？</span></span><br><span class="line">一般可以结合定时器封装方法来实现，或者使用 lodash 提供的 throttle 方法。</span><br><span class="line">------------------------------------------------</span><br><span class="line">逐字稿： 防抖和节流都是性能优化的一种手段， 防抖就是持续触发（事件）不执行，不触发的一段时间后才执行；节流就是持续触发也执行，只不过执行的频率变低了。 有多低取决于节流时间是多少， 一般用的时候回考虑去封装函数来使用， 可能封装函数的时候回用到定时器相关的 或者使用 lodash 提供的 debounce 和 throttle 方法， 应用场景 根据用户输入的内容来发请求，这时候就可以用到防抖   <span class="comment"># 例如在窗口滚动的时候，希望获取到滚动位置，但是获取位置的频率不希望很高，这时候就可以考虑使用节流</span></span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下你对-EventLoop-衣闻特咯普-的理解？"><a href="#【JS】说一下你对-EventLoop-衣闻特咯普-的理解？" class="headerlink" title="【JS】说一下你对 EventLoop(衣闻特咯普) 的理解？"></a>【JS】说一下你对 EventLoop(衣闻特咯普) 的理解？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是什么?</span></span><br><span class="line">EventLoop又叫事件循环，是单线程语言js在运行代码是不被阻塞的一种机制</span><br><span class="line">--------------------------------------------</span><br><span class="line"><span class="comment"># 解决了什么问题？</span></span><br><span class="line">解决了js单线程的缺陷</span><br><span class="line">--------------------------------------------</span><br><span class="line"><span class="comment"># 好处是什么？</span></span><br><span class="line">代码永不堵塞</span><br><span class="line">------------------------------------</span><br><span class="line"><span class="comment"># 原理是什么？</span></span><br><span class="line">1-判断代码是<span class="string">&#x27;同步&#x27;</span>还是<span class="string">&#x27;异步&#x27;</span></span><br><span class="line">2-同步<span class="string">&#x27;立即执行&#x27;</span></span><br><span class="line">3-异步等<span class="string">&#x27;同步执行完毕&#x27;</span>在执行</span><br><span class="line">4-异步代码分<span class="string">&#x27;微任务和宏任务&#x27;</span></span><br><span class="line">5-<span class="string">&#x27;先&#x27;</span>执行微任务</span><br><span class="line">6-<span class="string">&#x27;后&#x27;</span>执行宏任务</span><br><span class="line">7-执行完毕, 如果还有宏任务没有执行, 则继续执行上面操作</span><br><span class="line">----------------------------------------------</span><br><span class="line">逐字稿：EventLoop是js的一种解决代码阻塞的运行机制，因为js是单线程运行，如果代码过多会形成上一个代码未运行完毕，下一个代码到了运行时间形成代码堵塞会大大降低代码的运行速度，所以EventLoop专门处理这个事情，他会将代码分为同步代码和异步代码，同步代码执行，异步代码后执行，而异步代码比同步代码复杂，所以又将异步代码分为了微任务和宏任务，微任务比宏任务的运行速度更快，所以会先执行微任务在执行宏任务，宏任务又会进行分析代码是同步还是异步，重复以往操作。</span><br></pre></td></tr></table></figure>
<h3 id="浏览器的进程模型"><a href="#浏览器的进程模型" class="headerlink" title="浏览器的进程模型"></a>浏览器的进程模型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 何为进程？</span><br><span class="line">程序运行需要它自己专属的<span class="string">&#x27;内存空间&#x27;</span>，可以把这块内存空间简单的理解为进程，每个应用至少有一个进程，进程之间相互独立，即使通信，也需要双方同意。</span><br><span class="line"></span><br><span class="line"># 何为线程？</span><br><span class="line">有了进程后，就可以运行程序的代码了，运行代码的<span class="string">&#x27;任务队列&#x27;</span>被称为<span class="string">&#x27;线程&#x27;</span>。</span><br><span class="line">一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来专门运行代码，这个线程被称为主线程，如果程序需要同时执行多行代码，主线程就会启动更多的线程来执行代码，所以一个进程可以包含多个线程。</span><br><span class="line"></span><br><span class="line"># 浏览器有哪些进程和线程？</span><br><span class="line">例如：浏览器进程、网络进程、渲染进程</span><br><span class="line">浏览器是一个多进程多线程的应用程序，浏览器内部工作极其复杂，为了避免相互影响，为了减少崩溃的几率，当启动浏览器后，会自动启动多个进程。</span><br><span class="line">可以在浏览器的任务管理器中查看当前的所有进程</span><br><span class="line"></span><br><span class="line"># 思考题：为什么渲染进程不适用多个线程来处理这些事情？</span><br><span class="line"></span><br><span class="line"># 如何理解 <span class="variable constant_">JS</span> 的异步？</span><br><span class="line"><span class="variable constant_">JS</span> 是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个，而渲染主线程有着非常多的工作，渲染页面执行 <span class="variable constant_">JS</span> 都是在这执行的，如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行，这样一来导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。</span><br><span class="line">所以浏览器采用异步的方式来避免，就是正在执行时突然某些任务执行了，如定时器时间到了、用户点击了按钮等，主线程就把这个任务交给其他线程去处理，自身则继续执行剩余任务，其他线程执行完毕会传递到包装起来并加入到<span class="string">&#x27;消息队列&#x27;</span>的末尾，等待主线程调用。</span><br><span class="line">这种异步模式下浏览器永不阻塞，从而保证了单线程的流畅运行。</span><br><span class="line"></span><br><span class="line"># <span class="variable constant_">JS</span> 为何会阻塞渲染？</span><br><span class="line">因为 <span class="variable constant_">JS</span> 和渲染主线程都在一起执行，当执行 <span class="string">&#x27;渲染主线程&#x27;</span> 时 <span class="string">&#x27;JS&#x27;</span> 需要等待执行完毕，执行 <span class="string">&#x27;JS&#x27;</span> 时 <span class="string">&#x27;渲染主线程&#x27;</span> 需要等待执行完毕。</span><br><span class="line"></span><br><span class="line"># 任务有优先级吗？</span><br><span class="line">任务没有优先级，在消息队列中先进先出，但消息队列是有优先级的 ---&gt;</span><br><span class="line">每个任务都有以一个任务类型(<span class="string">&#x27;如：计时器类型、事件类型等&#x27;</span>)，同一类型的任务必须在一个队列(<span class="string">&#x27;例如所有的事件必须在同一队列中排队执行&#x27;</span>)，不同类型的任务可以分属于不同的队列(注意：不同类型的同一类型也必须在同一队列)，在一次事件循环中，浏览器可以根据实际情况从不同的任务队列中取出任务执行。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在目前 chrome 的实现中，至少包含了下面的队列：</p>
<ul>
<li>延时队列：用于存放计时器到达后的回调任务，优先级「中」</li>
<li>交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」</li>
<li>微队列：用户存放需要最快执行的任务，优先级「最高」</li>
</ul>
</blockquote>
<h3 id="EventLoop额外问答-vue-一定是一秒打印吗？"><a href="#EventLoop额外问答-vue-一定是一秒打印吗？" class="headerlink" title="EventLoop额外问答? vue 一定是一秒打印吗？"></a>EventLoop额外问答? vue 一定是一秒打印吗？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="string">&#x27;react&#x27;</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">	console.log(&#x27;vue&#x27;)</span><br><span class="line"># &#x27;vue&#x27; 是一秒打印的吗？</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">console.log(&#x27;angular&#x27;)</span><br><span class="line"></span><br><span class="line">答：不一定，并官网是这样解释的</span><br><span class="line"># !零延迟</span><br><span class="line">零延迟并不意味着`回调会立即执行`。以 <span class="number">0</span> 为第二参数调用 setTimeout 并不表示在 <span class="number">0</span> 毫秒后就立即调用回调函数。</span><br><span class="line">其等待的时间取决于队列里`待处理的消息数量`。在下面的例子中，&quot;这是一条消息&quot; 将会在回调获得处理之前输出到控制台，这是因为延迟参数是运行时处理请求所需的最小等待时间，但并不保证是准确的等待时间。</span><br><span class="line">基本上，setTimeout 需要等待当前队列中所有的消息都处理完毕之后才能执行，即使已经&#x27;超出了由第二参数所指定的时间&#x27;。</span><br></pre></td></tr></table></figure>
<h3 id="如何保证vue中的代码一秒打印-使用web-worker开启js的多线程"><a href="#如何保证vue中的代码一秒打印-使用web-worker开启js的多线程" class="headerlink" title="如何保证vue中的代码一秒打印? 使用web worker开启js的多线程"></a>如何保证vue中的代码一秒打印? 使用web worker开启js的多线程</h3><blockquote>
<p>JavaScript其中一个基本的特性就是<code>单线程</code>,比如浏览器<code>无法同时运行</code>两个事件处理程序，也无法在一个事件处理程序运行的时候触发定时器。之所以设置单线程的理论就是，客户端的JavaScript的函数不能运行太长时间，否则会导致<code>循环事件</code>，Web浏览器无法对用户输入做出响应，这也是为什么AJAX的API都是异步的，以及为什么客户端Javascript不能使用一个简单的异步load()或者require()函数来加载javascript库。<br>在<code>Web Worker</code>标准中，定义了解决客户端JavaScript<code>无法多线程的问题</code>，其中定义的 “ Worker “ 是指执行代码的并行线程，不过，<code>Web Worker</code>处在一个自包含的执行环境中，无法访问 Window 对象和 Document 对象，和主线程之间的通信也只能通过异步消息传递机制实现，这就意味着，并行的修改DOM是不可能的。</p>
</blockquote>
<h3 id="【JS】如何并发请求且根据请求的书写顺序拿到对应的结果？"><a href="#【JS】如何并发请求且根据请求的书写顺序拿到对应的结果？" class="headerlink" title="【JS】如何并发请求且根据请求的书写顺序拿到对应的结果？"></a>【JS】如何并发请求且根据请求的书写顺序拿到对应的结果？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是什么？</span></span><br><span class="line">-----------------------------------------</span><br><span class="line"><span class="comment"># 怎么用？</span></span><br><span class="line">promise.all([])   &lt;------ all，接收一个数组，数组里面可以接收无数个请求</span><br><span class="line">都成功后会触发 .<span class="keyword">then</span>(r=&gt;&#123;&#125;)   r 一定是所有数据的结果，返回的数据顺序一定是传入数组的顺序</span><br><span class="line">如果中间有任意一个出错了，会触发 catch </span><br><span class="line">-----</span><br><span class="line">`<span class="comment"># 如果在 catch 后面又有一个 .then() 这个 then 会被触发吗？`</span></span><br><span class="line">答：一定会被触发，但是这个 .<span class="keyword">then</span>() 里面的结果一定是 undefined ，因为 .<span class="keyword">then</span>() 写在 catch() 后面，而catch()</span><br><span class="line">--------------------------------------</span><br><span class="line"><span class="comment"># 场景是什么?</span></span><br><span class="line">我们使用了<span class="string">&#x27;Promise.all()&#x27;</span>方法来并发异步请求，并使用<span class="string">&#x27;map()&#x27;</span>方法来保证结果输出的顺序和输入的顺序一致。使用Promise.all()方法可以有效提高请求的并发效率，让请求尽可能同时进行，而不是一个一个等待。</span><br><span class="line"></span><br><span class="line">当所有请求都得到响应以后，Promise.all()方法会返回一个由所有请求的响应结果组成的数组 results(维肉特)，可以根据这个数组按照请求的先后顺序重新排列结果，以保证结果顺序与请求的顺序一致。最后我们通过遍历这个排好序的数组来输出每个响应结果的数据。</span><br><span class="line"></span><br><span class="line">这种方式比较简单，同时也非常实用，可以适用于各种场景，比如处理同时发起的多个请求，并根据请求的先后顺序来处理响应结果。</span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下你对-Promise-的理解？"><a href="#【JS】说一下你对-Promise-的理解？" class="headerlink" title="【JS】说一下你对 Promise 的理解？"></a>【JS】说一下你对 Promise 的理解？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">promise是ES6中新增的构造函数</span><br><span class="line">作用: 解决回调地狱, 层层嵌套, 异步回调</span><br><span class="line">原理: promise 中有三种执行状态, 分别是 立即执行（pending）、执行成功（fulfilled 佛非而特）、执行失败（rejected）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是什么?</span></span><br><span class="line">promise是ES6新增加的特性, 他是一个函数(构造函数)</span><br><span class="line">----------------------------------------------------</span><br><span class="line">Promise相关的几个静态方法？</span><br><span class="line">1、`Promise.race()`：接收多个 Promise 实例，可以得到`最先处理完毕`的结果（可能是成功，也可能是失败）。</span><br><span class="line"><span class="string">&#x27;Promise.race([p1,p2,p3])&#x27;</span></span><br><span class="line">2、`Promise.all()`：接收多个 Promise 实例，都成功了才会被触发 <span class="keyword">then</span>，有一个失败就会触发 catch 。 </span><br><span class="line"><span class="string">&#x27;Promise.all([p1,p2,p3]).then( r =&gt; console.log(r) )&#x27;</span></span><br><span class="line">// [p1 的结果，p2 的结果，p3 的结果]</span><br><span class="line">3、`Promise.any()`：接收多个 Promise 实例，可以得到`最先处理成功`的结果，都失败了才会触发 catch 。</span><br><span class="line"><span class="string">&#x27;Promise.any([p1，p2，p3])&#x27;</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment"># 解决了什么问题？</span></span><br><span class="line">它解决了回调地狱的问题。</span><br><span class="line"><span class="comment"># 有没有替代方案</span></span><br><span class="line">promise虽然解决了回到地狱的问题, 但是不能简化代码, 所以一般用的时候, 会使用async和await来配合promise, 这样的话既解决了回调地狱的问题也简化了代码</span><br><span class="line">----------------------------------------------------</span><br><span class="line"><span class="comment"># 怎么用?</span></span><br><span class="line">一般当做构造函数来使用, 也就意味着一般要new一下使用, 创建一个 Promise实例 他里面有三种状态, [padding立即执行, fulfilled成功和rejected失败],</span><br><span class="line">成功触发<span class="keyword">then</span> , 失败触发catch，还有一个finally是永远都会被触发。</span><br><span class="line">----------------------------------------------------</span><br><span class="line"><span class="comment"># Promise相关的几个静态方法？</span></span><br><span class="line">Promise.race()接收多个 promise 实例，可以得到最先处理完毕的结果（可能是成功，也可能是失败）</span><br><span class="line">Promise.race([p1,p2,p3])</span><br><span class="line"></span><br><span class="line">Promise.all()：接收多个Promise实例，都成功了会触发<span class="keyword">then</span>，有一个失败就会触发 catch</span><br><span class="line">Promise.all([p1,p2,p3])</span><br><span class="line"></span><br><span class="line">Promise.any()：接收多个Promise实例，可以得到最先处理成功的结果，都失败了才会触发catch</span><br><span class="line">Promise.any([p1,p2,p3])</span><br></pre></td></tr></table></figure>
<h3 id="【JS】函数传参简单数据类型和复杂数据类型有什么差异？"><a href="#【JS】函数传参简单数据类型和复杂数据类型有什么差异？" class="headerlink" title="【JS】函数传参简单数据类型和复杂数据类型有什么差异？"></a>【JS】函数传参简单数据类型和复杂数据类型有什么差异？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数传参实际上就是<span class="string">&#x27;实参&#x27;</span>赋值给<span class="string">&#x27;形参&#x27;</span></span><br><span class="line">简单数据类型就是拷贝数据给形参, 一旦发生修改对原数据没有影响</span><br><span class="line">复杂数据类型就是拷贝地址给形参, 一旦发生改变对原数据有影响</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">简单数据类型传递的是值的拷贝，函数内部对参数的修改不会影响外部；</span><br><span class="line">复杂数据类型传递的是引用的地址，函数内部对<span class="string">&#x27;参数内容&#x27;</span>的修改会影响到外部，对<span class="string">&#x27;参数引用&#x27;</span>的修改不会影响到外部。</span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下图片懒加载的实现原理？"><a href="#【JS】说一下图片懒加载的实现原理？" class="headerlink" title="【JS】说一下图片懒加载的实现原理？"></a>【JS】说一下图片懒加载的实现原理？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是什么?</span></span><br><span class="line">图片懒加载是一种通过<span class="string">&#x27;延迟加载图片&#x27;</span>来优化网页性能的技术。</span><br><span class="line">------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 怎么用?</span></span><br><span class="line">1. 首先，在HTML中将需要懒加载的图片的src属性设置为一个占位符或空字符串：  <span class="comment"># 其中 data-src 属性用于存放真实的图片地址，src 则设置为占位符或空字符串。</span></span><br><span class="line">2.在JavaScript代码中，使用 window.addEventListener 方法来监听页面的滚动事件：</span><br><span class="line">3.在滚动事件中，遍历需要懒加载的图片元素，判断其相对于视窗的位置： <span class="comment"># 这里使用 getBoundingClientRect() 方法获取图片相对于视窗的位置，如果其顶部位置小于视窗高度，则表示该图片已经进入了视窗范围内，需要开始加载。</span></span><br><span class="line">4.在开始加载图片时，将占位符或空字符串的 src 属性替换为真实图片地址： <span class="comment"># 这里使用 dataset 属性获取 data-src 存放的真实图片地址，并将其赋值给 src 属性，此时图片即开始加载。同时，将原来设置的 lazy 类名移除，避免重复加载。</span></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决了什么问题?</span></span><br><span class="line">1.带宽和服务器负担 <span class="comment">#在传统的图片加载方式中，所有图片都会在页面加载时一次性加载，无论用户是否浏览。当页面中存在大量图片时，这会导致页面响应时间变慢，用户等待的时间加长，同时还会占用更多的带宽和服务器资源 , 而使用图片懒加载，只有用户滚动到相应区域时才会加载图片，大量减少了初始加载时需要加载的图片数量，从而减轻了带宽和服务器负担。</span></span><br><span class="line">2.用户体验：<span class="comment"># 使用图片懒加载可以提高用户的体验，特别是在移动设备上。在移动设备上，用户通常会花费更少的时间在页面上，因此减少等待时间和提高响应速度非常重要。使用懒加载可以使页面更快地呈现出来，用户不需要等待所有图片加载完成即可开始浏览页面，这可以显著提高用户的满意度和留存率。</span></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有没有替代方案</span></span><br><span class="line">1.`压缩图片`：在保证图片质量的前提下，压缩图片可以直接减小图片的大小，从而加快图片的加载速度。</span><br><span class="line"></span><br><span class="line">2.将图片转换为 `WebP 格式`：WebP 格式是一种高效的图片格式，通常比 JPEG 格式的图片大小减小 25%-35%。将网页中的图片转换为 WebP 格式可以减少图片的大小，从而加快页面的加载速度。</span><br><span class="line"></span><br><span class="line">3.使用 CSS3 的 `background-image 属性`：在一些场景下，可以使用 CSS3 的 background-image 属性来代替 img 标签加载图片。这种方式可以减少 HTTP 请求的数量，从而加快页面的加载速度。</span><br><span class="line"></span><br><span class="line">4.`预加载图片`：对于一些关键的图片，可以使用预加载的方式将图片在用户进入页面之前全部加载完成，从而避免滚动时出现的图片加载延迟。</span><br><span class="line">-----------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 好处是什么?</span></span><br><span class="line">- 使用图片懒加载可以优化网页性能，提高用户体验，同时减轻服务器负担和节省用户成本</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.加快网页加载速度：使用图片懒加载可以减少初始加载时需要下载的图片数量，从而加快网页的加载速度。尤其是对于大型图片和大量图片的网页，优化加载方式可以显著地缩短用户等待的时间，从而提高用户体验。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.减轻服务器负担：一次性加载大量图片会占用服务器资源和网络带宽，使用图片懒加载可以在一定程度上减轻服务器负担，降低服务端成本。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.节省用户流量：在移动设备上，用户流量往往很宝贵，使用图片懒加载可以减少用户需要消耗的流量，节省用户成本。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.提高页面性能：使用图片懒加载可以缩短页面的响应时间和渲染时间，降低页面的 CPU 和内存占用，从而提高页面的性能。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.改善用户体验：优化页面加载速度可以改善用户体验，用户不需要等待所有图片加载完成即可开始浏览页面，可以显著提高用户的满意度和留存率。</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="comment"># 场景是什么?</span></span><br><span class="line">网页中包含大量图片：<span class="comment"># 当一个网页中包含大量图片时，一次性下载所有图片会占用很多带宽和服务器资源，加重了网页的加载负担，容易导致用户等待时间过长。使用图片懒加载可以优化图片加载方式，只有当用户浏览到相应的图片时才进行下载，从而缩短页面加载时间。</span></span><br><span class="line"></span><br><span class="line">移动端网页：<span class="comment"># 在移动设备上，页面的加载速度是一个非常关键的因素。由于移动设备的带宽和处理能力有限，使用懒加载可以提高页面的响应速度，提高用户体验。</span></span><br><span class="line"></span><br><span class="line">长页面：<span class="comment"># 当一个页面非常长时，一次性下载所有图片也会导致页面加载缓慢，影响用户体验。使用图片懒加载则可以优化加载方式，使得用户只需加载当前部分所需要的图片，避免一次性下载大量图片的问题。</span></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="comment"># 原理是什么?</span></span><br><span class="line">在HTML中 图片的src属性被设置为`空字符串`或者`占位符图片`，在页面滚动到相应图片位置时，通过`监听滚动事件`来判断图片是否在可见区域内。如果是，则修改img标签的src属性，让图片开始加载，如果不是，则不进行加载，从而避免了一次性加载大量图片造成的性能问题。这样可以提高网站的加载速度和用户的体验。</span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line">逐字稿：有两种方法：位置计算、和浏览器提供的 IntersectionObserver</span><br><span class="line"><span class="string">&#x27;位置计算&#x27;</span>：如果【图片顶部距离窗口数值】小于等于【可视区文档的高度】，说明进入了可视区。</span><br><span class="line">浏览器新增的 IntersectionObserver：通过浏览器提供的 IntersectionObserver 对象创建一个实例，调用实例的 observe 方法可以观测某个img元素；在 IntersectionObserver 的参数回调里面可以通过 `isIntersecting` 属性来判断这个 img 元素是否进入可视区；如果进入就把 img 元素上装地址的某个属性给图片真正的 src 属性。</span><br><span class="line">图片懒加载的原理是：如果图片进入了可视区就把图片上装地址的某个属性给图片真正的 src 属性，如何判断图片进入了可视区？1.位置的计算、2.利用浏览器提供的API IntersectionObserver</span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下-null-和-undefined-的差异是什么？"><a href="#【JS】说一下-null-和-undefined-的差异是什么？" class="headerlink" title="【JS】说一下 null 和 undefined 的差异是什么？"></a>【JS】说一下 null 和 undefined 的差异是什么？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">null表示一个对象被定义了, 值为<span class="string">&quot;空值&quot;</span></span><br><span class="line">undefined表示不存在这个值</span><br><span class="line"></span><br><span class="line">undefined表示没有声明,并且值为空, null表示声明了, 没有赋值, == 只比较值 所以在值类型里面null==undefined  // <span class="literal">true</span></span><br><span class="line">他们值相等, 但是类型并不一样, 一个是声明了, 一个是未声明</span><br><span class="line"></span><br><span class="line">null==undefined   // <span class="literal">true</span></span><br><span class="line">只比较值类型的话两个的值都属于空, 所以类型相同</span><br><span class="line"></span><br><span class="line">null===undefined   // <span class="literal">false</span></span><br><span class="line">比较完值类型后比较数据类型, null是空值, 而undefined 是声明了未定义</span><br><span class="line"></span><br><span class="line">null + 数字 = 0</span><br><span class="line">undefi + 数字 = NaN</span><br><span class="line"></span><br><span class="line">typeof 的表现 不同</span><br><span class="line">typeof null   // <span class="string">&#x27;object&#x27;</span></span><br><span class="line">typeof undefined   // <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">和数字相加的表现</span><br><span class="line">null + 4   //4</span><br><span class="line">undefined + 7   // NaN</span><br><span class="line"><span class="comment"># null和undefined在内部会自动调用 Number 这个方法将null和nudefined转换成数字类型</span></span><br><span class="line">// Number(null) // 0</span><br><span class="line">// Number(undefined) //NaN</span><br><span class="line">-----------------------------------------</span><br><span class="line"><span class="comment"># JSON.stringify  把undefined和null转换成 JSON 型，undefined会被忽略掉，null则会被保留下来</span></span><br><span class="line">JSON.stringify(&#123;foo:undefined,bar:null&#125;) // <span class="string">&#x27;&#123;bar:null&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="如何判断属性的数据类型？"><a href="#如何判断属性的数据类型？" class="headerlink" title="如何判断属性的数据类型？"></a>如何判断属性的数据类型？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">typeof</span> 检测一些基本的数据类型</span><br><span class="line">语法：<span class="keyword">typeof</span> 后面加不加括号都是可以用的</span><br><span class="line">注意：正则、&#123;&#125;、[]、<span class="literal">null</span>输出结果为object</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> /\d/);<span class="comment">//object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;);<span class="comment">//object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []);<span class="comment">//object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> (<span class="literal">null</span>));<span class="comment">//object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">123</span>);<span class="comment">//number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>);<span class="comment">//boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;);<span class="comment">//function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> (<span class="literal">undefined</span>));<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"># <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>()     万能检测数据类型</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([])) <span class="comment">// [object Array]</span></span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下你对闭包的理解？"><a href="#【JS】说一下你对闭包的理解？" class="headerlink" title="【JS】说一下你对闭包的理解？"></a>【JS】说一下你对闭包的理解？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># 是什么？</span><br><span class="line"># 闭包-- 在一个函数内部调用另一个函数体里面的局部变量就会形成闭包, 他是js中的被动技能, 可以比喻成空气一般无处不在</span><br><span class="line">闭包：【一个函数】使用了其【外部函数】中的局部变量，使用变量的地方我们称为发生了【闭包现象】，变量定义所在的函数我们称为【闭包函数】。</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="keyword">let</span> age = <span class="number">18</span></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> 	<span class="variable language_">console</span>.<span class="title function_">log</span>(age + <span class="number">1</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="title function_">foo</span>()</span><br><span class="line"><span class="title function_">bar</span>()</span><br><span class="line">--------------------------------------------------</span><br><span class="line"># 有什么用？ 特性?</span><br><span class="line">普通函数调用完毕，内部局部变量马上销毁。</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line">闭包函数调用完毕，会使内部形成这个【闭包函数】的变量（age）常驻内存，所以 <span class="string">`滥用`</span> 闭包会造成内存浪费。</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">18</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    age += <span class="number">1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="title function_">foo</span>() <span class="comment">// foo 中的 age 在内存中没有释放</span></span><br><span class="line"><span class="title function_">bar</span>()<span class="comment">//19</span></span><br><span class="line"><span class="title function_">bar</span>()<span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;只要符合了以上概览都是闭包&#x27;</span></span><br><span class="line">--------------------------------------------------</span><br><span class="line">-# 测试题</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line">-----</span><br><span class="line">;(<span class="keyword">function</span>(<span class="params"></span>)&#123;h</span><br><span class="line">    <span class="keyword">let</span> age = <span class="number">18</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(age + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">foo</span>()</span><br><span class="line">&#125;)()</span><br><span class="line">-----------------------------------------</span><br><span class="line"># 官网解释：</span><br><span class="line">闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。换而言之，闭包让开发者可以从<span class="string">&#x27;内部函数访问外部函数的作用域&#x27;</span>。在 <span class="title class_">JavaScript</span> 中，闭包会随着函数的创建而被同时创建。</span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下-localstorage-和-sessionStorage-及-Cookie-的差异？"><a href="#【JS】说一下-localstorage-和-sessionStorage-及-Cookie-的差异？" class="headerlink" title="【JS】说一下 localstorage 和 sessionStorage 及 Cookie 的差异？"></a>【JS】说一下 localstorage 和 sessionStorage 及 Cookie 的差异？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 都是用来存储数据的,</span><br><span class="line"><span class="variable language_">localStorage</span>是存储在硬盘空间的, 属于永久存储</span><br><span class="line">seeionStorage是存储在内存中的,属于临时存储, 电脑一旦关闭数据就丢失</span><br><span class="line"><span class="title class_">Cookie</span>是存储在客户端, 网页一旦关闭数据就会丢失</span><br><span class="line">-----------------------------------------------</span><br><span class="line"># 差异？ </span><br><span class="line"># 生命周期不一样</span><br><span class="line"><span class="variable language_">localStorage</span>：永久存储，除非手动删除。</span><br><span class="line">seesionStorage：关闭当前<span class="string">`页面`</span>后会自动清除</span><br><span class="line">cookie：默认关闭<span class="string">`浏览器`</span>后失效，如果设置了过期时间，则到达过期时间后才失效。</span><br><span class="line"></span><br><span class="line"># 生效范围不一样</span><br><span class="line"><span class="variable language_">localStorage</span>： 同域都可以共享。</span><br><span class="line">seesionStorage：只有当前标签页才能访问。</span><br><span class="line">cookie：同域下且 <span class="string">`path`</span> 匹配的情况下才能访问。</span><br><span class="line"></span><br><span class="line">什么是 <span class="string">`path`</span> 匹配？</span><br><span class="line">例如：<span class="attr">http</span>:<span class="comment">//www.xxx.com/ 下创建的 cookie 的时候加了 &#x27;path=/&#x27;,同域下的任意路径都可以访问，因为任意路径都属于&#x27;/&#x27;的子路径，又称为和&#x27;/&#x27;是匹配的。</span></span><br><span class="line">例如：<span class="attr">http</span>:<span class="comment">//www.xxx.com/a 下创建的 cookie 或者设置 cookie 的时候加了 &#x27;path=/a&#x27;,同域下和&#x27;/a&#x27;匹配的任意路径都能访问，例如&#x27;/a&#x27;、&#x27;/a/b&#x27;、&#x27;/a/c&#x27;、&#x27;/a/b/c&#x27; 等都称为是和 &#x27;/a&#x27; 匹配，或者称为是 &#x27;/a&#x27; 的子路径。除此之外&#x27;/&#x27;、&#x27;/b&#x27;、&#x27;/c&#x27;都和&#x27;/a&#x27;是不同域的</span></span><br><span class="line"></span><br><span class="line"># 存储大小不一样</span><br><span class="line"><span class="variable language_">localStorage</span>：<span class="number">4.</span>98MB(不同浏览器下会有差异，例如 <span class="title class_">Safari</span> <span class="number">2.</span>49M)。</span><br><span class="line">seesionStorage：<span class="number">4.</span>98MB</span><br><span class="line">cookie：4KB</span><br><span class="line"></span><br><span class="line"># 操作主体不一样</span><br><span class="line"><span class="variable language_">localStorage</span> / <span class="variable language_">sessionStorage</span>：只有客户端才能设置。</span><br><span class="line">cookie：客户端（<span class="variable language_">document</span>.<span class="property">cookie</span>）和服务端（<span class="title class_">Set</span>-<span class="title class_">Cookie</span>响应头）都可以设置。</span><br><span class="line"></span><br><span class="line"># 请求是否会携带</span><br><span class="line"><span class="variable language_">localStorage</span> / <span class="variable language_">sessionStorage</span>：请求时不会自动携带。</span><br><span class="line">cookie：每次请求都会随着请求头带到后端（符合同域且 path 匹配的条件）。</span><br></pre></td></tr></table></figure>
<h3 id="【JS】如何判断对象为空？"><a href="#【JS】如何判断对象为空？" class="headerlink" title="【JS】如何判断对象为空？"></a>【JS】如何判断对象为空？</h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">JSON.stringify()</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># chatGPT 回答</span><br><span class="line"># <span class="number">1.</span> 判断对象是否没有任何属性 可以使用 <span class="title class_">Object</span>.<span class="title function_">keys</span>() 方法获取对象的所有属性，然后判断属性的数量来确定对象是否为空。如果属性数量为<span class="number">0</span>，则表示对象为空。</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isObjectEmpty</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;; <span class="comment">// 空对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isObjectEmpty</span>(obj1)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;; <span class="comment">// 非空对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isObjectEmpty</span>(obj2)); <span class="comment">// false</span></span><br><span class="line">--------------------------------------------------------</span><br><span class="line"># <span class="number">2.</span> 判断对象的属性值是否全部为 <span class="literal">null</span> 或 <span class="literal">undefined</span> 通过遍历对象的所有属性值，判断它们是否为 <span class="literal">null</span> 或 <span class="literal">undefined</span>。如果所有属性值都是 <span class="literal">null</span> 或 <span class="literal">undefined</span>，则表示对象为空。</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isObjectEmpty</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj[key] !== <span class="literal">null</span> &amp;&amp; obj[key] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">name</span>: <span class="literal">null</span>, <span class="attr">age</span>: <span class="literal">undefined</span> &#125;; <span class="comment">// 空对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isObjectEmpty</span>(obj1)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;; <span class="comment">// 非空对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isObjectEmpty</span>(obj2)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>、搭配使用,判断不可</span><br><span class="line"><span class="keyword">const</span> s = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  [s]:<span class="number">28</span>,</span><br><span class="line">  <span class="attr">name</span>:<span class="number">48</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(o).<span class="title function_">concat</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(<span class="number">0</span>).<span class="property">length</span>===<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下-for-in-和-for-of-的区别？"><a href="#【JS】说一下-for-in-和-for-of-的区别？" class="headerlink" title="【JS】说一下 for in 和 for of 的区别？"></a>【JS】说一下 for in 和 for of 的区别？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">in</span> 和<span class="keyword">for</span> of区别</span><br><span class="line">相同点: 都是用于循环对象的</span><br><span class="line">不同点: </span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">in</span> 循环的是对象的key值</span><br><span class="line">	<span class="keyword">for</span> of 循环的是对象的value值</span><br><span class="line">	<span class="keyword">for</span> of是ES6新增的一个语法, 用于弥补<span class="keyword">for</span> <span class="keyword">in</span> 的不足, 所以<span class="keyword">for</span> <span class="keyword">in</span>一般用于遍历对象, <span class="keyword">for</span> of 一般用于遍历数组</span><br></pre></td></tr></table></figure>
<h3 id="【JS】说一下箭头函数和普通函数的差异？"><a href="#【JS】说一下箭头函数和普通函数的差异？" class="headerlink" title="【JS】说一下箭头函数和普通函数的差异？"></a>【JS】说一下箭头函数和普通函数的差异？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 箭头函数没有this指向</span><br><span class="line">2. 箭头函数没有构造函数</span><br><span class="line">3. 箭头函数的this指向上级作用域</span><br><span class="line">4. 使用箭头函数如果只有一个形参可以省略 小括号() , 如果在一行显示可以省略 花括号&#123;&#125;和<span class="built_in">return</span></span><br><span class="line">5. 箭头函数没有 prototype 和 arguments</span><br><span class="line">6. 在不需要使用this时可以使用箭头函数, 简化代码,看着更加美观</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">逐字稿： </span><br><span class="line">1. 箭头函数没有原型对象 prototype，不能作为构造函数使用（不能被new）。</span><br><span class="line">2. 箭头函数没有 arguments ，可以使用   ...   （...运算符）拿到所有实参的集合数组。</span><br><span class="line">3. 箭头函数的 this 在定义时就已经确定，取决于父级的环境。</span><br><span class="line">4. 箭头函数不能通过 call、apply、<span class="built_in">bind</span> 方法修改它的 this 指向（会忽略第一个参数，其他功能还是可以正常使用）</span><br><span class="line">5. 箭头函数不能用作 Generator 函数，不能使用 yeild 关键字（<span class="keyword">function</span> *） <span class="comment"># Generator语法规定函数要带 *   【function *】</span></span><br></pre></td></tr></table></figure>
<h3 id="【JS】什么是重绘和回流-重排-，如何减少？"><a href="#【JS】什么是重绘和回流-重排-，如何减少？" class="headerlink" title="【JS】什么是重绘和回流(重排)，如何减少？"></a>【JS】什么是重绘和回流(重排)，如何减少？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重绘: 当页面中的元素的属性(如背景、字体颜色、等等)发生改变,并没有影响布局时,浏览器为了节省性能 避免影响使用, 浏览器会对那个元素进行重新绘制渲染.</span><br><span class="line">回流: 当页面中元素的属性发生改变, 会影响到布局时,浏览器会重新计算属性并且重新布局, 这个过程特别消耗性能.</span><br></pre></td></tr></table></figure>
<h3 id="什么是内存泄露？"><a href="#什么是内存泄露？" class="headerlink" title="什么是内存泄露？"></a>什么是内存泄露？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 什么是内存泄露</span></span><br><span class="line">内存泄露是指程序运行是，分配的内存没有被正确的释放，导致内存空间的浪费，最终可能导致程序崩溃或运行缓慢。</span><br><span class="line"><span class="number">1</span>、在 <span class="variable language_">window</span> 上添加的监听事件，在页面卸载时要主动移除，并注意移除的正确性，绑定事件没有解绑，解绑的时候需要确定解绑的是同一个事件。</span><br><span class="line"><span class="number">2</span>、<span class="variable language_">console</span>.<span class="property">log</span> 也可能会引起内存泄露原因是，<span class="variable language_">console</span>也是引用属性也会造成内存泄露，因为一直被<span class="variable language_">console</span>引用在</span><br><span class="line"><span class="number">3</span>、弱引用 weakset、weakmap，它们对值的引用都是不计入垃圾回收机制的</span><br></pre></td></tr></table></figure>
<h3 id="JSON-parse-JSON-stringify-有哪些特点？"><a href="#JSON-parse-JSON-stringify-有哪些特点？" class="headerlink" title="JSON.parse/JSON.stringify 有哪些特点？"></a>JSON.parse/JSON.stringify 有哪些特点？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span>、对象包装的布尔值、数字、字符串，在序列化过程中，自动转换成对应的原始值</span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">8</span>),</span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(o))<span class="comment">// num: 8，直接转换成 原始数值</span></span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>、非数组对象的属性不能保证 以特定的顺序出现</span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">8</span>),</span><br><span class="line">  <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(o))<span class="comment">// 对象内部属性出现的顺序不能保证</span></span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>、<span class="title function_">toJSON</span>() 方法，该方法定义什么值将被序列化。</span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">8</span>),</span><br><span class="line">  <span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line">  <span class="title function_">toJSON</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">9</span> <span class="comment">// 当遇到toJSON时会先运行内部代码而忽略其他代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(o))</span><br><span class="line"></span><br><span class="line"># <span class="number">4</span>、<span class="literal">undefined</span>、任意的函数以及 symbol 值，在序列化过程中会被忽略</span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">fn</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,</span><br><span class="line">  <span class="attr">s</span>: <span class="title class_">Symbol</span>(),</span><br><span class="line">  <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(o))<span class="comment">//&#123;&quot;age&quot;:18&#125;，其他代码直接忽略</span></span><br><span class="line"></span><br><span class="line"># <span class="number">5</span>、对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">name</span>:<span class="string">&#x27;obj1&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; <span class="attr">name</span>:<span class="string">&#x27;obj2&#x27;</span> &#125;</span><br><span class="line">obj1.<span class="property">other</span> = obj2</span><br><span class="line">obj2.<span class="property">other</span> = obj1</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj1))</span><br><span class="line"></span><br><span class="line"># <span class="number">6</span>、<span class="title class_">NaN</span> 和 <span class="title class_">Infinity</span> 格式的数值及 <span class="literal">null</span> 都会被当做 <span class="literal">null</span>。</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">num1</span>: <span class="title class_">NaN</span> , <span class="attr">num2</span>: <span class="title class_">Infinity</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj1)) <span class="comment">// &#123;&quot;num1&quot;:null,&quot;num2&quot;:null&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><blockquote>
<p>可达性：“可达”值是那些以某种方式可访问或可用的值。它们一定是存储在内存中的。</p>
<p>内部算法：</p>
<ul>
<li>垃圾收集器找到所有的根，并“标记”（记住）它们。</li>
<li>然后它遍历并“标记”来自它们的所有引用。</li>
<li>然后它遍历标记的对象并标记 它们的 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。</li>
<li>……如此操作，直到所有可达的（从根部）引用都被访问到。</li>
<li>没有被标记的对象都会被删除。</li>
</ul>
<p>我们还可以将这个过程想象成从根溢出一大桶油漆，它流经所有引用并标记所有可到达的对象。然后移除未标记的。</p>
<p>这是垃圾收集工作的概念。JavaScript 引擎做了许多优化，使垃圾回收运行速度更快，并且不会对代码执行引入任何延迟。</p>
</blockquote>
<p>后端对垃圾回收的话一般需要做栈和堆相关的配置来配合垃圾回收机制。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h4 id="Promise静态方法"><a href="#Promise静态方法" class="headerlink" title="Promise静态方法"></a>Promise静态方法</h4><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="Vue2和Vue3有哪些不同？"><a href="#Vue2和Vue3有哪些不同？" class="headerlink" title="Vue2和Vue3有哪些不同？"></a>Vue2和Vue3有哪些不同？</h3><blockquote>
<p>体积小：删除了很多API</p>
<p>响应式：</p>
<p>​    <code>vue2</code> 的响应性主要依赖 <code>Objet.defineProperty</code> 进行实现，但是 <code>Object.defineProperty</code> 只能监听 <strong>指定对象的指定属性的 getter 行为和 setter 行为</strong>。</p>
<p>缺点：假如我们给<code>date</code>新增了一个对象 <code>person</code>，一旦给对象新增了一个属性，那么这个属性就不会是响应式的，原因就是Vue2中的<code>Objet.defineProperty</code>无法监听到我们新增的这个属性。</p>
<p>解决办法：Vue2中提供了 <code>Vue.$set</code>可以解决这个问题，但是这个方法并不合理。</p>
<p>$forceUpdate：迫使实例重新渲染，就是强制刷新。</p>
<p>​    <code>Vue3</code> 响应式原理基础是   <code>Proxy</code></p>
<p>所以Vue3中引入了<code>反射(reflect)</code>和<code>代理(Proxy)</code>的一个概览。<code>反射指的就是 Reflect</code>，<code>代理指的就是 Proxy</code>，利用Proxy直接代理一个普通对象得到Proxy实例(代理对象)，在Vue3当中这样的一个过程我们把它叫做 <code>reactive</code>方法。</p>
<p>缺点：Proxy只能代理<code>复杂数据类型</code>的响应式，所以Vue额外提供了<code>ref</code>的方法，用来处理简单数据类型的响应式，本质上没有进行数据的监听而是构建了一个叫做 Reflmpl 的类，通过set和get标记类里面的value方法，以此来实现。所以必须要使用 <code>.value</code>去触发，本质上就是在调用 value函数。</p>
</blockquote>
<h3 id="哪些方法会触发视图更新（变异方法）"><a href="#哪些方法会触发视图更新（变异方法）" class="headerlink" title="哪些方法会触发视图更新（变异方法）"></a>哪些方法会触发视图更新（变异方法）</h3><blockquote>
<p>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发<code>视图更新</code>。</p>
<ul>
<li><code>push()</code> </li>
<li><code>pop()</code> </li>
<li><code>shift()</code> </li>
<li><code>unshift()</code> </li>
<li><code>splice()</code> </li>
<li><code>sort()</code> </li>
<li><code>reverse()</code> </li>
</ul>
</blockquote>
<h3 id="SPA-单页面？说说你对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#SPA-单页面？说说你对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="SPA 单页面？说说你对 SPA 单页面的理解，它的优缺点分别是什么？"></a>SPA 单页面？说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h3><blockquote>
<p>一种特殊的web应用，他将所有的web活动仅限于一个web页面中，仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>
<p>优点：</p>
<ul>
<li><p>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染</p>
</li>
<li><p>减少不必要的开发成本</p>
</li>
<li><p>对服务压力较小</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载</li>
<li>代码量增加不利于首屏优化</li>
<li>由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能</li>
</ul>
</blockquote>
<h3 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># <span class="title class_">Vue2</span></span><br><span class="line">以下类型为  --&gt; 类型：<span class="title class_">Function</span></span><br><span class="line">-----四个阶段-八大钩子-----</span><br><span class="line">第一阶段-初始化阶段</span><br><span class="line">beforeCreate</span><br><span class="line">created</span><br><span class="line">第二阶段-渲染阶段</span><br><span class="line">beforeMount</span><br><span class="line">mounted</span><br><span class="line">第三阶段-更新阶段</span><br><span class="line">beforeUpdate</span><br><span class="line">updated</span><br><span class="line">第四阶段-卸载阶段</span><br><span class="line">beforeDestroy</span><br><span class="line"><span class="title function_">destroyed</span>(蒂斯状)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被 keep-alive 缓存的组件调用。</span></span><br><span class="line">activated -- 激活</span><br><span class="line">deactivated -- 失活</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue2新增钩子</span></span><br><span class="line">errorCaptured ---&gt; 在捕获一个来自后代组件的错误时被调用。</span><br><span class="line"></span><br><span class="line"># <span class="title class_">Vue3</span></span><br><span class="line">setup   ---&gt; 替换了 beforeCreate 和 created 比之前更快</span><br><span class="line">onBeforeMount</span><br><span class="line">onMounted</span><br><span class="line"></span><br><span class="line">onBeforeUpdate</span><br><span class="line">onUpdated</span><br><span class="line"></span><br><span class="line">onBeforeUnmount</span><br><span class="line">onUnmounted</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被 keep-alive 缓存的组件调用。</span></span><br><span class="line">onActivated</span><br><span class="line">onDeactivated</span><br><span class="line">onErrorCaptured</span><br></pre></td></tr></table></figure>
<h3 id="Vue中事件修饰符"><a href="#Vue中事件修饰符" class="headerlink" title="Vue中事件修饰符"></a>Vue中事件修饰符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">stop</span>   <span class="comment">// 阻止单击事件继续传播(就是阻止冒泡)</span></span><br><span class="line">.<span class="property">prevent</span>  <span class="comment">// 提交事件不再重载页面(就是阻止点击按钮刷新页面)</span></span><br><span class="line">.<span class="property">capture</span></span><br><span class="line">.<span class="property">self</span></span><br><span class="line">.<span class="property">once</span></span><br><span class="line">.<span class="property">passive</span></span><br><span class="line">.<span class="property">sync</span> <span class="comment">// 是使用组件时内部修改值的一种便捷写法，在Vue3中已经删除了</span></span><br></pre></td></tr></table></figure>
<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>&gt;</p>
<h3 id="Vue-自定义指令在什么时机执行？"><a href="#Vue-自定义指令在什么时机执行？" class="headerlink" title="Vue 自定义指令在什么时机执行？"></a>Vue 自定义指令在什么时机执行？</h3><blockquote>
<p>是在运行时解析并执行的</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35b9c30313d14e349c96bbe86f4c4b3c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="自定义指令"></p>
<h3 id="宿主环境"><a href="#宿主环境" class="headerlink" title="宿主环境"></a>宿主环境</h3><p>&gt;</p>
<h3 id="为什么需要虚拟DOM"><a href="#为什么需要虚拟DOM" class="headerlink" title="为什么需要虚拟DOM?"></a>为什么需要虚拟DOM?</h3><blockquote>
<p>因为真实 DOM 操作是比较昂贵的</p>
<p>如果虚拟 DOM 能提升效率，那 React Fiber 是干什么的？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">React</span> <span class="title class_">Fiber</span> 就是解决 虚拟 <span class="variable constant_">DOM</span> 效率问题的，因为 <span class="title class_">React</span> 的虚拟 <span class="variable constant_">DOM</span> 的效率问题比<span class="title class_">Vue</span>严重的多，因为<span class="title class_">Vue</span>是不怎么需要 <span class="title class_">React</span> <span class="title class_">Fiber</span> 的而 <span class="title class_">React</span> 是必须要的</span><br></pre></td></tr></table></figure>
<p>为什么 Svelte(斯喔特)(国外流行框架) 效率更高？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Svelte</span>是编译形态的，在编译的期间就可以知道这个数据对应的那个真是<span class="variable constant_">DOM</span>然后进行更新，不需要绕，所以效率很高。</span><br></pre></td></tr></table></figure>
<p>需要虚拟 DOM 的真正原因是什么？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;# <span class="number">1</span>、框架设计层面</span><br><span class="line">&gt;基于数据驱动，以数据为中心</span><br><span class="line">&gt;render 数据一变化，全量生成界面</span><br><span class="line">&gt;<span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">全量生成界面(虚拟<span class="variable constant_">DOM</span>)</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;# <span class="number">2</span>、跨平台</span><br><span class="line">&gt;浏览器真实 <span class="variable constant_">DOM</span> ，不能和真实<span class="variable constant_">DOM</span>进行绑定，所以需要虚拟<span class="variable constant_">DOM</span>就是一个普通的对象，所有的环境都认识，可以实现一套代码多端运行。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="原生JS效率更高还是框架效率更高？"><a href="#原生JS效率更高还是框架效率更高？" class="headerlink" title="原生JS效率更高还是框架效率更高？"></a>原生JS效率更高还是框架效率更高？</h3><blockquote>
<p>当然是原生的效率更高，不需要绕一大圈。</p>
</blockquote>
<h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><blockquote>
<p>防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。每次父组件数据发生变化时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p>
</blockquote>
<h3 id="在vue2中的Object-defineProperty有哪些属性？"><a href="#在vue2中的Object-defineProperty有哪些属性？" class="headerlink" title="在vue2中的Object.defineProperty有哪些属性？"></a>在vue2中的<code>Object.defineProperty</code>有哪些属性？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">enumerable</span>(俺<span class="keyword">new</span>位波): <span class="literal">true</span>, <span class="comment">// 可枚举（是否可通过for...in 或 Object.keys()进行访问）</span></span><br><span class="line"><span class="title function_">configurable</span>(扛飞各薄): <span class="literal">true</span>, <span class="comment">// 可配置（是否可使用delete删除，是否可再次设置属性）</span></span><br><span class="line"><span class="comment">// value: &#x27;&#x27;, // 任意类型的值，默认undefined</span></span><br><span class="line"><span class="comment">// writable: true, // 可重写</span></span><br><span class="line"># writable 和 value 与 getter 和 setter 不共存。</span><br><span class="line"><span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="attr">set</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【Vue】说一下你对-Vuex-的理解？"><a href="#【Vue】说一下你对-Vuex-的理解？" class="headerlink" title="【Vue】说一下你对 Vuex 的理解？"></a>【Vue】说一下你对 Vuex 的理解？</h3><p><img src="https://v3.vuex.vuejs.org/vuex.png" alt="vuex状态修改"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">是什么?</span><br><span class="line">Vue.js 官方提供的一个状态管理模式库, 用于实现组件之间的状态共享和数据流控制</span><br><span class="line">Vuex是一个全局的状态管理库</span><br><span class="line">Vuex 的核心原理是状态集中管理。Vuex 提供了一个全局的状态管理仓库，用于存储和管理应用中的所有状态，同时也提供了一系列的 API，使得组件能够方便地进行状态的读取、修改和监听。</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line">怎么用?</span><br><span class="line">核心就是一个全局的状态管理仓库，用于存储和管理应用中的所有状态</span><br><span class="line"><span class="comment"># 配置项</span></span><br><span class="line">一般使用的时候它里面有 state、mutation、action、getters、modules、plugins 等配置项</span><br><span class="line"></span><br><span class="line"><span class="comment"># 触发流程</span></span><br><span class="line">需求：例如点击按钮发请求，需要把请求的结果存储到 Vuex。</span><br><span class="line">进入视图 使用 dispatch =&gt; action 在axtion里面发送请求 并拿到数据 拿到数据之后使用 commit =&gt; mutation 存储到  state state里面数据是响应式的 一旦视图里面数据发生变化 视图当中用到这个数据自然也会发生变化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line">解决了什么问题?</span><br><span class="line">通过 Vuex，我们能够轻松地追踪应用状态的变化，管理状态的更新和响应</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line">好处是什么?</span><br><span class="line">Vuex 可以帮助我们管理应用的状态，降低组件之间的耦合度，提高开发效率</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">逐字稿: vuex是一个全局的`状态`管理js库, 解决了非关系组件之间的`数据传递`和`共享`的问题, 一般在使用的时候 里面有常见的六个配置项 state(斯德特)、mutation(幂特性)、action(哎可行)、getter(给得)、module(猫丢)、plugins（猫丢斯） 等配置项</span><br><span class="line"></span><br><span class="line">在使用期间 组件关系比较 清晰/明确 的情况下，会使用其他的方案去传递和共享，会使用 props（普软普斯）、ref、EventBus（伊文特八十）、Provide（普外的） 等方法。</span><br><span class="line">-----------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="string">&#x27;衍生问题&#x27;</span></span><br><span class="line"><span class="comment"># mutation 里面为什么建议只写同步代码去修改 state？写异步会怎样？</span></span><br><span class="line">如果在 mutation 中写异步代码去修改 state，可能会导致状态更新缺乏可追溯性。如果在 mutation 中使用异步代码，那么对于其他开发人员来说，很难确定哪些函数在哪个时间点对 state 进行了更改，因为异步操作的执行时间是不确定的。</span><br><span class="line"></span><br><span class="line">可能会造成状态不一致的问题。如果在 mutation 中使用异步操作，例如执行一个异步请求，那么在异步请求返回之前，可能已经有其他函数对 state 进行了修改，而这些修改是基于异步请求之前的状态的，这样就可能导致状态不一致的问题。</span><br></pre></td></tr></table></figure>
<h3 id="【Vue】v-for-和-v-if-为什么不建议放一行？"><a href="#【Vue】v-for-和-v-if-为什么不建议放一行？" class="headerlink" title="【Vue】v-for 和 v-if 为什么不建议放一行？"></a>【Vue】v-for 和 v-if 为什么不建议放一行？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在 Vue 模板中， v-for 和 v-if 不建议同时放在同一个元素上，这是因为它们会影响彼此的行为。`v-for 会优先渲染整个列表`，而`v-if 会根据条件过滤列表`。如果两者放在同一个标签上，<span class="string">&#x27;那么v-if 可能会影响 v-for 的性能表现，导致它的更新速度变慢&#x27;</span>。</span><br><span class="line"></span><br><span class="line">当应用中数据变化较频繁时，v-if 可能会多次检查条件是否满足，而v-for 在每次循环中都会重新渲染列表。将它们放在同一行可能会对应用程序的性能产生负面影响。</span><br><span class="line">另外，将 v-for 和 v-if 分别放在不同的元素上，还可以更清晰地表达模板的意图，提高代码的可读性和可维护性。</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">解决了什么问题?</span><br><span class="line">将 v-for 和 v-if 分别放置在不同的元素上，可以提高代码的可读性和可维护性。另外，还可以提高应用程序的性能表现，避免因为v-if 检查条件的频繁调用而对 v-for 循环的性能产生负面影响</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">Vue2</span><br><span class="line">因为Vue2中 v-for 的优先级比 v-if 高，Vue会先循环出所有的元素，再把不符合条件的销毁，多了一些没必要的创建和销毁的操作，性能浪费。</span><br><span class="line">Vue3</span><br><span class="line">Vue3中 v-if 和 v-for 的优先级高，更不能放一行了，因为往往 v-if 判断的时候需要依赖循环项进行，那这个时候循环项还没有呢，所有会直接报错。</span><br><span class="line">解决方式：通过计算属性，先计算出需要循环的那些元素就好啦。</span><br></pre></td></tr></table></figure>
<h3 id="【Vue】Vue-响应式四连问？"><a href="#【Vue】Vue-响应式四连问？" class="headerlink" title="【Vue】Vue 响应式四连问？"></a>【Vue】Vue 响应式四连问？</h3><blockquote>
<h4 id="Vue2哪些情况操作数据不是响应式的？"><a href="#Vue2哪些情况操作数据不是响应式的？" class="headerlink" title="Vue2哪些情况操作数据不是响应式的？"></a>Vue2哪些情况操作数据不是响应式的？</h4><p>常见的有如下 3 种情况</p>
<p>1、给对象后续新增的 key 进行赋值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">obj</span>:&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">obj</span>.<span class="property">age</span> = <span class="number">18</span> <span class="comment">// 原先没有 age 这里添加了 age 不是响应式</span></span><br></pre></td></tr></table></figure>
<p>2、删除对象中的某一项</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">obj</span>:&#123;</span><br><span class="line">      <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">obj</span>.<span class="property">age</span> <span class="comment">// 也不是响应式的</span></span><br></pre></td></tr></table></figure>
<p>3、通过索引去修改数组的元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">   	<span class="attr">arr</span>:[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">arr</span>[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="为什么这些情况不是响应式的？"><a href="#为什么这些情况不是响应式的？" class="headerlink" title="为什么这些情况不是响应式的？"></a>为什么这些情况不是响应式的？</h4><p>1、给对象后续新增的 key 进行赋值</p>
<p>原因：因为 Object.defineProperty 是递归劫持的对象中的每一个<code>属性</code>，如果这个属性是后续被添加的，当然就没有被劫持到。</p>
<p>2、删除对象中的某一项</p>
<p>原因：Object.defineProperty 不支持对删除操作的劫持</p>
<p>3、通过索引去修改数组的元素</p>
<p>原因：并不是 Object.defineProperty 不支持对数组的劫持，而是作者    <code>性能代价和获得的用户体验收益不成正比</code></p>
<h4 id="怎么解决？"><a href="#怎么解决？" class="headerlink" title="怎么解决？"></a>怎么解决？</h4><p>1、给对象后续新增的 key 进行赋值</p>
<p>解决：Vue.set 或 this.$set</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">obj</span>:&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">obj</span>.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(<span class="variable language_">this</span>.<span class="property">obj</span>,<span class="string">&#x27;age&#x27;</span>,<span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>2、删除对象中的某一项</p>
<p>解决：Vue.delete 或 this.$delete</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">delete</span>(<span class="variable language_">this</span>.<span class="property">obj</span>,<span class="string">&#x27;age&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>3、通过索引去修改数组的元素</p>
<p>解决：Vue.set 或 this.$set 或 arr.splice</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(<span class="variable language_">this</span>.<span class="property">arr</span>,<span class="number">0</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;d&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Vue3呢"><a href="#Vue3呢" class="headerlink" title="Vue3呢?"></a>Vue3呢?</h4><p>Vue不存在上述问题了。</p>
<p>1、给对象后续新增的 key 进行赋值</p>
<p>​    Vue3响应式的原理换成了 Proxy，可以直接代理整个<code>对象</code>，就无所谓这个属性是不是后续添加的了。</p>
<p>2、删除对象中的某一项</p>
<p>​    Proxy 支持对删除操作的拦截</p>
<p>3、通过索引去修改数组的元素</p>
<p>​    Proxy 对数组的操作不存在性能问题</p>
</blockquote>
<h3 id="【Vue】hash-和-history-模式的差异是什么？router路由的工作模式？"><a href="#【Vue】hash-和-history-模式的差异是什么？router路由的工作模式？" class="headerlink" title="【Vue】hash 和 history 模式的差异是什么？router路由的工作模式？"></a>【Vue】hash 和 history 模式的差异是什么？router路由的工作模式？</h3><p>两者都是用来实现前端路由的（前端路由就是页面地址和组件之间的对应关系）</p>
<h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><blockquote>
<p>hash 兼容 IE8，history 兼容 IE10</p>
</blockquote>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><blockquote>
<p>hash 模式是通过监听 onhashchange 事件做得处理</p>
<p>history 模式是利用 H5 新增的 History 相关的 API 实现的，例如 onpopstate 事件、pushState、replaceState等方法。</p>
</blockquote>
<h4 id="刷新页面时，对于后端的表现"><a href="#刷新页面时，对于后端的表现" class="headerlink" title="刷新页面时，对于后端的表现"></a>刷新页面时，对于后端的表现</h4><blockquote>
<p>hash</p>
<p>刷新页面时，hash 地址也就是（也就是 # 号后面的内容），不会作为资源发送到服务端，后端拿到的都是 <code>/</code> 这个请求地址，他只需要返回<code>index.html</code>页面就好了</p>
<p>history</p>
<p>刷新页面时，htstory 地址对于服务端来说是一个新的请求，后端拿到的是不同的请求地址，也就意味着需要服务端对这些请求做处理否则会404</p>
<p>做什么处理？</p>
<p>匹配到路由相关的 GET 请求后，统一返回 <code>index.html</code>，<code>index.tml</code>加载的有路由相关的代码，所以也就转换为由前端路由来处理。</p>
</blockquote>
<h3 id="【Vue】父传子都有哪些方法？父传子都有哪些方法，注意点是什么？"><a href="#【Vue】父传子都有哪些方法？父传子都有哪些方法，注意点是什么？" class="headerlink" title="【Vue】父传子都有哪些方法？父传子都有哪些方法，注意点是什么？"></a>【Vue】父传子都有哪些方法？父传子都有哪些方法，注意点是什么？</h3><blockquote>
<p>1、父亲通过自定义属性传递，儿子通过 props 接收。</p>
<p>2、父组件通过 $refs API 配合 ref 属性来获取子组件实例，获取子组件实例后调用它的方法的同时并传参。</p>
<p>3、父组件通过 $children 获取子组件实例，Vue3 废弃了。</p>
<p>4、父组件通过自定义属性传递，子组件通过 $attrs 接收，如果子组件没有通过 props 接收则一定会存放在 attrs 里面。</p>
</blockquote>
<h4 id="1、父亲通过自定义属性传递，儿子通过-props-接收"><a href="#1、父亲通过自定义属性传递，儿子通过-props-接收" class="headerlink" title="1、父亲通过自定义属性传递，儿子通过 props 接收"></a>1、父亲通过自定义属性传递，儿子通过 props 接收</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 父</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  	Parent</span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">Child</span> <span class="attr">:自定义属性</span>=<span class="string">&quot;需要传递的参数&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>:<span class="string">&#x27;ParentCmp&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">Child</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">age</span>:<span class="number">18</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"># 子</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Child&#123;&#123;age&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>:<span class="string">&#x27;Child&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    自定义属性:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">type</span>:<span class="title class_">Number</span>(定义接收类型),</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">default</span>:<span class="number">17</span> <span class="comment">// 定义默认值</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="2、父组件通过-refs-API-配合-ref-属性来获取子组件实例，获取子组件实例后调用它的方法的同时并传参。"><a href="#2、父组件通过-refs-API-配合-ref-属性来获取子组件实例，获取子组件实例后调用它的方法的同时并传参。" class="headerlink" title="2、父组件通过 $refs API 配合 ref 属性来获取子组件实例，获取子组件实例后调用它的方法的同时并传参。"></a>2、父组件通过 $refs API 配合 ref 属性来获取子组件实例，获取子组件实例后调用它的方法的同时并传参。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 父</span><br><span class="line">&lt;button @click=<span class="string">&quot;handleClick&quot;</span>&gt;传递 age 给子组件&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">ref</span>=<span class="string">&quot;childRef&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">	<span class="title function_">handleClick</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">childRef</span>.<span class="title function_">changAge</span>(<span class="number">18</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"># 子</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">    <span class="attr">age</span>:<span class="number">17</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">  <span class="title function_">changAge</span>(<span class="params">age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、父组件通过-children-获取子组件实例"><a href="#3、父组件通过-children-获取子组件实例" class="headerlink" title="3、父组件通过 $children 获取子组件实例"></a>3、父组件通过 $children 获取子组件实例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 父</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$children</span>[<span class="number">0</span>].<span class="title function_">changeAge</span>(<span class="variable language_">this</span>.<span class="property">age</span>)</span><br></pre></td></tr></table></figure>
<h4 id="4、父组件通过自定义属性传递，子组件通过-attrs-接收"><a href="#4、父组件通过自定义属性传递，子组件通过-attrs-接收" class="headerlink" title="4、父组件通过自定义属性传递，子组件通过 $attrs 接收"></a>4、父组件通过自定义属性传递，子组件通过 $attrs 接收</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 父</span><br><span class="line">&lt;<span class="title class_">Child</span> :age=<span class="string">&quot;age&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"># 子</span><br><span class="line">&lt;div&gt;<span class="title class_">Child</span>：&#123;&#123;$attrs.<span class="property">age</span>&#125;&#125;&#123;&#123;$attrs.<span class="property">name</span>&#125;&#125;&lt;/div&gt;</span><br><span class="line"><span class="title function_">created</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// $attrs 是非 props 属性，类似于捡漏,props没有接收的都被它接收了</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$attrs</span>) <span class="comment">// &#123;age：18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Vue3组件通信"><a href="#Vue3组件通信" class="headerlink" title="Vue3组件通信"></a>Vue3组件通信</h3><blockquote>
<p>1、父亲通过自定义属性传递，儿子通过 defineProps 接收</p>
<p>2、v-model 是 <code>@update:modelValue</code>和<code>:modelValue</code> 的语法糖</p>
<p>3、父亲通过自定义属性传递，儿子通过 $attrs 接收</p>
<p>4、父亲通过 ref 获取子组件实例</p>
<p>5、使用插槽 <slot /></p>
</blockquote>
<h3 id="父传子传过来的数据可以被修改吗？"><a href="#父传子传过来的数据可以被修改吗？" class="headerlink" title="父传子传过来的数据可以被修改吗？"></a>父传子传过来的数据可以被修改吗？</h3><blockquote>
<p>简单数据类型</p>
<p>​    1、简单数据类型，一定不能改（数据不同步）。</p>
<p>​    2、不符合单向数据流的思想，如果是大型项目或复杂项目，则会导致代码变得的不可控。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;# 数据不同步</span><br><span class="line">&gt;子组件修改父组件传递过来的数据，子组件数据发生变化了，但是父组件没有发生变化，并且控制台报错</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="v-model-和-sync-修饰符异同？"><a href="#v-model-和-sync-修饰符异同？" class="headerlink" title="v-model 和 .sync 修饰符异同？"></a>v-model 和 .sync 修饰符异同？</h3><blockquote>
<p>同：都是父传子，子在改传递过来的数据的一种便捷写法（语法糖）。</p>
<p>异：v-model 只能写一次，.sync修饰符可以写任意多次。</p>
<p>v-model就是 :value和@input 的语法糖</p>
<p>.sync就是 <code>update:XXX</code></p>
<p>Vue3中</p>
<p>v-model就是 :modelVlaue和@update的语法糖</p>
</blockquote>
<h3 id="v-model-传递过来的-value-和-input-怎么修改"><a href="#v-model-传递过来的-value-和-input-怎么修改" class="headerlink" title="v-model 传递过来的 value 和 input 怎么修改"></a>v-model 传递过来的 value 和 input 怎么修改</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">model</span>: &#123;</span><br><span class="line">  <span class="attr">prop</span>: <span class="string">&#x27;修改后的 value 属性&#x27;</span>,</span><br><span class="line">  <span class="attr">event</span>: <span class="string">&#x27;修改后的 input 属性&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【Vue】子传父都有哪些方法？"><a href="#【Vue】子传父都有哪些方法？" class="headerlink" title="【Vue】子传父都有哪些方法？"></a>【Vue】子传父都有哪些方法？</h3><blockquote>
<p>1、this.$emit(‘方法名’，传递的参数) // 子组件向父组件传值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 子</span><br><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;changeValue&#x27;</span>,<span class="number">2</span>)</span><br><span class="line"># 父</span><br><span class="line">&lt;子组件 @changeValue=<span class="string">&quot;value += $event&quot;</span>&gt;&lt;/子组件&gt;</span><br></pre></td></tr></table></figure>
<p>2、儿子也可以通过 $parent 拿到父组件的实例，然后调用父组件实例下方法的同时并传参，父组件在自身的方法中根据传递过来的参数修改自身组件的内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$parent</span>.父组件方法名  <span class="comment">// 子组件获取父组件所有方法和属性，前提条件：父组件在应用子组件的时候，位置不能随意放，例如不能放在element UI组件的插槽里, 通常要放在根元素div里</span></span><br></pre></td></tr></table></figure>
<p>3、父组件可以给儿子传递一个属性，只不过这个属性值是一个方法，儿子通过 props 接收这个属性，这个属性对应的就是父组件的方法，然后再调用属性/方法的同时并传参，父组件在自身的方法中根据传递过来的参数修改自身组件的内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 父</span><br><span class="line">&lt;子组件 :方法=<span class="string">&quot;方法&quot;</span>/&gt; <span class="comment">// 父组件将自己的方法传递给子组件</span></span><br><span class="line"></span><br><span class="line"># 子</span><br><span class="line"><span class="attr">defineProps</span>:&#123;</span><br><span class="line">  方法: <span class="function">()=&gt;</span>&#123;&#125;  <span class="comment">// 子组件接收这个方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者子组件也可以通过 $attrs 接收这个父组件方法</span></span><br></pre></td></tr></table></figure>
<p>4、Vue2 有个 $listeners 其实也是可以的（Vue3 废弃了），它可以拿到组件上绑定的自定义事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 父组件.<span class="property">vue</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeCount</span> = (<span class="params">num: number</span>) =&gt; &#123;</span><br><span class="line">  count.<span class="property">value</span> += num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">Child</span> @changeCount=<span class="string">&quot;changeCount&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"># 子组件.<span class="property">vue</span></span><br><span class="line">$listeners.<span class="title function_">changeCount</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="【Vue】说一下-Vue-中的兄弟组件通信？"><a href="#【Vue】说一下-Vue-中的兄弟组件通信？" class="headerlink" title="【Vue】说一下 Vue 中的兄弟组件通信？"></a>【Vue】说一下 Vue 中的兄弟组件通信？</h3><h4 id="1、状态提升"><a href="#1、状态提升" class="headerlink" title="1、状态提升"></a>1、状态提升</h4><blockquote>
<p>把需要操作的数据提升或传入到公共的父组件，转换成父子关系后，在传递给对应组件，对应组件接收在使用。</p>
<p>相当于把需要操作的数据传递给父组件操作，父组件专门负责传递和处理数据，这种方式会产生父子组件关系。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;# 子组件A</span><br><span class="line">&gt;子组件A通过 <span class="string">&#x27;$emit&#x27;</span> 将数据传递给父组件</span><br><span class="line">&gt;<span class="variable language_">this</span>.$emit(<span class="string">&#x27;change&#x27;</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">&gt;# 父组件</span><br><span class="line">&gt;<span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">1</span>)</span><br><span class="line">&gt;&lt;子组件A @change=<span class="string">&quot;count += $event&quot;</span>/&gt;</span><br><span class="line">&gt;&lt;子组件B :count=<span class="string">&quot;count&quot;</span>&gt;</span><br><span class="line"> </span><br><span class="line">&gt;# 子组件B</span><br><span class="line">&gt;接收数据</span><br><span class="line">&gt;defineProps&lt;&#123;</span><br><span class="line"> <span class="attr">count</span>:number</span><br><span class="line">&gt;&#125;&gt;()</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2、Event-Bus"><a href="#2、Event-Bus" class="headerlink" title="2、Event Bus"></a>2、Event Bus</h4><blockquote>
<p>Vue3移除了自带的 Event Bus，可以自己实现或使用官方<a href="https://gitee.com/link?target=https%3A%2F%2Fv3-migration.vuejs.org%2Fbreaking-changes%2Fevents-api.html%23event-bus">推荐的库</a>。</p>
<p>利用发布订阅的设计模式，一个组件通过 emit触发自定义事件并传值，另一个组件通过on 监听被触发自定义事件并接收数据。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 发布订阅模式，一个组件通过 $emit 触发自定义事件并传值，另外一个组件通过 $on 监听这个事件同时并接收数据，内部执行对应代码</span><br><span class="line">好处：不会局限于兄弟组件通信，任意两个组件通信都可以用这种方式实现。</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  $on(type, handler) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>[type] ? <span class="variable language_">this</span>.<span class="property">subs</span>[type].<span class="title function_">push</span>(handler) : (<span class="variable language_">this</span>.<span class="property">subs</span>[type] = [handler])</span><br><span class="line">  &#125;</span><br><span class="line">  $emit(type, ...args) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>[type].<span class="title function_">forEach</span>(<span class="function">(<span class="params">handler</span>) =&gt;</span> <span class="title function_">handler</span>(...args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么-nextTick-中就能拿到-DOM-更新后的数据？"><a href="#为什么-nextTick-中就能拿到-DOM-更新后的数据？" class="headerlink" title="为什么 nextTick 中就能拿到 DOM 更新后的数据？"></a>为什么 nextTick 中就能拿到 DOM 更新后的数据？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="【Vue】Vue-nextTick-和-eventLoop？"><a href="#【Vue】Vue-nextTick-和-eventLoop？" class="headerlink" title="【Vue】Vue nextTick 和 eventLoop？"></a>【Vue】Vue nextTick 和 eventLoop？</h3><h3 id="【Vue】你会在哪个钩子里面发请求为什么？"><a href="#【Vue】你会在哪个钩子里面发请求为什么？" class="headerlink" title="【Vue】你会在哪个钩子里面发请求为什么？"></a>【Vue】你会在哪个钩子里面发请求为什么？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">发请求的时机肯定是越早越好，那么 beforeCreate 最早，但是有的时候需要依赖 data里面的数据或调用 methods 里面的方法(请求后也可能需要)，而 data 和 methods 都是需要实例创建完成后才具有的，所以一般我会在 created 里面发送请求</span><br><span class="line"></span><br><span class="line">如果说需要依赖 <span class="variable constant_">DOM</span> 相关操作的话，我会选择在 mounted 里面进行，因为 mounted 阶段才能保证页面已经渲染完毕了，可以操作<span class="variable constant_">DOM</span></span><br></pre></td></tr></table></figure>
<h3 id="【Vue】如何监听组件某个生命周期钩子的触发？如何监听子组件生命周期的某个阶段，父组件做一些相关操作？"><a href="#【Vue】如何监听组件某个生命周期钩子的触发？如何监听子组件生命周期的某个阶段，父组件做一些相关操作？" class="headerlink" title="【Vue】如何监听组件某个生命周期钩子的触发？如何监听子组件生命周期的某个阶段，父组件做一些相关操作？"></a>【Vue】如何监听组件某个生命周期钩子的触发？如何监听子组件生命周期的某个阶段，父组件做一些相关操作？</h3><h4 id="方法1：借助自定义事件"><a href="#方法1：借助自定义事件" class="headerlink" title="方法1：借助自定义事件"></a>方法1：借助自定义事件</h4><blockquote>
<p>父组件通过自定义事件，绑定某个回调函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 子组件</span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">	<span class="title function_">emits</span>(<span class="string">&#x27;logHello&#x27;</span>) <span class="comment">// 触发父组件自定义事件</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"># 父组件</span><br><span class="line">&lt;子组件 @logHello=<span class="string">&quot;logHello&quot;</span>/&gt;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> <span class="title function_">logHello</span> = (<span class="params"></span>)=&gt;&#123; <span class="comment">// 触发事件</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="方式二：通过-vnode-直接进行监听"><a href="#方式二：通过-vnode-直接进行监听" class="headerlink" title="方式二：通过 @vnode- 直接进行监听"></a>方式二：通过 @vnode- 直接进行监听</h4><blockquote>
<p>Vue2语法：@hook:updated，事件名和相应的生命周期钩子一致，并带有 <code>hook:</code> 前缀</p>
<p>Vue3语法：原<code>@vnode-</code>，官方修改成了，<code>@vue:updated</code>，事件名附带的是 <code>vue:</code> 前缀</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># <span class="title class_">Vue</span>自带的 @vnode-生命周期钩子</span><br><span class="line"># 父</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">logHello</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&lt;子组件 @vnode-mounted=<span class="string">&quot;logHello&quot;</span>/&gt;</span><br><span class="line">  </span><br><span class="line"># 子</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<h3 id="【Vue】说一下-computed-和-methods-及-watch-之间的差异？"><a href="#【Vue】说一下-computed-和-methods-及-watch-之间的差异？" class="headerlink" title="【Vue】说一下 computed 和 methods 及 watch 之间的差异？"></a>【Vue】说一下 computed 和 methods 及 watch 之间的差异？</h3><blockquote>
<p>computed：基于依赖(data中的数据)进行<code>缓存</code>，会产生一个新的数据，一般内部不会写异步代码。</p>
<p>methods：也可以基于依赖产生一个新的数据，但<code>不具有缓存</code>。</p>
<p>watch：和上面两者的区别是应用场景会不一样，它一般是用来监听 data 中某一个数据的变化做一些副作用相关的操作，例如没请求</p>
<p>watch 也可以监听路由，有的时候可以利用这种写法来解决路由缓存问题。</p>
</blockquote>
<h3 id="【Vue】说一下你对-Vue3-的理解？"><a href="#【Vue】说一下你对-Vue3-的理解？" class="headerlink" title="【Vue】说一下你对 Vue3 的理解？"></a>【Vue】说一下你对 Vue3 的理解？</h3><blockquote>
<p>性能更高了：</p>
<ul>
<li>响应式原理换成了 Proxy。</li>
<li>VNode Diff算法进行了优化，PatchFlag静态标记。</li>
<li>hoistStatic静态提升。</li>
<li>cacheHandlers 事件侦听器缓存。</li>
</ul>
<p>体积更小了</p>
<ul>
<li>删除了一些没必要或不常用到的 API，例如 filter(过滤器)、EventBus(发布订阅) 等。</li>
<li>按需导入，能配合 Webpack 支持 Tree Shaking。</li>
<li>…</li>
</ul>
<p>对TS支持更好了<br>源码就是 TS 重写的。</p>
<p>Composition API</p>
<p>对大型项目更利于代码的组织和复用。</p>
<p>新特性</p>
<p>Fragment：不必只有一个根节点，减少了标签嵌套，减少了内存的使用</p>
<p>Teleport：将DOM结构转移到特定的节点里面或下面，方便管理结构</p>
<p>Suspense：….</p>
</blockquote>
<h3 id="【Vue】v-show-和-v-if-的异同？"><a href="#【Vue】v-show-和-v-if-的异同？" class="headerlink" title="【Vue】v-show 和 v-if 的异同？"></a>【Vue】v-show 和 v-if 的异同？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">相同：</span><br><span class="line">	两种都是用来控制元素可见不可见的</span><br><span class="line"></span><br><span class="line">不同：</span><br><span class="line">	v-<span class="keyword">if</span>是通过 <span class="variable constant_">JS</span> 来控制的<span class="string">&#x27;创建和销毁&#x27;</span>,v-show是通过 <span class="variable constant_">CSS</span> 来控制元素的<span class="string">&#x27;显示和隐藏&#x27;</span></span><br><span class="line">	v-show：<span class="attr">display</span>: <span class="string">&#x27;none&#x27;</span> || <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">	v-<span class="keyword">if</span>：通过判断来进行渲染</span><br><span class="line"></span><br><span class="line">	v-<span class="keyword">if</span>有较高的切换开销</span><br><span class="line">	v-show有较高的初始渲染开销。</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">	一般需要频繁切换的元素建议 v-show ，需要多个分支条件处理的元素使用 v-<span class="keyword">if</span> 比较合适。</span><br></pre></td></tr></table></figure>
<h3 id="【Vue】说一下-Vue-有哪些内置组件，分别是什么意思？"><a href="#【Vue】说一下-Vue-有哪些内置组件，分别是什么意思？" class="headerlink" title="【Vue】说一下 Vue 有哪些内置组件，分别是什么意思？"></a>【Vue】说一下 Vue 有哪些内置组件，分别是什么意思？</h3><h3 id="【Vue】Vue-父子组件嵌套的话，生命周期顺序是什么？"><a href="#【Vue】Vue-父子组件嵌套的话，生命周期顺序是什么？" class="headerlink" title="【Vue】Vue 父子组件嵌套的话，生命周期顺序是什么？"></a>【Vue】Vue 父子组件嵌套的话，生命周期顺序是什么？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 加载渲染过程</span><br><span class="line">父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</span><br><span class="line"></span><br><span class="line"># 更新过程</span><br><span class="line">父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</span><br><span class="line"></span><br><span class="line"># 销毁过程</span><br><span class="line">父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</span><br><span class="line"></span><br><span class="line"># 常见钩子顺序</span><br><span class="line">父create-&gt;子created-&gt;子mounted-&gt;父mounted</span><br></pre></td></tr></table></figure>
<h3 id="【Vue】和-Vue-相关性能优化的手段你了解哪些？"><a href="#【Vue】和-Vue-相关性能优化的手段你了解哪些？" class="headerlink" title="【Vue】和 Vue 相关性能优化的手段你了解哪些？"></a>【Vue】和 Vue 相关性能优化的手段你了解哪些？</h3><h3 id="【Vue】和Vue相关的性能优化的手段有哪些？"><a href="#【Vue】和Vue相关的性能优化的手段有哪些？" class="headerlink" title="【Vue】和Vue相关的性能优化的手段有哪些？"></a>【Vue】和Vue相关的性能优化的手段有哪些？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># v-if 和 v-show 区分使用场景</span></span><br><span class="line">当需要频繁切换元素的可见性时，使用v-show会更具性能优势，但如果元素不经常切换可见性，则应该使用v-if。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 路由懒加载</span></span><br><span class="line">当页面中存在大量图片时，可以使用懒加载的方式，将页面中的图片延迟加载，减少初始渲染时的性能开销</span><br><span class="line"></span><br><span class="line"><span class="comment"># v-for 和 key</span></span><br><span class="line">在使用v-for渲染列表时，为每个元素添加一个唯一的key，可以帮助Vue跟踪元素的状态，减少不必要的DOM操作</span><br><span class="line"></span><br><span class="line"><span class="comment"># v-for 和 v-if 不建议放一行</span></span><br><span class="line">Vue2中 ： v-for优先级高于v-if.  尽量避免v-for与v-if一起使用。  因为每一次执行v-for的时候， v-if也会被执行一次，浪费性能</span><br><span class="line"></span><br><span class="line"><span class="comment"># 区分 计算属性 和 侦听器 （方法）的使用场景</span></span><br><span class="line">计算属性 和 监听器 可以通过缓存结果或异步计算来提升性能，从而帮助应用程序更快地响应用户操作。</span><br><span class="line"></span><br><span class="line"><span class="comment"># keep-alive缓存组件</span></span><br><span class="line">使用keep-alive可以缓存已经渲染过的组件，当组件被切换时，可以直接从缓存中读取，减少不必要的性能开销</span><br></pre></td></tr></table></figure>
<h3 id="watch监听时遇到的问题"><a href="#watch监听时遇到的问题" class="headerlink" title="watch监听时遇到的问题"></a>watch监听时遇到的问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视图更新，但是监听器内部代码并没有运行，说明监听对象并没有被监听到</span></span><br><span class="line">&lt;script setup lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">ref</span>(&#123;</span><br><span class="line">  <span class="attr">eat</span>: <span class="string">&#x27;西瓜&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">watch</span>(obj, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue)</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; obj.eat &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;obj.eat = &#x27;面条&#x27;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>改成面条<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 解决方式 <span class="number">1</span>：修改第一层</span><br><span class="line"><span class="comment">// 因为 watch 对 ref 数据的监听默认是 浅监听 ， 既然是浅监听，那可以直接修改第一层就好啦，也就是 obj.value。</span></span><br><span class="line"><span class="comment">// 这里的第一层 就是被监听对象自己，自己就是第一层，内部值则是第二层，需要开启深度监听才可以监听到内部代码或值。</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;obj = &#123;eat:&#x27;面条&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>改成面条<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 解决方式 <span class="number">2</span>:开启深度监听</span><br><span class="line"><span class="title function_">watch</span>(obj, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue)</span><br><span class="line">&#125;,&#123;</span><br><span class="line">  <span class="attr">deep</span>:<span class="literal">true</span>   <span class="comment">// 开启深度监听，可以监听到被监听对象内部代码或值</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 解决方式 <span class="number">3</span>: obj.<span class="property">value</span>强制开启深度监听</span><br><span class="line"><span class="comment">// ref 的 value 是一个 reactive 类型的， obj.value 是一个 reactive 数据，而 reactive 数据是强制开启深度监听的，并且不能修改。</span></span><br><span class="line"><span class="comment">// 判断这个对象的 value 值是不是一个 reavtive 类型的，因为 ref 内部还是借助 reactive 来执行的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(obj.<span class="property">value</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(obj.<span class="property">value</span>, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意点：直接监听 reactive ，对 reactive 本身的修改是不会触发监听的。</span></span><br><span class="line">&lt;button @click=<span class="string">&quot;obj=&#123;eat: &#x27;面条&#x27;&#125;&quot;</span>&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">code</span>&gt;</span>不会打印<span class="tag">&lt;/<span class="name">code</span>&gt;</span></span>&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 解决方式 <span class="number">4</span>：watch指定函数，返回ref</span><br><span class="line"><span class="comment">// 视图和数据发生变化，但是任何情况下都不会触发监听，除非开启 &#123;deep:true&#125;</span></span><br><span class="line">&lt;script setup lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">ref</span>(&#123;</span><br><span class="line">  <span class="attr">eat</span>: <span class="string">&#x27;西瓜&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ()=&gt;obj 把监听对象转为普通类型,丢失响应式</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>obj, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue)</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; obj.eat &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;obj.eat = &#x27;面条&#x27;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>面条<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;obj=&#123;eat:&#x27;馒头&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>馒头<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 解决方式 <span class="number">5</span>： watch指定函数, 返回 reactive (ref中的对象)</span><br><span class="line"><span class="comment">// 对这个 reactive 本身的修改会触发监听，但是对内部数据的修改则不会触发监听，开启 &#123;deep:true&#125; 后，对着两种情况都会触发监听。</span></span><br><span class="line">&lt;script setup lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">ref</span>(&#123;</span><br><span class="line">  <span class="attr">eat</span>: <span class="string">&#x27;西瓜&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改本身触发*/</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>obj.<span class="property">value</span>, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 都会触发 </span></span><br><span class="line"><span class="comment">watch(()=&gt;obj.value, (newValue) =&gt; &#123;</span></span><br><span class="line"><span class="comment">  console.log(newValue)</span></span><br><span class="line"><span class="comment">&#125;,&#123;</span></span><br><span class="line"><span class="comment">  deep:true</span></span><br><span class="line"><span class="comment">&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; obj.eat &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;obj.eat = &#x27;面条&#x27;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>面条<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;obj=&#123;eat:&#x27;馒头&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>馒头<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 解决方式 <span class="number">6</span>：watch指定函数，返回普通值</span><br><span class="line"><span class="comment">// 任何影响到此值的修改并且是响应式的，都会触发监听。</span></span><br><span class="line">&lt;script setup lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">ref</span>(&#123;</span><br><span class="line">  <span class="attr">eat</span>: <span class="string">&#x27;西瓜&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>obj.<span class="property">value</span>.<span class="property">eat</span>, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue)   <span class="comment">// 打印的是新值</span></span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; obj.eat &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;obj.eat = &#x27;面条&#x27;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>面条<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;obj=&#123;eat:&#x27;馒头&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>馒头<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Vue中哪些方法不会改变原数组"><a href="#Vue中哪些方法不会改变原数组" class="headerlink" title="Vue中哪些方法不会改变原数组?"></a>Vue中哪些方法不会改变原数组?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">是什么?</span><br><span class="line">push</span><br><span class="line">pop</span><br><span class="line">shift</span><br><span class="line">unshift</span><br><span class="line"></span><br><span class="line">怎么用?</span><br><span class="line">解决了什么问题?</span><br><span class="line">有没有替代方案?</span><br><span class="line">好处是什么?</span><br><span class="line">场景是什么?</span><br><span class="line">原理是什么?</span><br></pre></td></tr></table></figure>
<h3 id="数据变化视图不更新？"><a href="#数据变化视图不更新？" class="headerlink" title="数据变化视图不更新？"></a>数据变化视图不更新？</h3><h3 id="常见的数据处理"><a href="#常见的数据处理" class="headerlink" title="常见的数据处理"></a>常见的数据处理</h3><p>处理后端返回的数据或把数据处理成后端想要的格式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 问题<span class="number">1</span></span><br><span class="line"><span class="comment">// 考察 1：用内置方法实现。</span></span><br><span class="line"><span class="comment">// 考察 2：自己模拟这些内置方法实现（flat、reduce、unique、sort...）</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">8</span>,<span class="number">1</span>,[<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>],<span class="number">2</span>,<span class="number">2</span>,[<span class="number">6</span>],<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,[<span class="number">4</span>,<span class="number">3</span>,[<span class="number">5</span>,<span class="number">4</span>],<span class="number">7</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> r = arr.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r)</span><br></pre></td></tr></table></figure>
<h3 id="vue-导出文件为pdf格式"><a href="#vue-导出文件为pdf格式" class="headerlink" title="vue 导出文件为pdf格式"></a>vue 导出文件为pdf格式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">推荐包 ---&gt; vue-to-pdf</span><br></pre></td></tr></table></figure>
<h3 id="new-Vue-的过程？发生了什么事情？"><a href="#new-Vue-的过程？发生了什么事情？" class="headerlink" title="new Vue 的过程？发生了什么事情？"></a>new Vue 的过程？发生了什么事情？</h3><blockquote>
<p><code>new Vue(&#123;传递一个对象)</code>，解析参数；初始化事件、挂载生命周期；处理 watch 监听、computed 以及数据劫持、解析模版，把模版交给 render 函数处理成虚拟 DOM ；把虚拟 DOM 解析成真实 DOM 进行挂载。</p>
</blockquote>
<h3 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装?"></a>组件封装?</h3><blockquote>
<p>单一职责：组件没有太多功能（可组合）</p>
<p>低耦合/高内聚：高内聚（一样的功能，封装到组件内部），低耦合（组件可以独立运行，放到任意地方都可以跑）</p>
<p>可定制：根据传参的不同，实现对应的效果（提前封装/定制好的），通过传值定制不同的形式效果</p>
<p>可拓展：外界可以决定做什么事情</p>
</blockquote>
<h3 id="小程序生命周期钩子"><a href="#小程序生命周期钩子" class="headerlink" title="小程序生命周期钩子"></a>小程序生命周期钩子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 小程序</span><br><span class="line"># 应用生命周期</span><br><span class="line">onLaunch：初始化钩子，只触发一次</span><br><span class="line">onShow：回到当前页面时触发</span><br><span class="line">onHide：离开当前页时触发</span><br><span class="line">onError：错误监听函数</span><br><span class="line">onPageNotFound：页面不存在</span><br><span class="line">onUnhandledRejection：未处理的 <span class="title class_">Promise</span> 拒绝事件监听函数。</span><br><span class="line">onThemeChange：系统切换主题时触发</span><br><span class="line"></span><br><span class="line"># 页面生命周期</span><br><span class="line">onLoad：页面初始化钩子，只触发一次</span><br><span class="line">onShow：回到当前页面时触发</span><br><span class="line">onReady：页面初次渲染完成时触发，只触发一次</span><br><span class="line">onHide：离开当前页时触发</span><br><span class="line">onUnload：页面卸载时触发</span><br><span class="line">onRouteDone：路由动画完成时触发</span><br><span class="line">onPullDownRefresh：页面相关事件处理函数 比如 用户下拉刷新事件</span><br><span class="line">onReachBottom：页面上拉触底事件的处理函数</span><br><span class="line"><span class="string">&#x27;需要在 app.json 里面的 window 配置 onReachBottomDistance：距离px，默认50px&#x27;</span></span><br><span class="line"></span><br><span class="line">onShareAppMessage：右上角分享按钮</span><br><span class="line"></span><br><span class="line"># 组件生命周期</span><br><span class="line">created：组件实例被创建时触发</span><br><span class="line">attached：进入页面时触发</span><br><span class="line">detached：组件实例被从页面节点树移除时执行</span><br><span class="line">ready：组件在视图布局完成后执行</span><br><span class="line">move：组件实例被移动到节点树另一个位置时执行</span><br><span class="line">error：每当组件方法抛出错误时执行</span><br></pre></td></tr></table></figure>
<h3 id="setup-返回的一定是对象吗？"><a href="#setup-返回的一定是对象吗？" class="headerlink" title="setup 返回的一定是对象吗？"></a><strong>setup 返回的一定是对象吗？</strong></h3><blockquote>
<p>不一定，也可以是一个渲染函数（可以在没有模版的情况下，渲染内容）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="comment">// 渲染函数</span></span><br><span class="line">    <span class="comment">// 参数1：标签，参数2：内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span><span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>,<span class="string">&#x27;Hello world&#x27;</span>) <span class="comment">// 会在页面生成一个h1标签，右侧为显示的内容</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="DOM-Diff算法"><a href="#DOM-Diff算法" class="headerlink" title="DOM Diff算法"></a>DOM Diff算法</h3><blockquote>
<p>Diff算法又称快速 diff 算法</p>
<p>借鉴：ivi 和 inferno +纯文本 diff 算法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">diff算法的执行过程</span><br><span class="line"><span class="number">1</span>、预处理 前 置节点</span><br><span class="line"><span class="number">2</span>、预处理 后 置节点</span><br><span class="line"><span class="number">3</span>、处理 仅有新增 节点情况</span><br><span class="line"><span class="number">4</span>、处理 仅有卸载 节点情况</span><br><span class="line"><span class="number">5</span>、处理 其他 情况(新增/卸载/移动)</span><br></pre></td></tr></table></figure>
<h3 id="项目打包优化手段"><a href="#项目打包优化手段" class="headerlink" title="项目打包优化手段"></a>项目打包优化手段</h3><p>cdn加载</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span>、按需加载 第三方库 比如：<span class="variable constant_">UI</span> 组件库</span><br><span class="line">首先安装     npm install babel-plugin-component -D</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./plugins/element.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// plugins/element.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">Pagination</span>,</span><br><span class="line">  <span class="title class_">Dialog</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Pagination</span>);</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Dialog</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把弹框组件挂着到了 vue 的原型对象上，这样每一个组件都可以直接通过 this 访问</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$message</span> = <span class="title class_">Message</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$confirm</span> = <span class="title class_">MessageBox</span>.<span class="property">confirm</span></span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>、按需导入工具包</span><br><span class="line"><span class="comment">// 按需加载第三方工具包（例如 lodash）或者使用 CDN 的方式进行处理。</span></span><br><span class="line">例如：工具包  </span><br><span class="line">	npm i babel-plugin-transform-remove-<span class="variable language_">console</span> -D</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="string">&#x27;工具&#x27;</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span></span><br><span class="line">！工具包在打包的时候处理一下</span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>、移除<span class="variable language_">console</span>.<span class="property">log</span>信息</span><br><span class="line">npm install babel-plugin-component -D</span><br><span class="line"><span class="comment">// babel.config.js</span></span><br><span class="line"><span class="keyword">const</span> prodPlugins = [] <span class="comment">// 把插件装到数组里面</span></span><br><span class="line"><span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">  prodPlugins.<span class="title function_">push</span>(<span class="string">&#x27;transform-remove-console&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [<span class="string">&#x27;@vue/cli-plugin-babel/preset&#x27;</span>],</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&#x27;component&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">libraryName</span>: <span class="string">&#x27;element-ui&#x27;</span>,</span><br><span class="line">        <span class="attr">styleLibraryName</span>: <span class="string">&#x27;theme-chalk&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    ...prodPlugins <span class="comment">// 这里应用一下，插件就生效了</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># <span class="number">4</span>、处理 sourcemap 代码调试</span><br><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">productionSourceMap</span>: <span class="literal">false</span>  <span class="comment">// 选择不生成 生产环境文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># <span class="number">5</span>、<span class="title class_">Externals</span> &amp;&amp; <span class="variable constant_">CDN</span></span><br><span class="line"><span class="comment">// 通过 externals 排除第三方 JS 和 CSS 文件打包，使用 CDN 加载。</span></span><br><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">productionSourceMap</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    config.<span class="title function_">when</span>(process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span>, <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> cdn = &#123; <span class="comment">// 生产环境对象</span></span><br><span class="line">        <span class="attr">js</span>: [  <span class="comment">// 第三方js</span></span><br><span class="line">          <span class="string">&#x27;https://cdn.staticfile.org/vue/2.6.11/vue.min.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;https://cdn.staticfile.org/vue-router/3.1.3/vue-router.min.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;https://cdn.staticfile.org/axios/0.18.0/axios.min.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;https://cdn.staticfile.org/echarts/4.1.0/echarts.min.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;https://cdn.staticfile.org/quill/1.3.4/quill.min.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;https://cdn.jsdelivr.net/npm/vue-quill-editor@3.0.4/dist/vue-quill-editor.js&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">css</span>: [  <span class="comment">// 第三方css</span></span><br><span class="line">          <span class="string">&#x27;https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;https://cdn.staticfile.org/quill/1.3.4/quill.core.min.css&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;https://cdn.staticfile.org/quill/1.3.4/quill.snow.min.css&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;https://cdn.staticfile.org/quill/1.3.4/quill.bubble.min.css&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">      config.<span class="title function_">set</span>(<span class="string">&#x27;externals&#x27;</span>, &#123;  <span class="comment">// 通过 externals 排除不希望打包的文件</span></span><br><span class="line">        <span class="attr">vue</span>: <span class="string">&#x27;Vue&#x27;</span>,   <span class="comment">// key值是有讲究的，key值需要和引入的一致---&gt; vue: &#x27;Vue&#x27; &lt;--- value也必须和引入的CDN地址包一致</span></span><br><span class="line">        <span class="string">&#x27;vue-router&#x27;</span>: <span class="string">&#x27;VueRouter&#x27;</span>,</span><br><span class="line">        <span class="attr">axios</span>: <span class="string">&#x27;axios&#x27;</span>,</span><br><span class="line">        <span class="attr">echarts</span>: <span class="string">&#x27;echarts&#x27;</span>,</span><br><span class="line">        <span class="attr">nprogress</span>: <span class="string">&#x27;NProgress&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;nprogress/nprogress.css&#x27;</span>: <span class="string">&#x27;NProgress&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;vue-quill-editor&#x27;</span>: <span class="string">&#x27;VueQuillEditor&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;quill/dist/quill.core.css&#x27;</span>: <span class="string">&#x27;VueQuillEditor&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;quill/dist/quill.snow.css&#x27;</span>: <span class="string">&#x27;VueQuillEditor&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;quill/dist/quill.bubble.css&#x27;</span>: <span class="string">&#x27;VueQuillEditor&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">      config.<span class="title function_">plugin</span>(<span class="string">&#x27;html&#x27;</span>).<span class="title function_">tap</span>(<span class="function">(<span class="params">args</span>) =&gt;</span> &#123; <span class="comment">// 挂载数据</span></span><br><span class="line">        args[<span class="number">0</span>].<span class="property">isProd</span> = <span class="literal">true</span></span><br><span class="line">        args[<span class="number">0</span>].<span class="property">cdn</span> = cdn</span><br><span class="line">        <span class="keyword">return</span> args</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// public/index.html</span></span><br><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;</span><br><span class="line">  &lt;title&gt;</span><br><span class="line">    &lt;%= htmlWebpackPlugin.options.title %&gt;</span><br><span class="line">  &lt;/title&gt;</span><br><span class="line">  &lt;% if(htmlWebpackPlugin.options.isProd)&#123; %&gt;  # &lt;-- 通过 isProd 进行判断是否渲染</span><br><span class="line">    &lt;% for(var css of htmlWebpackPlugin.options.cdn.css) &#123; %&gt;</span><br><span class="line">      &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%=css%&gt;&quot;&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">        &lt;% &#125; %&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;noscript&gt;</span><br><span class="line">    &lt;strong&gt;We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled.</span><br><span class="line">        Please enable it to continue.&lt;/strong&gt;</span><br><span class="line">  &lt;/noscript&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;!-- built files will be auto injected --&gt;</span><br><span class="line">  &lt;% if(htmlWebpackPlugin.options.isProd)&#123; %&gt;</span><br><span class="line">    &lt;% for(var js of htmlWebpackPlugin.options.cdn.js) &#123; %&gt;</span><br><span class="line">      &lt;script src=&quot;&lt;%=js%&gt;&quot;&gt;&lt;/script&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">        &lt;% &#125; %&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"># 6、懒加载   缺点：会增大文件体积，但是增加的并不多</span><br><span class="line">const routes = [&#123;</span><br><span class="line">  path:&#x27;/&#x27;,</span><br><span class="line">  redirect:&#x27;/login&#x27;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">  path:&#x27;/Home&#x27;,</span><br><span class="line">  component:&#x27;../components/Home.vue&#x27;</span><br><span class="line">&#125;]</span><br><span class="line">// 路由懒加载就是把上面的代码 `component:&#x27;../components/Home.vue&#x27;` 改成下面的代码 `component:()=&gt;import(&#x27;../components/Home.vue&#x27;)` 这样路由不会立即加载，只有触发该路径的时候才会发送路由请求，点击页面跳转路径的时候发送请求，说明已经做到了路由懒加载</span><br><span class="line">const routes = [&#123;</span><br><span class="line">  path:&#x27;/&#x27;,</span><br><span class="line">  redirect:&#x27;/login&#x27;</span><br><span class="line">	&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path:&#x27;/Home&#x27;,</span><br><span class="line">    component:()=&gt;import(&#x27;../components/Home.vue&#x27;)</span><br><span class="line">  &#125;]</span><br><span class="line"></span><br><span class="line">// 图片的压缩、雪碧图（精灵图）</span><br></pre></td></tr></table></figure>
<h3 id="路由缓存问题"><a href="#路由缓存问题" class="headerlink" title="路由缓存问题"></a>路由缓存问题</h3><blockquote>
<p>当路由地址的切换匹配的是同一个 path 时，Vue出于性能的考虑，对应的路由组件会被<code>复用</code>。也就意味着，即便路由参数每次发送了变化，路由组件中对应的生命钩子也就只会被触发1次。例如：当在 setup 中需要根据路由参数的变化发请求时，会发现拿到的永远是最初到的旧数据。我们希望点击tabbar栏切换id时发送请求，而不是只发送一次请求。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、</span><br><span class="line"># 给路由出口添加一个不一样的 key 值,这样vue检测到key值发生变化就会对这个组件进行重新初始化的一个操作，一般我们会写$route.<span class="property">fullPath</span></span><br><span class="line"><span class="comment">// $route.fullPath，类型: string，说明：完成解析后的 URL，包含查询参数和 hash 的完整路径。</span></span><br><span class="line">&lt;router-view :key=<span class="string">&quot;$route.fullPath&quot;</span>&gt;&lt;/router-view&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、</span><br><span class="line">通过watch监听 路由传过来的id的变化并进行发送请求</span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>route.<span class="property">params</span>.<span class="property">id</span>,<span class="function">(<span class="params">newId</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 发送请求...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、</span><br><span class="line">通过 <span class="title class_">VueRouter</span> 官方提供的 onBeforeRouteUpdate,添加一个导航守卫，不论当前位置何时被更新都会触发。</span><br><span class="line"><span class="title function_">onBeforeRouteUpdate</span>(<span class="function">(<span class="params">to</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 请求代码...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="pinia持久化存储"><a href="#pinia持久化存储" class="headerlink" title="pinia持久化存储"></a>pinia持久化存储</h3><p><code>pinia</code> 和 <code>vuex</code> 一样，数据是短时的，只要一刷新页面，数据就会恢复成初始状态，为了避免这个问题，可以对其采用持久化保存方法。</p>
<p>持久化保存的原理是在 <code>pinia</code> 中数据更新时，同步保存到 <code>localStorage</code> 或 <code>sessionStorage</code> 中，刷新后从本地存储中读取数据，你可以选择自己去写，但是实现起来并不像想象中那么容易，当然，也没那么难。</p>
<p>一般我们可以借助插件进行持久化存储</p>
<blockquote>
<p>pnpm i pinia-plugin-persistedstate</p>
<p>或</p>
<p>yarn add pinia-plugin-persistedstate</p>
<p>或</p>
<p>npm i pinia-plugin-persistedstate</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">`persist`</span> <span class="keyword">from</span> <span class="string">`&#x27;pinia-plugin-persistedstate&#x27;`</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">`persist`</span> )</span><br></pre></td></tr></table></figure>
<h3 id="什么是动态路由？"><a href="#什么是动态路由？" class="headerlink" title="什么是动态路由？"></a>什么是动态路由？</h3><p>&gt;</p>
<h3 id="路由懒加载怎么做？"><a href="#路由懒加载怎么做？" class="headerlink" title="路由懒加载怎么做？"></a>路由懒加载怎么做？</h3><p>&gt;</p>
<h2 id="TS"><a href="#TS" class="headerlink" title="TS"></a>TS</h2><h3 id="type-和-interface-的异同"><a href="#type-和-interface-的异同" class="headerlink" title="type 和 interface 的异同"></a>type 和 interface 的异同</h3><blockquote>
<p>相同点：<br>1、都能描述对象，但是 type 还能描述其他任意类型，例如 string、number 等基本类型、联合或交叉等类型<br>2、都能进行类型拓展，interface 通过extends来实现，type通过 &amp; 交叉运算符号形成交叉类型。</p>
<p>3、名字相同时，当多个 interface 声明名字相同时会发生合并 查漏补缺，type 会报错，只允许声明一次。</p>
<p>4、个人一般使用 interface 来描述对象结构，用 type 来描述类型之间的关系。</p>
</blockquote>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">强制缓存</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对比缓存/又称协商缓存</span><br></pre></td></tr></table></figure>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><blockquote>
<p>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术，用于创建快速动态网页的技术。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>() <span class="comment">// 创建 XMLHttpRequest 对象</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;method 请求类型,GET 或 POST&quot;</span>,<span class="string">&quot;文件在服务器上的位置(网址、域名)&quot;</span>,<span class="literal">true</span>（异步）或 <span class="literal">false</span>（同步）不写默认异步);</span><br><span class="line">xhr.<span class="title function_">send</span>(); <span class="comment">// 将.open请求发送到服务器。</span></span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(header,value); <span class="comment">// 向请求添加 HTTP 头。</span></span><br><span class="line"><span class="attr">header</span>:规定头的名称，如：<span class="string">&quot;Content-type&quot;</span></span><br><span class="line">value：规定头的值，如：<span class="string">&quot;application/x-www-form-urlencoded&quot;</span></span><br><span class="line"></span><br><span class="line">onreadystatechange事件 <span class="comment">// 监测请求发生的状态</span></span><br><span class="line"><span class="comment">// 当请求被发送到服务器时，我们需要执行一些基于响应的任务，每当 readyState 改变时，就会触发 onreadystatechange 事件，readyState 属性存有 XMLHttpRequest 的状态信息。</span></span><br><span class="line">readyState有多个属性表示 <span class="title class_">XMLHttpRequest</span> 的状态，从 <span class="number">0</span> 到 <span class="number">4</span> 发生变化。</span><br><span class="line"><span class="number">0</span>: 请求未初始化</span><br><span class="line"><span class="number">1</span>: 服务器连接已建立</span><br><span class="line"><span class="number">2</span>: 请求已接收</span><br><span class="line"><span class="number">3</span>: 请求处理中</span><br><span class="line"><span class="number">4</span>: 请求已完成，且响应已就绪</span><br><span class="line"></span><br><span class="line">status 表示状态码（<span class="number">200</span> || <span class="number">404</span>）只有两种</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;   <span class="comment">// 请求发送成功并且响应</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><blockquote>
<p>100——客户必须继续发出请求 <code>请求已经建立但是没有发送请求</code><br>101——客户要求服务器根据请求转换HTTP协议版本<br>200——交易成功 <code>请求成功</code><br>201——提示知道新文件的URL<br>202——接受和处理、但处理未完成<br>203——返回信息不确定或不完整<br>204——请求收到，但返回信息为空<br>205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件<br>206——服务器已经完成了部分用户的GET请求<br>300——请求的资源可在多处得到<br>301——删除请求数据 <code>永久重定向</code><br>302——在其他地址发现了请求数据 <code>临时重定向</code><br>303——建议客户访问其他URL或访问方式<br>304——客户端已经执行了GET，但文件未变化 <code>浏览器缓存相关，请求的文件未发生改变</code><br>305——请求的资源必须从服务器指定的地址得到<br>306——前一版本HTTP中使用的代码，现行版本中不再使用<br>307——申明请求的资源临时性删除<br>400——错误请求，如语法错误 <code>请求报文中存在错误，需修改请求的内容后再次发送请求。</code><br>401——请求授权失败 <code>token过期所以请求失败</code><br>402——保留有效ChargeTo头响应<br>403——请求不允许 <code>没有权限</code><br>404——没有发现文件、查询或URl <code>服务器上无法找到请求的资源或路径</code><br>405——用户在Request-Line字段定义的方法不允许<br>406——根据用户发送的Accept拖，请求资源不可访问<br>407——类似401，用户必须首先在代理服务器上得到授权<br>408——客户端没有在用户指定的饿时间内完成请求<br>409——对当前资源状态，请求不能完成<br>410——服务器上不再有此资源且无进一步的参考地址<br>411——服务器拒绝用户定义的Content-Length属性请求<br>412——一个或多个请求头字段在当前请求中错误<br>413——请求的资源大于服务器允许的大小<br>414——请求的资源URL长于服务器允许的长度<br>415——请求资源不支持请求项目格式<br>416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段<br>417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求<br>500——服务器产生内部错误<br>501——服务器不支持请求的函数<br>502——服务器暂时不可用，有时是为了防止发生系统过载<br>503——服务器过载或暂停维修<br>504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长<br>505——服务器不支持或拒绝支请求头中指定的HTTP版本</p>
<p>1xx:信息响应类，表示接收到请求并且继续处理<br>2xx:处理成功响应类，表示动作被成功接收、理解和接受<br>3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理<br>4xx:客户端错误，客户请求包含语法错误或者是不能正确执行<br>5xx:服务端错误，服务器不能正确执行一个正确的请求</p>
</blockquote>
<h3 id="restful-API接口文档风格"><a href="#restful-API接口文档风格" class="headerlink" title="restful   API接口文档风格"></a>restful   API接口文档风格</h3><blockquote>
<p>restful API 是后端设置接口的一种风格，很直观，即便相同的请求地址，能根据请求方式的不同，实现不同的功能</p>
</blockquote>
<h3 id="HTTP是什么？什么是HTTP"><a href="#HTTP是什么？什么是HTTP" class="headerlink" title="HTTP是什么？什么是HTTP?"></a>HTTP是什么？什么是HTTP?</h3><blockquote>
<p>是客户端和服务端进行数据交互的协议（标准）。</p>
</blockquote>
<h3 id="axios的请求方式有哪些？-根据后端文档-axios-传参"><a href="#axios的请求方式有哪些？-根据后端文档-axios-传参" class="headerlink" title="axios的请求方式有哪些？/ 根据后端文档 axios 传参"></a>axios的请求方式有哪些？/ 根据后端文档 axios 传参</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">get</span>：只支持params传参 <span class="comment">// 一般用户获取数据</span></span><br><span class="line">axios.<span class="property">request</span></span><br><span class="line">axios.<span class="property">delete</span>：只支持params传参 <span class="comment">// 用于删除数据</span></span><br><span class="line">axios.<span class="property">head</span>：只支持params传参</span><br><span class="line">axios.<span class="property">options</span></span><br><span class="line">axios.<span class="property">post</span>： 同时支持  data 和 params <span class="comment">// 用于提交数据（新建）</span></span><br><span class="line">axios.<span class="property">put</span>： 同时支持  data 和 params <span class="comment">// 用于更新数据（修改）</span></span><br><span class="line">axios.<span class="property">patch</span>： 同时支持  data 和 params <span class="comment">// 用于更新数据（修改）单个修改，类似于补丁</span></span><br><span class="line"></span><br><span class="line"># <span class="variable constant_">PUT</span> 和 <span class="variable constant_">PATCH</span> 的区别？</span><br><span class="line">一个局部一个全局</span><br><span class="line">patch（补丁） 就是只会修改某个或某一部分</span><br><span class="line"></span><br><span class="line">？号传参，query 传参</span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user？id=888&#x27;</span>)</span><br><span class="line">地址栏传参，params 传参</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">请求体传参</span><br><span class="line"># 格式：applicition/json</span><br><span class="line"># post传参</span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;/地址&#x27;</span>,&#123;传参&#125;)</span><br><span class="line">或</span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,<span class="comment">//请求方法</span></span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;后台接口地址&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: data,</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//执行成功后代码处理</span></span><br><span class="line">&#125;)</span><br><span class="line"># formData传参</span><br><span class="line"> <span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,<span class="comment">//请求方法</span></span><br><span class="line">    <span class="attr">data</span>: fromData,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;后台接口地址&#x27;</span>,</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//执行成功后代码处理</span></span><br><span class="line">&#125;)</span><br><span class="line"># 格式：application/x-www-form-urlencoded</span><br><span class="line"><span class="title function_">http</span>(&#123;</span><br><span class="line">  <span class="attr">method</span>:<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>:<span class="string">&#x27;接口地址&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>:&#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">data</span>:<span class="string">&#x27;username=ifer&amp;age=18&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"># 格式：application/multipart-formdata 表示文件上传格式</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span><br><span class="line">f.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>,e.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>])</span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;/file&#x27;</span>,f)</span><br></pre></td></tr></table></figure>
<h3 id="axios请求"><a href="#axios请求" class="headerlink" title="axios请求"></a>axios请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="comment">// `url` 是用于请求的服务器 URL</span></span><br><span class="line">	<span class="attr">url</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">	<span class="comment">// `method` 是创建请求时使用的方法</span></span><br><span class="line">	<span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>, <span class="comment">// 默认值</span></span><br><span class="line">  <span class="comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span></span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="comment">// `transformRequest` 允许在向服务器发送前，修改请求数据,它只能用于 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法</span></span><br><span class="line">  <span class="attr">transformRequest</span>: [<span class="keyword">function</span>(<span class="params">参数<span class="number">1</span>，参数<span class="number">2</span></span>)&#123;</span><br><span class="line">     <span class="comment">// 对发送的 data 进行任意转换处理</span></span><br><span class="line">     <span class="keyword">return</span> data;</span><br><span class="line">  &#125;]</span><br><span class="line">  <span class="comment">// 在传递给 then/catch 前，允许修改响应数据</span></span><br><span class="line">  <span class="attr">transformResponse</span>: [<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// 对接收的 data 进行任意转换处理</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="comment">// timeout 指定请求超时的毫秒数,如果请求时间超过 `timeout` 的值，则请求会被中断</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span> <span class="comment">// 默认值是 `0` (永不超时)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="axios封装"><a href="#axios封装" class="headerlink" title="axios封装"></a>axios封装</h3><blockquote>
<p>1、创建一个axios实例。</p>
<p>2、封装 baseURL、timeout。</p>
<p>​       封装 transformResponse。</p>
<p>3、请求拦截器（统一携带token）</p>
<p>4、响应拦截器</p>
<p>​    成功回调做数据脱壳 或 统一的错误处理 =&gt; 业务错误</p>
<p>​    失败回调做统一的错误处理（HTTP 状态码的错误）</p>
<p>​        无感刷新：一般 token 出于安全性的考虑，有效期不会设的很长，这样就会导致用户浏览网站的时间并不长，并且频繁登录体验不好。</p>
<p>​        解决方法：token 还是设置有效期很短当过期的时候回 401 ，在响应拦截器错误额地方 refresh_Token 调用后端接口拿到新 token ，更新到 vuex 和本地，重新把错误的请求重新发送一次。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后端返回的数据都是 JSON 格式的字符串，但是我们用到的时候竟然可以当做对象直接使用，为什么呢？</span></span><br><span class="line"><span class="comment">// 原因就是 axios 内部通过 JSON.parse 进行了转换，所以可以当做对象去使用，但是如果后端返回的数据是 &#x27;&#123;&quot;id&quot;:111111111111111111111&#125;&#x27;，axios 转换后 &#123;id: 111111111111111110000&#125;，转换后与后端返回的完全不同，如果拿去发送请求则会立即404，因为后端返回的格式是大数字格式（超过了安全范围 Number.MAX_SAFE_INTEGER，或，Math.pow(2,53)-1 称为大数字），</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">JSON</span>big = <span class="built_in">require</span>(<span class="string">&#x27;json-bigint&#x27;</span>);</span><br><span class="line">axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">	baseURL,</span><br><span class="line">  timeout,</span><br><span class="line">  <span class="comment">// json-bigint包可以帮助我们解决大数字问题</span></span><br><span class="line">  <span class="attr">transformResponse</span>:[<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="comment">// 默认</span></span><br><span class="line">    <span class="comment">// return JSON.parse(data)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">JSON</span>big.<span class="title function_">parse</span>(data) <span class="comment">// 转换大数字</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="axios取消请求"><a href="#axios取消请求" class="headerlink" title="axios取消请求"></a>axios取消请求</h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort">官网取消请求</a>应用场景 —- 点击切换页面或导航栏会发生请求，假如这时候用户切换的特别快那么一次就会发生多个请求，而我们只需要显示用户当前页面的请求，其他请求则不需要返回这时候就会浪费性能。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42018166/article/details/120705730?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=axios%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-120705730.142^v91^insertT0,239^v12^control2&amp;spm=1018.2226.3001.4187">取消请求博客</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果该请求已被发出，可以使用原生的 XMLHttpRequest.abort() 方法将终止该请求。</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET or POST&#x27;</span>, url);</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br><span class="line"><span class="comment">// 取消请求使用 xhr.abort()</span></span><br><span class="line">使用方式：</span><br><span class="line">  <span class="comment">// 创建全局变量，目的是为了存储取消请求的那个函数</span></span><br><span class="line">  <span class="keyword">let</span> cancel = <span class="literal">null</span>;</span><br><span class="line">  oBtn.<span class="property">onclick</span> = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> r = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;https://api-hmugo-web.itheima.net/api/public/v1/home/swiperdata&#x27;</span>, &#123;</span><br><span class="line">      <span class="comment">// 配置 cancelToken 参数</span></span><br><span class="line">      <span class="attr">cancelToken</span>: <span class="keyword">new</span> axios.<span class="title class_">CancelToken</span>(<span class="keyword">function</span>(<span class="params">c</span>) &#123;</span><br><span class="line">      <span class="comment">// c =&gt; 就是关闭当前请求的函数</span></span><br><span class="line">      cancel = c;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(r.<span class="property">data</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  oCancel.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">cancel</span>()</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>什么是跨域？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、代理服务器（正向代理 =&gt; 正客（正向代理） 反服），如果 <span class="title class_">Vue</span> <span class="title class_">ClI</span> 创建的项目，可以在 vue.<span class="property">config</span>.<span class="property">js</span> 中配置 devServer 的 <span class="title function_">proxy</span>(破克醒) 选项。</span><br><span class="line"><span class="number">2</span>、<span class="variable constant_">CORS</span>，后端通过设置 <span class="title class_">Access</span>(阿克赛斯)-<span class="title class_">Control</span>(康却)-<span class="title class_">Allow</span>(恶劳)-<span class="title class_">Origin</span> 响应头来允许访问某些域名访问</span><br><span class="line"><span class="number">3</span>、<span class="title class_">JSON</span>，缺点：只能处理 <span class="variable constant_">GET</span> 请求，利用 script 标签不存在跨域限制这一特点去实现的，因为 &lt;script&gt; 标签可以无视跨域限制</span><br></pre></td></tr></table></figure>
<h2 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h2><h3 id="为什么使用-uni-app？"><a href="#为什么使用-uni-app？" class="headerlink" title="为什么使用 uni-app？"></a>为什么使用 uni-app？</h3><blockquote>
<p>为了使用 Vue 的语法，上手成本低；一套代码可以多端使用（我们这一版主要针对的是小程序端，后续可能拓展的其他端）。</p>
</blockquote>
<h3 id="只有微信小程序支持的属性是什么？"><a href="#只有微信小程序支持的属性是什么？" class="headerlink" title="只有微信小程序支持的属性是什么？"></a>只有微信小程序支持的属性是什么？</h3><p>&gt;</p>
<h3 id="小程序客服"><a href="#小程序客服" class="headerlink" title="小程序客服?"></a>小程序客服?</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置一个 &lt;buttn&gt; 按钮，给按钮添加 <span class="string">&#x27;open-type&#x27;</span> 属性为 <span class="string">&#x27;contact&#x27;</span>，点击即可进入客服会话。</span><br></pre></td></tr></table></figure>
<h3 id="小程序中分享怎么做的？"><a href="#小程序中分享怎么做的？" class="headerlink" title="小程序中分享怎么做的？"></a>小程序中分享怎么做的？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给按钮设置 share 触发用户转发</span></span><br><span class="line">&lt;button open-type=<span class="string">&quot;share&quot;</span>&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户点击按钮后触发 Page.onShareAppMessage 事件</span></span><br><span class="line"><span class="title function_">onShareAppMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;分享标题&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;查看路径&#x27;</span>,</span><br><span class="line">      <span class="attr">imageUrl</span>: <span class="string">&#x27;封面地址&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="小程序扫码功能实现"><a href="#小程序扫码功能实现" class="headerlink" title="小程序扫码功能实现"></a>小程序扫码功能实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定点击事件</span></span><br><span class="line">&lt;button <span class="keyword">class</span>=<span class="string">&quot;btn-bottom&quot;</span> <span class="attr">bind</span>:tap=<span class="string">&quot;saomasuy&quot;</span>&gt;扫码&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 wx.scanCode 唤醒用户相机</span></span><br><span class="line">wx.<span class="title function_">scanCode</span>(斯给扣得)(&#123; <span class="comment">//唤醒相机，调起客户端扫码界面进行扫码</span></span><br><span class="line">  <span class="title function_">onlyFromCamera</span>(安立否开幕): <span class="literal">false</span>, <span class="comment">// false 允许从相册扫码，true 不允许从相册扫码</span></span><br><span class="line">  <span class="title function_">success</span>(c格赛斯): <span class="keyword">function</span> (<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="comment">// console.log(a.scanType) // 获取扫码类型</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="小程序登录流程"><a href="#小程序登录流程" class="headerlink" title="小程序登录流程"></a>小程序登录流程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">逐字稿：</span><br><span class="line"><span class="number">1</span>、小程序端调用 wx.<span class="title function_">login</span>() 获取 code（临时登录凭证 ）。</span><br><span class="line"><span class="number">2</span>、通过 wx.<span class="title function_">request</span>() 发送 code 到后端。</span><br><span class="line"><span class="number">3</span>、后端调用 codeSession（登录凭证校验的函数）并且传递 appid（小程序 <span class="variable constant_">ID</span>）、<span class="title function_">appsecret</span>(app c扣瑞的)（小程序密钥）、code（临时登录凭证） 到微信的后台。</span><br><span class="line"><span class="number">4</span>、微信后台返回到后端 session_key、openid（用户唯一标识）。</span><br><span class="line"><span class="number">5.</span> 后端把 openid和session_key 进行关联,形成自定义登录态（生成 token）并返回 token 到前端。</span><br><span class="line"><span class="number">6.</span> 前端拿到数据并进行存储（持久化）token 到本地，后续再用 wx.<span class="title function_">request</span>() 发请求的时候携带 token。</span><br><span class="line"><span class="number">7.</span> 后端通过 token 查询关联的 openid，明确身份后返回信息给前端。</span><br></pre></td></tr></table></figure>
<h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="webpack是什么-什么是webpack"><a href="#webpack是什么-什么是webpack" class="headerlink" title="webpack是什么? / 什么是webpack"></a>webpack是什么? / 什么是webpack</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">是什么?</span><br><span class="line">webpack是<span class="string">&#x27;静态资源打包工具&#x27;</span></span><br><span class="line">可以处理一个或多个Javascript应用程序和库的依赖关系，并生成相应的静态资源</span><br><span class="line">如Javascript (js)文件、样式表、图片等。</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">怎么用?</span><br><span class="line">解决了什么问题?</span><br><span class="line">有没有替代方案?</span><br><span class="line">好处是什么?</span><br><span class="line">场景是什么?</span><br><span class="line">原理是什么?</span><br></pre></td></tr></table></figure>
<h3 id="什么是websocket？什么是websocket协议"><a href="#什么是websocket？什么是websocket协议" class="headerlink" title="什么是websocket？什么是websocket协议?"></a>什么是websocket？什么是websocket协议?</h3><blockquote>
<p>用于提供<code>低延迟</code>、<code>全双工</code>、<code>长期运行</code>的连接。</p>
<p>全双工：通信的两个参与方可以同时发送和接收数据，不需要等待对方的响应式或传输完成。</p>
<p>可以说websocket的出现就是为了解决实时通信的问题。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">传统的通信：电子邮箱、网页浏览、存在延迟，需要用户主动请求来获取更新数据</span><br><span class="line">实时通信：即使消息传递、音视频通话、在线会议和实时数据传输等，可以实现即时的数据传输和交流，不需要用户主动请求或刷新来获取更新数据</span><br><span class="line"></span><br><span class="line">在 websocket 之前通信方式：</span><br><span class="line"><span class="string">&#x27;轮询&#x27;</span>：就是客户端定期不间断的向后端发送请求，询问是否有新数据产生，服务器接收数据后检查是否有新数据并返回给前端。</span><br><span class="line"><span class="string">&#x27;缺点&#x27;</span>：会产生大量的请求和响应，导致不必要的网络开销和延迟。</span><br><span class="line"><span class="string">&#x27;思路&#x27;</span>：设置定时器不间断向服务器发送请求。</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;长轮询&#x27;</span>：基于<span class="variable constant_">HTTP</span>的技术，在客户端发出请求后，保持连接打开，在服务器有新数据可以使用时返回给前端，在关闭连接。解决了无效轮询的数量</span><br><span class="line"><span class="string">&#x27;缺点&#x27;</span>：需要频繁的建立连接和关闭连接</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;Comet&#x27;</span>(扣曼特)：基于<span class="variable constant_">HTTP</span>的技术，在客户端发出请求后继续保持连接，核心通过保持长连接模拟实时通信，并允许服务器通过<span class="string">&#x27;流式传输、frame &#x27;</span>等推送技术来主动向客户端推送数据。</span><br><span class="line"><span class="string">&#x27;缺点&#x27;</span>：推送方式还是通过延长响应或推送技巧来实现的。</span><br><span class="line"></span><br><span class="line">websocket对比优势：</span><br><span class="line"><span class="string">&#x27;双向实时通信&#x27;</span>：允许在单个、长时间的连接上进行双向实时通信。在需要快速实时更新的应用程序里比 <span class="variable constant_">HTTP</span> 更加高效。</span><br><span class="line"><span class="string">&#x27;降低延迟&#x27;</span>：链接一旦建立会保持开放，数据可以在客户端和服务器之间比 <span class="variable constant_">HTTP</span> 更低的延迟进行传输。</span><br><span class="line"><span class="string">&#x27;更高效的资源利用&#x27;</span>：减少重复请求和响应的开销，因为连接只需要建立一次。</span><br><span class="line"><span class="string">&#x27;优点&#x27;</span>：允许客户端或服务器之间通过单个 <span class="variable constant_">TCP</span> 连接进行双工通信，并且进行实时的数据交换。</span><br><span class="line"></span><br><span class="line">如何建立 websocket 连接？</span><br><span class="line">通过 <span class="variable constant_">HTTP</span> 发送一次常规的 get请求，在请求头中带上 <span class="title class_">Upgrade</span>，告诉服务器从 <span class="variable constant_">HTTP</span> 升级成 <span class="title class_">Websocket</span>，连接就建立成功</span><br></pre></td></tr></table></figure>
<h3 id="websocket心跳机制"><a href="#websocket心跳机制" class="headerlink" title="websocket心跳机制"></a>websocket心跳机制</h3><blockquote>
<p>为了保持 Websocket 稳定的长连接，在连接建立之后，服务器和客户端之间通过<code>心跳包</code>来保持连接状态，以防止连接因为长时间没有数据传输而被切断。</p>
<p><code>心跳包</code>：一种特殊的数据包，不包含任何实际数据，仅用来维持连接状态。</p>
<p>原理：定期发送一个空的数据帧，确保双方之间的连接仍然有效，避免长时间没有数据传输而中断，一段时间内没有收到对方的心跳包，就可以认为连接已经断开，需要重新建立连接。</p>
<p>缺点：</p>
<p>不提供加密功能，可使用 SSL 协议，设置黑白名单弥补。</p>
<p>不支持古老浏览器，如IE10以前版本，需要使用 AJAX 或其他方式替代。</p>
<p>长连接会过渡消耗资源，需要不断的维护和处理连接状态，需要优化性能。</p>
</blockquote>
<h3 id="配置-webpack-的排除打包效果-CDN"><a href="#配置-webpack-的排除打包效果-CDN" class="headerlink" title="配置 webpack 的排除打包效果 CDN"></a>配置 webpack 的排除打包效果 CDN</h3><blockquote>
<p>externals 排除不需要的文件后，配合CDN将样式加载过来</p>
</blockquote>
<h1 id="未分类面试题"><a href="#未分类面试题" class="headerlink" title="未分类面试题"></a>未分类面试题</h1><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.ctyun.cn/developer/article/424865198821445">CDN与前端技术原文</a>，<a target="_blank" rel="noopener" href="https://juejin.cn/post/7255138771985104951?searchId=20230807022558D9CB1A68F32E8F9B6EB0">副文</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6913704568325046279?searchId=20230807022558D9CB1A68F32E8F9B6EB0">什么是CDN</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7002781373014474759?searchId=20230807022558D9CB1A68F32E8F9B6EB0">了解CDN</a></p>
</blockquote>
<h3 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包?"></a>项目打包?</h3><h3 id="Nginx部署？"><a href="#Nginx部署？" class="headerlink" title="Nginx部署？"></a>Nginx部署？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">如果是 history 的路由模式，上线的时候需要 <span class="title class_">Nginx</span> 做配置，否则会 <span class="number">404</span></span><br><span class="line">原因：history 的每一次跳转对于后端来说都是一个新的请求，后端如果没有匹配这个请求就会 <span class="number">404</span></span><br><span class="line">解决方法：把浏览器地址栏的请求转发到 index.<span class="property">html</span>，index.<span class="property">html</span> 中加载的有前端路由代码，所以就会交给前端路由去处理</span><br><span class="line"></span><br><span class="line"><span class="comment">/*location / &#123;</span></span><br><span class="line"><span class="comment">    # 设置不论请求什么地址，都返回 index.html</span></span><br><span class="line"><span class="comment">    try_files $uri $uri/ /index.html;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Nginx</span> 转发，代理配置</span><br><span class="line">包含 /prod-api，都转发到  <span class="attr">https</span>:<span class="comment">//heimahr-t.itheima.net;</span></span><br><span class="line"><span class="comment">/*location /prod-api  &#123;</span></span><br><span class="line"><span class="comment">  proxy_pass https://heimahr-t.itheima.net;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure>
<h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后端返回的是文件流</span></span><br><span class="line"><span class="number">1</span>、利用 a标签 的 download 属性可以下载（服务器环境下测试） &lt;a download&gt;&lt;/a&gt;</span><br><span class="line"><span class="number">2</span>、推荐这个包  ---&gt;   file-saver ---&gt; 使用 file-saver 将 blob 转化成文件(用于将后端返回的二级制 blob 内部的数据转换成文件的形式下载)</span><br><span class="line"></span><br><span class="line">使用方法<span class="number">1</span> 按需导入：<span class="keyword">import</span> &#123; saveAs &#125; <span class="keyword">from</span> <span class="string">&#x27;file-saver&#x27;</span>;</span><br><span class="line"><span class="title function_">saveAs</span>(二进制数据,<span class="string">&#x27;文件名&#x27;</span>)</span><br><span class="line"></span><br><span class="line">方法<span class="number">2</span> 默认导入：<span class="keyword">import</span> <span class="title class_">FileSaver</span> <span class="keyword">from</span> <span class="string">&#x27;file-saver&#x27;</span>;</span><br><span class="line"><span class="title class_">FileSaver</span>.<span class="title function_">saveAs</span>(二进制数据,<span class="string">&#x27;文件名&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="国际化语言"><a href="#国际化语言" class="headerlink" title="国际化语言"></a>国际化语言</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Echarts适配"><a href="#Echarts适配" class="headerlink" title="Echarts适配"></a>Echarts适配</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904174669299726?searchId=202308070129351D21B8E16CB333969F17#heading-8">相关面试题</a></p>
<p><a target="_blank" rel="noopener" href="https://echarts.apache.org/handbook/zh/concepts/chart-size/">响应容器</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 方案一</span><br><span class="line">布局 =&gt; 百分比布局</span><br><span class="line"></span><br><span class="line"># 方案二</span><br><span class="line"><span class="comment">// 监听页面的 resize 事件获取浏览器大小改变的事件,然后调用 echartsInstance.resize 改变图表的大小</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123; 获取的元素名.<span class="title function_">resize</span>() &#125;)<span class="comment">// resize(V晒日) 适配</span></span><br><span class="line"></span><br><span class="line"># 方案三</span><br><span class="line">包 =&gt; v-scale-screen 大屏适配</span><br></pre></td></tr></table></figure>
<h3 id="Echarts3-x与Echarts2-x的区别"><a href="#Echarts3-x与Echarts2-x的区别" class="headerlink" title="Echarts3.x与Echarts2.x的区别"></a>Echarts3.x与Echarts2.x的区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Echarts2</span>.<span class="property">x</span>是通用的版本。</span><br><span class="line"><span class="title class_">Echarts2</span>.<span class="property">x</span>版本的文档实例比<span class="title class_">Echarts3</span>.<span class="property">x</span>版本的文档实例要好，更加清晰，更加容易理解。</span><br><span class="line"><span class="title class_">Echarts2</span>.<span class="property">x</span>版本做的图表更炫酷。</span><br><span class="line"><span class="title class_">Echarts2</span>.<span class="property">x</span>代表的是现在，而<span class="title class_">Echarts3</span>.<span class="property">x</span>代表的是未来。</span><br><span class="line"><span class="title class_">Echarts3</span>.<span class="property">x</span>对<span class="title class_">Echarts</span>的引用更灵活，更简单，方便。</span><br></pre></td></tr></table></figure>
<h3 id="切换主题和restful-Api"><a href="#切换主题和restful-Api" class="headerlink" title="切换主题和restful Api"></a>切换主题和restful Api</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、完善页面样式结构</span><br><span class="line">  .<span class="property">box</span>&#123;</span><br><span class="line">    <span class="attr">color</span>:red</span><br><span class="line">  &#125;</span><br><span class="line"><span class="number">2</span>、准备一个 &lt;button&gt; 按钮</span><br><span class="line">&lt;button&gt;&lt;/button&gt;</span><br><span class="line"><span class="number">3</span>、给按钮绑定页面样式</span><br><span class="line">&lt;button <span class="keyword">class</span>=<span class="string">&quot;theme&quot;</span>&gt;&lt;/button&gt;</span><br><span class="line">  .<span class="property">theme</span> .<span class="property">box</span>&#123;</span><br><span class="line">    <span class="attr">color</span>:blue</span><br><span class="line">  &#125;</span><br><span class="line"><span class="number">4</span>、给按钮绑定一个点击事件</span><br><span class="line">&lt;button <span class="keyword">class</span>=<span class="string">&quot;theme&quot;</span> id=<span class="string">&quot;oBtn&quot;</span>&gt;&lt;/button&gt;</span><br><span class="line">oBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;theme&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">逐字稿：首先我们准备多套样式，我们可以通过最外面的标签去添加样式，这个标签控制的就是网站所有的颜色样式，代码只需要去操控样式就可以了</span><br></pre></td></tr></table></figure>
<h2 id="Mock-js是什么？"><a href="#Mock-js是什么？" class="headerlink" title="Mock.js是什么？"></a>Mock.js是什么？</h2><p><a target="_blank" rel="noopener" href="https://gitee.com/ifercarly/mockjs">Mock语法</a></p>
<blockquote>
<p>一款模拟数据生成器，旨在帮助前端攻城师独立于后端进行开发，帮助编写单元测试。</p>
<p>功能：</p>
<ul>
<li><p>根据数据模板生成模拟数据</p>
</li>
<li><p>模拟 Ajax 请求，生成并返回模拟数据</p>
</li>
<li><p>基于 HTML 模板生成模拟数据</p>
</li>
</ul>
<p>书写格式：<code>&#39;属性名|生成规则&#39;</code>：属性值</p>
</blockquote>
<h3 id="大数字遇到的问题"><a href="#大数字遇到的问题" class="headerlink" title="大数字遇到的问题"></a>大数字遇到的问题</h3><p>什么是大数字?</p>
<blockquote>
<p>JS能表示的最大<code>安全</code>数值区间是 -Math.pow（2,53） +1 —-   Math.pow（2,53）-1，超过这个区间的数字称为大数字。</p>
<p>大白话：一段数值很大的数字类型，无小数点 和 逗号分隔，会导致后端传递数据后与前端接收到的数值不一致导致404。</p>
</blockquote>
<p>问题描述</p>
<blockquote>
<p><code>康哥</code>—-&gt;   后端返回的数据大部分是JSON格式的字符串 为了方便我们使用，axios 内部会对这个数据进行JSON.parse 反序列化的操作；而当这个JSON格式的字符串中包含大数字的时候，JSON.parse 是搞不定的，会出现转出来的结果和原来的不一致的问题；</p>
<p><code>个人</code>—-&gt;   点击按钮或列表某一项获取id并进入详情时，有的时候会出现404，因为如果后端传递的id是较大的number类型的数字 例如：900719925474099288 这超过了 Math.pow（2,53）-1属于大数字，那么前端浏览器获取到的则是 900719925474099300 与后端返回的不符，拿着这个id去发送详情 请求就会出现404。</p>
</blockquote>
<p>解决方法：</p>
<blockquote>
<p>和后端协商，让其返回的 ID 使用字符串的类型进行表示</p>
<p>前端配置 axios 的 transformResponse 选项，手动使用一些第三方包对后端返回的数据进行处理，例如： <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/json-bigint">json-bigint</a></p>
</blockquote>
<h2 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h2><p>页面跳转的方式有哪些？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># <span class="variable language_">window</span> 跳转方式</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span> = <span class="string">&quot;http://&quot;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">window.location.href = &quot;https//&quot;</span></span><br><span class="line"><span class="string">// 上面两种方法都是当前页面跳转； 不同之处在于 window.location 返回的是对象，如果没有.href，它的默认参数就是href</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">window.open(&quot;https://&quot;)</span></span><br><span class="line"><span class="string">window.open(&quot;https://&quot;, &quot;_self&quot;)</span></span><br><span class="line"><span class="string">// 上面两种方法不带参数_self，会走新开页面，加self在当前页面跳转，window.open(&quot;http://&quot;, &quot;_self&quot;)与window.location相比，window.location有IE浏览器兼容问题，会有缓存存在，所以项目中采用了，window.open(&quot;https://&quot;, &quot;_self&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">window.location.reload()；  // 重新加载当前页面</span></span><br><span class="line"><span class="string">window.location.replace();   // 重新加载且可以替换的当前页面为另一个页面；</span></span><br><span class="line"><span class="string">top.location.href=”url”        // 在顶层页面打开url（跳出框架）</span></span><br><span class="line"><span class="string">self.location.href=”url”        //仅在本页面打开url地址</span></span><br><span class="line"><span class="string">parent.location.href=”url”     // 在父窗口打开Url地址</span></span><br><span class="line"><span class="string">this.location.href=”url”       // 用法和self的用法一致</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># HTML跳转</span></span><br><span class="line"><span class="string">&lt;a href=&quot;页面路径&quot;&gt;&lt;/a&gt;  // 会有历史记录</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Vue跳转方式</span></span><br><span class="line"><span class="string">this.$router.push(&#x27;</span>页面路径<span class="string">&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># VueRouter跳转</span></span><br><span class="line"><span class="string">&lt;router-link to=&quot;页面路径&quot;&gt;&lt;/router-link&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 小程序跳转方式</span></span><br><span class="line"><span class="string">标签跳转</span></span><br><span class="line"><span class="string">&lt;navigator url=&quot;页面路径&quot;&gt;&lt;/navigator&gt;   // 注意，不能跳转 tabbar 页面 </span></span><br><span class="line"><span class="string">wx.switchTab   // 跳转到 tabBar 页面，并关闭所有非tabBar页面</span></span><br><span class="line"><span class="string">wx.reLaunch   // 关闭所有页面，打开到应用内的某个页面，无历史记录，无法通过左上角的箭头返回原页面。</span></span><br><span class="line"><span class="string">wx.redirectTo   // 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。</span></span><br><span class="line"><span class="string">wx.navigateTo   // 保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 wx.navigateBack 可以返回到原页面。小程序中页面栈最多十层。</span></span><br><span class="line"><span class="string">wx.navigateBack   // 关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages 获取当前的页面栈，决定需要返回几层。</span></span><br></pre></td></tr></table></figure>
<h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><h2 id="地图API"><a href="#地图API" class="headerlink" title="地图API"></a>地图API</h2><p>&gt;</p>
<h2 id="Promise执行顺序"><a href="#Promise执行顺序" class="headerlink" title="Promise执行顺序"></a>Promise执行顺序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> 同步</span><br><span class="line"><span class="keyword">await</span> 异步</span><br><span class="line">.<span class="title function_">then</span>()下方如果有代码则返回默认返回一段代码   <span class="comment">// return Promise.resolve(undefined)</span></span><br><span class="line"><span class="built_in">setTimeout</span> 异步宏任务 <span class="comment">// 定时器</span></span><br></pre></td></tr></table></figure>
<h2 id="业务相关面试题"><a href="#业务相关面试题" class="headerlink" title="业务相关面试题"></a>业务相关面试题</h2><h3 id="【业务】路由级别的权限你是怎么做的？"><a href="#【业务】路由级别的权限你是怎么做的？" class="headerlink" title="【业务】路由级别的权限你是怎么做的？"></a>【业务】路由级别的权限你是怎么做的？</h3><p>&gt;</p>
<h3 id="前后端协作接口文档"><a href="#前后端协作接口文档" class="headerlink" title="前后端协作接口文档"></a>前后端协作接口文档</h3><blockquote>
<p>apifox 文档</p>
<p>Typora（用的少）</p>
</blockquote>
<h3 id="【业务】按钮级别的权限你是怎么做的？"><a href="#【业务】按钮级别的权限你是怎么做的？" class="headerlink" title="【业务】按钮级别的权限你是怎么做的？"></a>【业务】按钮级别的权限你是怎么做的？</h3><p>&gt;</p>
<h3 id="上传二次封装？"><a href="#上传二次封装？" class="headerlink" title="上传二次封装？"></a>上传二次封装？</h3><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e：事件对象</span><br><span class="line">e.<span class="property">target</span>：事件对象内部属性</span><br><span class="line">e.<span class="property">target</span>.<span class="property">files</span>：上传的文件数组</span><br><span class="line">后端要求上传的格式是 (application/form-data) 的情况下</span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">new</span> <span class="title class_">FormData</span>()  <span class="comment">// 因为后端需要接收 FormData 所以 new 一个 FormData 对象</span></span><br><span class="line">data.<span class="title function_">append</span>(<span class="string">&#x27;后端规定的名字&#x27;</span>, 你上传的文件信息)  <span class="comment">// 将文件信息放入其中后，发请求时直接发生data，因为一般情况后端接收的是 FormData 对象通过解析这个对象拿到上传的二进制文件</span></span><br></pre></td></tr></table></figure>
<h3 id="前端大文件上传（切割文件）"><a href="#前端大文件上传（切割文件）" class="headerlink" title="前端大文件上传（切割文件）"></a>前端大文件上传（切割文件）</h3><blockquote>
<p>File对象：他表示一组文件，我们使用<input type="file">选择文件时，这些文件被存储在 File 对象中</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> file = files[i] <span class="comment">// File对象</span></span><br><span class="line">files.<span class="property">name</span> <span class="comment">// 文件名</span></span><br><span class="line">files.<span class="property">size</span> <span class="comment">// 文件大小</span></span><br><span class="line">files.<span class="property">type</span> <span class="comment">// 文件类型</span></span><br><span class="line">files.<span class="property">lastModifiedDate</span> <span class="comment">// 文件最后修改时间</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Blob对象：表示二进制数据，常用来表示大数据对象（如照片、音频等）。File对象是Blob对象的一个子类，他继承了Blob对象的属性和方法。</p>
<p>formData对象：前端先把文件存储在formData 对象中，才能传给后端。</p>
<p>File对象一般不能直接传输给后端，需要将二进制传输给后端，通过 append方法 将file对象添加到formData对象中，此时file对象会被转化成二进制后传给后端。</p>
<p><code>未完待续……</code></p>
</blockquote>
<h3 id="mixin代码混入"><a href="#mixin代码混入" class="headerlink" title="mixin代码混入"></a>mixin代码混入</h3><blockquote>
<p>混入：Vue2中常用的代码复用的手段，混入数据和业务逻辑</p>
<p>缺点：数据来源不清晰，命名冲突</p>
<p>在 Vue3中虽然没有移除 mixin ，但是不推荐使用了，更推荐组合API</p>
</blockquote>
<h3 id="公司迭代时间"><a href="#公司迭代时间" class="headerlink" title="公司迭代时间"></a>公司迭代时间</h3><blockquote>
<p>半个月迭代一次</p>
</blockquote>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>&gt;</p>
<p>for of 就是专门负责处理可迭代数据的。</p>
<h3 id="伪数组转真数组，Array-from-和-三个点都可以，区别是什么？"><a href="#伪数组转真数组，Array-from-和-三个点都可以，区别是什么？" class="headerlink" title="伪数组转真数组，Array.from 和 三个点都可以，区别是什么？"></a>伪数组转真数组，Array.from 和 三个点都可以，区别是什么？</h3><p>&gt;</p>
<h3 id="weakset-和-weakmap"><a href="#weakset-和-weakmap" class="headerlink" title="weakset 和 weakmap"></a>weakset 和 weakmap</h3><blockquote>
<p>weakset 和 weakmap 里面放的内容是弱引用的，有时候用这两个可以节省内存的占用。</p>
</blockquote>
<h3 id="对象去重"><a href="#对象去重" class="headerlink" title="对象去重"></a>对象去重</h3><blockquote>
<p>任何两个对象都不可能重复（相等，何来去重一说呢？）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="模块化规范都有哪些"><a href="#模块化规范都有哪些" class="headerlink" title="模块化规范都有哪些?"></a>模块化规范都有哪些?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">是什么?</span><br><span class="line">怎么用?</span><br><span class="line">解决了什么问题?</span><br><span class="line">有没有替代方案?</span><br><span class="line">好处是什么?</span><br><span class="line">场景是什么?</span><br><span class="line">原理是什么?</span><br></pre></td></tr></table></figure>
<h3 id="长列表优化？"><a href="#长列表优化？" class="headerlink" title="长列表优化？"></a>长列表优化？</h3><blockquote>
<p>使用虚拟列表：只渲染可视化区域（滑上去的删除）</p>
</blockquote>
<h3 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h3><p><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/nprogress">nprogress</a>（ &lt;—- 详情参考）被称为纳米级进度条</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">下载进度条包</span><br><span class="line">npm install --save nprogress</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只需调用 <code>start()</code> 和 <code>done()</code> 即可控制进度条。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">NProgress</span>.<span class="title function_">start</span>(); <span class="comment">// 开启进度条</span></span><br><span class="line">&gt;<span class="title class_">NProgress</span>.<span class="title function_">done</span>(); <span class="comment">// 关闭进度条</span></span><br><span class="line">&gt;# 注意点：如果在路由全局前置导航守卫中，通过 next 拦截到了其他页面，后置守卫里面设置的 <span class="title class_">NProgress</span>.<span class="title function_">done</span>() 不会被触发，需要在前置导航守卫也进行配置</span><br><span class="line"></span><br><span class="line">&gt;百分比：若要设置进度百分比，请调用 .<span class="title function_">set</span>(n) ，其中 n 是介于 <span class="number">1</span> 之间的数字。</span><br><span class="line">&gt;<span class="title class_">NProgress</span>.<span class="title function_">set</span>(<span class="number">0.0</span>); <span class="comment">// 进度条显示一点停止不动</span></span><br><span class="line">&gt;<span class="title class_">NProgress</span>.<span class="title function_">set</span>(<span class="number">0.4</span>); <span class="comment">// 进度条显示到一半停止不动</span></span><br><span class="line">&gt;<span class="title class_">NProgress</span>.<span class="title function_">set</span>(<span class="number">1.0</span>); <span class="comment">// 加载完毕</span></span><br><span class="line"></span><br><span class="line">&gt;# 递增：要递增进度条，只需使用 .<span class="title function_">inc</span>() 。这会以随机数量递增它。这永远不会达到 <span class="number">100</span>%：将其用于每个图像加载（或类似）。</span><br><span class="line">&gt;<span class="title class_">NProgress</span>.<span class="title function_">inc</span>() <span class="comment">// 每次加载一点，加载到还剩一点时停止不动(等于说就是加载到99%停止不动)</span></span><br><span class="line">&gt;如果要按特定值递增，可以将其作为参数传递：</span><br><span class="line">&gt;<span class="title class_">NProgress</span>.<span class="title function_">inc</span>(<span class="number">0.2</span>); <span class="comment">// 每次前进一点</span></span><br><span class="line"></span><br><span class="line">&gt;强制完成：通过将 <span class="literal">true</span> 传递到 <span class="title function_">done</span>() ，即使未显示进度条，它也会显示进度条。（默认行为是，如果未调用 .<span class="property">start</span>（），.<span class="property">done</span>（） 不会做任何事情）</span><br><span class="line">&gt;<span class="title class_">NProgress</span>.<span class="title function_">done</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="界面访问控制怎么做的？"><a href="#界面访问控制怎么做的？" class="headerlink" title="界面访问控制怎么做的？"></a>界面访问控制怎么做的？</h3><blockquote>
<p>在路由全局前置导航守卫，根据有没有token进行处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span>  <span class="comment">// 导入路由</span></span><br><span class="line">&gt;<span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span>  <span class="comment">// 快捷访问取token</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> whiteList = [<span class="string">&#x27;/login&#x27;</span>, <span class="string">&#x27;/404&#x27;</span>]  <span class="comment">// 设置白名单列表</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 全局前置导航守卫</span></span><br><span class="line">&gt;router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否有token</span></span><br><span class="line">   <span class="keyword">if</span> (store.<span class="property">getters</span>.<span class="property">token</span>) &#123;</span><br><span class="line">       <span class="comment">// 二次判断是不是在登录页面</span></span><br><span class="line">       <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/login&#x27;</span>) &#123;</span><br><span class="line">         <span class="comment">// 如果在登录页面并且还在白名单，就说明客户已经处于登录状态还想跳转到登录，这是不允许的，直接拦截到首页</span></span><br><span class="line">         <span class="title function_">next</span>(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 如果在登录页面并且还不在白名单，就说明客户访问的不是白名单页面，可以直接放行</span></span><br><span class="line">         <span class="title function_">next</span>()</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 如果没有token，那么判断是否访问的是白名单</span></span><br><span class="line">       <span class="keyword">if</span> (whiteList.<span class="title function_">includes</span>(to.<span class="property">path</span>)) &#123;</span><br><span class="line">         <span class="comment">// 如果是白名单则放行</span></span><br><span class="line">         <span class="title function_">next</span>()</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 如果访问的不是白名单则跳转登录页，登录</span></span><br><span class="line">         <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="H5三方登录流程？QQ登录、微信登录？"><a href="#H5三方登录流程？QQ登录、微信登录？" class="headerlink" title="H5三方登录流程？QQ登录、微信登录？"></a>H5三方登录流程？QQ登录、微信登录？</h3><p>&gt;</p>
<h3 id="什么是低代码？"><a href="#什么是低代码？" class="headerlink" title="什么是低代码？"></a>什么是低代码？</h3><p>&gt;</p>
<h3 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h3><p><a target="_blank" rel="noopener" href="https://github.com/chromium/chromium">谷歌浏览器源代码</a></p>
<p>vscode看源插件 <code>GitHub Repositories</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="title function_">addRule</span>(<span class="string">&#x27;div&#x27;</span>,<span class="string">&#x27;border: 2px solid #f40 !important&#x27;</span>)</span><br><span class="line">获取节点，某一段样式表，并添加规则(选中元素，添加的样式 !important防止被覆盖) <span class="comment">// 一般框架使用的多</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>什么是浏览器渲染？</p>
<p>​    <code>把一个HTML字符串变成屏幕上的像素信息</code></p>
<p>浏览器是如何渲染页面的？</p>
<p>​    <code>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列，在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程</code></p>
<p>1、<code>生成树并解析</code></p>
<p>DOM树（document object model）</p>
<p>释：含义就是我们的所有的 atl 元素以及注释就是 atl 文档里面有的东西就会形成一个一个的对象，因为方便后续去操作和改变它，并且还会提供 JS 操作控制的能力。</p>
<p>CSS树（CSS object model 称之为 CSSOM）</p>
<p>释：和DOM树一样开放 JS 操作能力</p>
<p>样式表有哪几种？</p>
<ul>
<li><p>内部样式表</p>
</li>
<li><p>外部样式表</p>
</li>
<li><p>内联样式表（行内样式表）</p>
</li>
<li><p>浏览器默认样式表</p>
</li>
</ul>
<p>在解析的过程中遇到了 外部引入的CSS 如：<link src="css文件"></link>&gt;  代码怎么办？</p>
<p><code>为了提高解析的效率，浏览器会启动一个预解析率先下载和解析 CSS、JS 样式(预解析就是额外开启一个线程率先去下载和解析)，主线程不会等待下载完成，而是继续解析后续的 HTML，CSS、JS是在预解析线程中执行的，这就是CSS不会阻塞 HTML 解析的根本原因。</code></p>
<p><code>如果主线程解析到了外部引入的 JS 文件 如：&lt;script src=&quot;JS文件&quot;&gt;&lt;/script&gt;  位置时，会停止解析 HTML ，转而等待 JS 文件下载好，并将全局代码解析执行完毕后，才能继续执行 HTML 。这是因为 JS 代码的执行过程可能会修改当前的DOM树，所以 DOM树的生成必须暂停，这就是 JS 会阻塞 HTML 解析的根本原因。</code></p>
</blockquote>
<h1 id="康哥讲面试"><a href="#康哥讲面试" class="headerlink" title="康哥讲面试"></a>康哥讲面试</h1><p>1、<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_69079573/article/details/131690614?spm=1001.2014.3001.5501">继承</a></p>
<blockquote>
<p>挂载到实例上面的称为实例属性、方法</p>
<p>挂载到原型上面的称为原型属性、方法</p>
<p>直接挂载到构造函数上的称为静态属性、方法，只能通过构造函数访问</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="comment">// this =&gt; 实例对象</span></span><br><span class="line">  <span class="comment">// 实例属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 方法不应该挂到实例上面，这样会存在内存空间浪费的问题</span></span><br><span class="line">  <span class="comment">/* this.show = function() &#123;</span></span><br><span class="line"><span class="comment">    console.log(&#x27;Hello World&#x27;)</span></span><br><span class="line"><span class="comment">  &#125; */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态属性</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">version</span> = <span class="number">18</span></span><br><span class="line"><span class="comment">// 原型属性</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">show</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法 then、catch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数通过 new 来使用</span></span><br><span class="line"><span class="keyword">const</span> wsc = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">show</span>() <span class="comment">// 自己没有会找原型</span></span><br><span class="line"><span class="comment">// 每一次调用方法都会在 堆 里面开辟一个空间存储方法，造成内存空间的浪费</span></span><br><span class="line">wsc.方法名</span><br><span class="line"></span><br><span class="line"># 借用继承</span><br><span class="line"># 原型继承（继承的是父类原型上的方法）</span><br><span class="line"><span class="comment">// 说一下对继承到的了解？ 说一下什么是组合继承？</span></span><br></pre></td></tr></table></figure>
<p>2、class</p>
<p>3、Event bus(发布订阅模式) / provide、inject（跨层级组件通信）</p>
<p>4、vuex =&gt; plugin</p>
<p>5、polyfill</p>
<p>6、 数据类型判断</p>
<p>7、数据处理</p>
<p>8、keep-alive组件缓存</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">微风</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/31/2023/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E5%BF%85%E4%BC%9A%EF%BC%8C%E4%B8%8D%E4%BC%9A%E6%89%BE%E5%B7%A5%E4%BD%9C%E9%9A%BE/">http://example.com/2023/07/31/2023/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E5%BF%85%E4%BC%9A%EF%BC%8C%E4%B8%8D%E4%BC%9A%E6%89%BE%E5%B7%A5%E4%BD%9C%E9%9A%BE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Were all heroes</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="https://img0.baidu.com/it/u=3487243724,4005355975&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500" data-sites="qq,wechat,weibo,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/29/2023/7%E6%9C%88%E6%96%87%E7%AB%A0/1_%E5%8F%91%E5%B8%83github404/" title="github部署网站404"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">github部署网站404</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/03/2023/8%E6%9C%88%E6%96%87%E7%AB%A0/1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" title="垃圾回收机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">垃圾回收机制</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author_top is-center"><div class="avatar-img"><img src="https://img0.baidu.com/it/u=3487243724,4005355975&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">微风</div><div class="author-info__description">I ll catch up with you</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ychangjun" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%94%E8%AE%B0%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">笔记类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E8%B7%AF"><span class="toc-number">2.0.1.</span> <span class="toc-text">套路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML%E3%80%81CSS"><span class="toc-number">2.1.</span> <span class="toc-text">HTML、CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90CSS%E3%80%91EM-%E5%92%8C-REM-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">【CSS】EM 和 REM 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9-REM-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.1.2.</span> <span class="toc-text">说一下你对 REM 的理解?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90CSS%E3%80%91REM-%E9%80%82%E9%85%8D%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.1.3.</span> <span class="toc-text">【CSS】REM 适配的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-position-%E5%AE%9A%E4%BD%8D%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">2.1.4.</span> <span class="toc-text">CSS position 定位有哪些属性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA"><span class="toc-number">2.1.5.</span> <span class="toc-text">CSS 文本溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90CSS%E3%80%91%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%9B%92%E5%AD%90%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%EF%BC%9F"><span class="toc-number">2.1.6.</span> <span class="toc-text">【CSS】如何实现一个盒子水平垂直居中？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90CSS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9-BFC-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">2.1.7.</span> <span class="toc-text">【CSS】说一下你对 BFC 的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90CSS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B-link-%E5%92%8C-import-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.1.8.</span> <span class="toc-text">【CSS】说一下 link 和 @import 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.9.</span> <span class="toc-text">盒子模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E5%85%83%E7%B4%A0"><span class="toc-number">2.1.10.</span> <span class="toc-text">行内元素和块元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BD%9C%E7%94%A8%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">2.1.11.</span> <span class="toc-text">深度作用选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">2.1.12.</span> <span class="toc-text">css画三角形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flex-1%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-number">2.1.13.</span> <span class="toc-text">flex:1是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#margin-top%E7%99%BE%E5%88%86%E6%AF%94%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-number">2.1.14.</span> <span class="toc-text">margin-top百分比是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%92%E5%AD%90%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%EF%BC%9F"><span class="toc-number">2.1.15.</span> <span class="toc-text">盒子垂直水平居中？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%94%AF%E6%8C%81%E5%B0%8F%E4%BA%8E12px%E7%9A%84%E6%96%87%E5%AD%97"><span class="toc-number">2.1.16.</span> <span class="toc-text">如何让谷歌浏览器支持小于12px的文字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS"><span class="toc-number">2.2.</span> <span class="toc-text">JS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%EF%BC%9F"><span class="toc-number">2.2.1.</span> <span class="toc-text">DOM？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BOM"><span class="toc-number">2.2.2.</span> <span class="toc-text">BOM?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#script%E6%A0%87%E7%AD%BE%EF%BC%9F"><span class="toc-number">2.2.3.</span> <span class="toc-text">script标签？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#script%E6%A0%87%E7%AD%BE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%88%B0-lt-body-gt-%E7%9A%84%E4%B8%8A%E6%96%B9%EF%BC%9F"><span class="toc-number">2.2.4.</span> <span class="toc-text">script标签为什么要写到&lt;&#x2F;body&gt;的上方？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E8%84%9A%E6%9C%AC"><span class="toc-number">2.2.5.</span> <span class="toc-text">动态加载脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99js%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BB%8E%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6%E5%BC%95%E5%85%A5%EF%BC%9F"><span class="toc-number">2.2.6.</span> <span class="toc-text">编写js时为什么需要从外部文件引入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.7.</span> <span class="toc-text">文档模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.8.</span> <span class="toc-text">元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9Cuse-strict%E2%80%9D%E5%85%BC%E5%AE%B9%E6%97%A7%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.9.</span> <span class="toc-text">“use strict”兼容旧代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.10.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E8%80%81%E8%AF%AD%E6%B3%95-var"><span class="toc-number">2.2.10.1.</span> <span class="toc-text">了解老语法 var</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.10.2.</span> <span class="toc-text">严格模式变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#let%E3%80%81const%E3%80%81var%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.2.10.3.</span> <span class="toc-text">let、const、var的区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.11.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.12.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B-new-%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.2.13.</span> <span class="toc-text">【JS】说一下 new 一个构造函数的执行过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B-call-%E5%92%8C-apply-%E5%8F%8A-bind-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.2.14.</span> <span class="toc-text">【JS】说一下 call 和 apply 及 bind 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6-%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.2.15.</span> <span class="toc-text">注册事件&#x2F;绑定事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">2.2.16.</span> <span class="toc-text">【JS】说一下你对事件委托的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">2.2.17.</span> <span class="toc-text">【JS】说一下你对防抖和节流的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9-EventLoop-%E8%A1%A3%E9%97%BB%E7%89%B9%E5%92%AF%E6%99%AE-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">2.2.18.</span> <span class="toc-text">【JS】说一下你对 EventLoop(衣闻特咯普) 的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.19.</span> <span class="toc-text">浏览器的进程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventLoop%E9%A2%9D%E5%A4%96%E9%97%AE%E7%AD%94-vue-%E4%B8%80%E5%AE%9A%E6%98%AF%E4%B8%80%E7%A7%92%E6%89%93%E5%8D%B0%E5%90%97%EF%BC%9F"><span class="toc-number">2.2.20.</span> <span class="toc-text">EventLoop额外问答? vue 一定是一秒打印吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81vue%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%80%E7%A7%92%E6%89%93%E5%8D%B0-%E4%BD%BF%E7%94%A8web-worker%E5%BC%80%E5%90%AFjs%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.2.21.</span> <span class="toc-text">如何保证vue中的代码一秒打印? 使用web worker开启js的多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E5%A6%82%E4%BD%95%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E4%B8%94%E6%A0%B9%E6%8D%AE%E8%AF%B7%E6%B1%82%E7%9A%84%E4%B9%A6%E5%86%99%E9%A1%BA%E5%BA%8F%E6%8B%BF%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%9F"><span class="toc-number">2.2.22.</span> <span class="toc-text">【JS】如何并发请求且根据请求的书写顺序拿到对应的结果？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9-Promise-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">2.2.23.</span> <span class="toc-text">【JS】说一下你对 Promise 的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%B7%AE%E5%BC%82%EF%BC%9F"><span class="toc-number">2.2.24.</span> <span class="toc-text">【JS】函数传参简单数据类型和复杂数据类型有什么差异？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">2.2.25.</span> <span class="toc-text">【JS】说一下图片懒加载的实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B-null-%E5%92%8C-undefined-%E7%9A%84%E5%B7%AE%E5%BC%82%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.2.26.</span> <span class="toc-text">【JS】说一下 null 和 undefined 的差异是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%B1%9E%E6%80%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">2.2.27.</span> <span class="toc-text">如何判断属性的数据类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">2.2.28.</span> <span class="toc-text">【JS】说一下你对闭包的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B-localstorage-%E5%92%8C-sessionStorage-%E5%8F%8A-Cookie-%E7%9A%84%E5%B7%AE%E5%BC%82%EF%BC%9F"><span class="toc-number">2.2.29.</span> <span class="toc-text">【JS】说一下 localstorage 和 sessionStorage 及 Cookie 的差异？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E4%B8%BA%E7%A9%BA%EF%BC%9F"><span class="toc-number">2.2.30.</span> <span class="toc-text">【JS】如何判断对象为空？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B-for-in-%E5%92%8C-for-of-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.2.31.</span> <span class="toc-text">【JS】说一下 for in 和 for of 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%B7%AE%E5%BC%82%EF%BC%9F"><span class="toc-number">2.2.32.</span> <span class="toc-text">【JS】说一下箭头函数和普通函数的差异？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JS%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81-%E9%87%8D%E6%8E%92-%EF%BC%8C%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%EF%BC%9F"><span class="toc-number">2.2.33.</span> <span class="toc-text">【JS】什么是重绘和回流(重排)，如何减少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%9F"><span class="toc-number">2.2.34.</span> <span class="toc-text">什么是内存泄露？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON-parse-JSON-stringify-%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">2.2.35.</span> <span class="toc-text">JSON.parse&#x2F;JSON.stringify 有哪些特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.36.</span> <span class="toc-text">垃圾回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise"><span class="toc-number">2.2.37.</span> <span class="toc-text">Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.37.1.</span> <span class="toc-text">Promise静态方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue"><span class="toc-number">2.3.</span> <span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue2%E5%92%8CVue3%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">2.3.1.</span> <span class="toc-text">Vue2和Vue3有哪些不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E4%BC%9A%E8%A7%A6%E5%8F%91%E8%A7%86%E5%9B%BE%E6%9B%B4%E6%96%B0%EF%BC%88%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">2.3.2.</span> <span class="toc-text">哪些方法会触发视图更新（变异方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPA-%E5%8D%95%E9%A1%B5%E9%9D%A2%EF%BC%9F%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-SPA-%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.3.3.</span> <span class="toc-text">SPA 单页面？说说你对 SPA 单页面的理解，它的优缺点分别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.3.4.</span> <span class="toc-text">Vue生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E4%B8%AD%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">2.3.5.</span> <span class="toc-text">Vue中事件修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-number">2.3.6.</span> <span class="toc-text">自定义指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E6%9C%BA%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-number">2.3.7.</span> <span class="toc-text">Vue 自定义指令在什么时机执行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%BF%E4%B8%BB%E7%8E%AF%E5%A2%83"><span class="toc-number">2.3.8.</span> <span class="toc-text">宿主环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9FDOM"><span class="toc-number">2.3.9.</span> <span class="toc-text">为什么需要虚拟DOM?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9FJS%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98%E8%BF%98%E6%98%AF%E6%A1%86%E6%9E%B6%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98%EF%BC%9F"><span class="toc-number">2.3.10.</span> <span class="toc-text">原生JS效率更高还是框架效率更高？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">2.3.11.</span> <span class="toc-text">单向数据流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8vue2%E4%B8%AD%E7%9A%84Object-defineProperty%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">2.3.12.</span> <span class="toc-text">在vue2中的Object.defineProperty有哪些属性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9-Vuex-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">2.3.13.</span> <span class="toc-text">【Vue】说一下你对 Vuex 的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91v-for-%E5%92%8C-v-if-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E6%94%BE%E4%B8%80%E8%A1%8C%EF%BC%9F"><span class="toc-number">2.3.14.</span> <span class="toc-text">【Vue】v-for 和 v-if 为什么不建议放一行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91Vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9B%9B%E8%BF%9E%E9%97%AE%EF%BC%9F"><span class="toc-number">2.3.15.</span> <span class="toc-text">【Vue】Vue 响应式四连问？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue2%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E4%B8%8D%E6%98%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%EF%BC%9F"><span class="toc-number">2.3.15.1.</span> <span class="toc-text">Vue2哪些情况操作数据不是响应式的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8D%E6%98%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%EF%BC%9F"><span class="toc-number">2.3.15.2.</span> <span class="toc-text">为什么这些情况不是响应式的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">2.3.15.3.</span> <span class="toc-text">怎么解决？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue3%E5%91%A2"><span class="toc-number">2.3.15.4.</span> <span class="toc-text">Vue3呢?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91hash-%E5%92%8C-history-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B7%AE%E5%BC%82%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9Frouter%E8%B7%AF%E7%94%B1%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.3.16.</span> <span class="toc-text">【Vue】hash 和 history 模式的差异是什么？router路由的工作模式？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">2.3.16.1.</span> <span class="toc-text">兼容性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.16.2.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E6%97%B6%EF%BC%8C%E5%AF%B9%E4%BA%8E%E5%90%8E%E7%AB%AF%E7%9A%84%E8%A1%A8%E7%8E%B0"><span class="toc-number">2.3.16.3.</span> <span class="toc-text">刷新页面时，对于后端的表现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E7%88%B6%E4%BC%A0%E5%AD%90%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F%E7%88%B6%E4%BC%A0%E5%AD%90%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%8C%E6%B3%A8%E6%84%8F%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.3.17.</span> <span class="toc-text">【Vue】父传子都有哪些方法？父传子都有哪些方法，注意点是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%88%B6%E4%BA%B2%E9%80%9A%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%BC%A0%E9%80%92%EF%BC%8C%E5%84%BF%E5%AD%90%E9%80%9A%E8%BF%87-props-%E6%8E%A5%E6%94%B6"><span class="toc-number">2.3.17.1.</span> <span class="toc-text">1、父亲通过自定义属性传递，儿子通过 props 接收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%88%B6%E7%BB%84%E4%BB%B6%E9%80%9A%E8%BF%87-refs-API-%E9%85%8D%E5%90%88-ref-%E5%B1%9E%E6%80%A7%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%AD%90%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%EF%BC%8C%E8%8E%B7%E5%8F%96%E5%AD%90%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E5%90%8E%E8%B0%83%E7%94%A8%E5%AE%83%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E5%90%8C%E6%97%B6%E5%B9%B6%E4%BC%A0%E5%8F%82%E3%80%82"><span class="toc-number">2.3.17.2.</span> <span class="toc-text">2、父组件通过 $refs API 配合 ref 属性来获取子组件实例，获取子组件实例后调用它的方法的同时并传参。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E7%88%B6%E7%BB%84%E4%BB%B6%E9%80%9A%E8%BF%87-children-%E8%8E%B7%E5%8F%96%E5%AD%90%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.3.17.3.</span> <span class="toc-text">3、父组件通过 $children 获取子组件实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E7%88%B6%E7%BB%84%E4%BB%B6%E9%80%9A%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%BC%A0%E9%80%92%EF%BC%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E8%BF%87-attrs-%E6%8E%A5%E6%94%B6"><span class="toc-number">2.3.17.4.</span> <span class="toc-text">4、父组件通过自定义属性传递，子组件通过 $attrs 接收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue3%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">2.3.18.</span> <span class="toc-text">Vue3组件通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E4%BC%A0%E5%AD%90%E4%BC%A0%E8%BF%87%E6%9D%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%AF%E4%BB%A5%E8%A2%AB%E4%BF%AE%E6%94%B9%E5%90%97%EF%BC%9F"><span class="toc-number">2.3.19.</span> <span class="toc-text">父传子传过来的数据可以被修改吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-model-%E5%92%8C-sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="toc-number">2.3.20.</span> <span class="toc-text">v-model 和 .sync 修饰符异同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-model-%E4%BC%A0%E9%80%92%E8%BF%87%E6%9D%A5%E7%9A%84-value-%E5%92%8C-input-%E6%80%8E%E4%B9%88%E4%BF%AE%E6%94%B9"><span class="toc-number">2.3.21.</span> <span class="toc-text">v-model 传递过来的 value 和 input 怎么修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E5%AD%90%E4%BC%A0%E7%88%B6%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">2.3.22.</span> <span class="toc-text">【Vue】子传父都有哪些方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B-Vue-%E4%B8%AD%E7%9A%84%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%EF%BC%9F"><span class="toc-number">2.3.23.</span> <span class="toc-text">【Vue】说一下 Vue 中的兄弟组件通信？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87"><span class="toc-number">2.3.23.1.</span> <span class="toc-text">1、状态提升</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Event-Bus"><span class="toc-number">2.3.23.2.</span> <span class="toc-text">2、Event Bus</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-nextTick-%E4%B8%AD%E5%B0%B1%E8%83%BD%E6%8B%BF%E5%88%B0-DOM-%E6%9B%B4%E6%96%B0%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">2.3.24.</span> <span class="toc-text">为什么 nextTick 中就能拿到 DOM 更新后的数据？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91Vue-nextTick-%E5%92%8C-eventLoop%EF%BC%9F"><span class="toc-number">2.3.25.</span> <span class="toc-text">【Vue】Vue nextTick 和 eventLoop？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E4%BD%A0%E4%BC%9A%E5%9C%A8%E5%93%AA%E4%B8%AA%E9%92%A9%E5%AD%90%E9%87%8C%E9%9D%A2%E5%8F%91%E8%AF%B7%E6%B1%82%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.3.26.</span> <span class="toc-text">【Vue】你会在哪个钩子里面发请求为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E7%BB%84%E4%BB%B6%E6%9F%90%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E7%9A%84%E8%A7%A6%E5%8F%91%EF%BC%9F%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E6%9F%90%E4%B8%AA%E9%98%B6%E6%AE%B5%EF%BC%8C%E7%88%B6%E7%BB%84%E4%BB%B6%E5%81%9A%E4%B8%80%E4%BA%9B%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-number">2.3.27.</span> <span class="toc-text">【Vue】如何监听组件某个生命周期钩子的触发？如何监听子组件生命周期的某个阶段，父组件做一些相关操作？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E5%80%9F%E5%8A%A9%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.3.27.1.</span> <span class="toc-text">方法1：借助自定义事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E9%80%9A%E8%BF%87-vnode-%E7%9B%B4%E6%8E%A5%E8%BF%9B%E8%A1%8C%E7%9B%91%E5%90%AC"><span class="toc-number">2.3.27.2.</span> <span class="toc-text">方式二：通过 @vnode- 直接进行监听</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B-computed-%E5%92%8C-methods-%E5%8F%8A-watch-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82%EF%BC%9F"><span class="toc-number">2.3.28.</span> <span class="toc-text">【Vue】说一下 computed 和 methods 及 watch 之间的差异？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9-Vue3-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">2.3.29.</span> <span class="toc-text">【Vue】说一下你对 Vue3 的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91v-show-%E5%92%8C-v-if-%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="toc-number">2.3.30.</span> <span class="toc-text">【Vue】v-show 和 v-if 的异同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E8%AF%B4%E4%B8%80%E4%B8%8B-Vue-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-number">2.3.31.</span> <span class="toc-text">【Vue】说一下 Vue 有哪些内置组件，分别是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91Vue-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%B5%8C%E5%A5%97%E7%9A%84%E8%AF%9D%EF%BC%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.3.32.</span> <span class="toc-text">【Vue】Vue 父子组件嵌套的话，生命周期顺序是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E5%92%8C-Vue-%E7%9B%B8%E5%85%B3%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%89%8B%E6%AE%B5%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.3.33.</span> <span class="toc-text">【Vue】和 Vue 相关性能优化的手段你了解哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Vue%E3%80%91%E5%92%8CVue%E7%9B%B8%E5%85%B3%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%89%8B%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.3.34.</span> <span class="toc-text">【Vue】和Vue相关的性能优化的手段有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watch%E7%9B%91%E5%90%AC%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.35.</span> <span class="toc-text">watch监听时遇到的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E4%B8%AD%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E4%B8%8D%E4%BC%9A%E6%94%B9%E5%8F%98%E5%8E%9F%E6%95%B0%E7%BB%84"><span class="toc-number">2.3.36.</span> <span class="toc-text">Vue中哪些方法不会改变原数组?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96%E8%A7%86%E5%9B%BE%E4%B8%8D%E6%9B%B4%E6%96%B0%EF%BC%9F"><span class="toc-number">2.3.37.</span> <span class="toc-text">数据变化视图不更新？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">2.3.38.</span> <span class="toc-text">常见的数据处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E5%AF%BC%E5%87%BA%E6%96%87%E4%BB%B6%E4%B8%BApdf%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.3.39.</span> <span class="toc-text">vue 导出文件为pdf格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-Vue-%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85%EF%BC%9F"><span class="toc-number">2.3.40.</span> <span class="toc-text">new Vue 的过程？发生了什么事情？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85"><span class="toc-number">2.3.41.</span> <span class="toc-text">组件封装?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90"><span class="toc-number">2.3.42.</span> <span class="toc-text">小程序生命周期钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setup-%E8%BF%94%E5%9B%9E%E7%9A%84%E4%B8%80%E5%AE%9A%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F"><span class="toc-number">2.3.43.</span> <span class="toc-text">setup 返回的一定是对象吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-Diff%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.44.</span> <span class="toc-text">DOM Diff算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5"><span class="toc-number">2.3.45.</span> <span class="toc-text">项目打包优化手段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.46.</span> <span class="toc-text">路由缓存问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pinia%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8"><span class="toc-number">2.3.47.</span> <span class="toc-text">pinia持久化存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%EF%BC%9F"><span class="toc-number">2.3.48.</span> <span class="toc-text">什么是动态路由？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">2.3.49.</span> <span class="toc-text">路由懒加载怎么做？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS"><span class="toc-number">2.4.</span> <span class="toc-text">TS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#type-%E5%92%8C-interface-%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">2.4.1.</span> <span class="toc-text">type 和 interface 的异同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-number">2.5.</span> <span class="toc-text">HTTP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AJAX"><span class="toc-number">2.6.</span> <span class="toc-text">AJAX</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">2.6.1.</span> <span class="toc-text">HTTP状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#restful-API%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E9%A3%8E%E6%A0%BC"><span class="toc-number">2.6.2.</span> <span class="toc-text">restful   API接口文档风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFHTTP"><span class="toc-number">2.6.3.</span> <span class="toc-text">HTTP是什么？什么是HTTP?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axios%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-%E6%A0%B9%E6%8D%AE%E5%90%8E%E7%AB%AF%E6%96%87%E6%A1%A3-axios-%E4%BC%A0%E5%8F%82"><span class="toc-number">2.6.4.</span> <span class="toc-text">axios的请求方式有哪些？&#x2F; 根据后端文档 axios 传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axios%E8%AF%B7%E6%B1%82"><span class="toc-number">2.6.5.</span> <span class="toc-text">axios请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axios%E5%B0%81%E8%A3%85"><span class="toc-number">2.6.6.</span> <span class="toc-text">axios封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axios%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82"><span class="toc-number">2.6.7.</span> <span class="toc-text">axios取消请求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.7.</span> <span class="toc-text">微信小程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-uni-app%EF%BC%9F"><span class="toc-number">2.7.1.</span> <span class="toc-text">为什么使用 uni-app？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E6%9C%89%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%94%AF%E6%8C%81%E7%9A%84%E5%B1%9E%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.7.2.</span> <span class="toc-text">只有微信小程序支持的属性是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%A2%E6%9C%8D"><span class="toc-number">2.7.3.</span> <span class="toc-text">小程序客服?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%88%86%E4%BA%AB%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F"><span class="toc-number">2.7.4.</span> <span class="toc-text">小程序中分享怎么做的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%89%AB%E7%A0%81%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.7.5.</span> <span class="toc-text">小程序扫码功能实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="toc-number">2.7.6.</span> <span class="toc-text">小程序登录流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web"><span class="toc-number">2.8.</span> <span class="toc-text">Web</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack%E6%98%AF%E4%BB%80%E4%B9%88-%E4%BB%80%E4%B9%88%E6%98%AFwebpack"><span class="toc-number">2.8.1.</span> <span class="toc-text">webpack是什么? &#x2F; 什么是webpack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFwebsocket%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFwebsocket%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.8.2.</span> <span class="toc-text">什么是websocket？什么是websocket协议?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#websocket%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="toc-number">2.8.3.</span> <span class="toc-text">websocket心跳机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-webpack-%E7%9A%84%E6%8E%92%E9%99%A4%E6%89%93%E5%8C%85%E6%95%88%E6%9E%9C-CDN"><span class="toc-number">2.8.4.</span> <span class="toc-text">配置 webpack 的排除打包效果 CDN</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AA%E5%88%86%E7%B1%BB%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">未分类面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CDN"><span class="toc-number">3.0.1.</span> <span class="toc-text">CDN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85"><span class="toc-number">3.0.2.</span> <span class="toc-text">项目打包?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx%E9%83%A8%E7%BD%B2%EF%BC%9F"><span class="toc-number">3.0.3.</span> <span class="toc-text">Nginx部署？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6"><span class="toc-number">3.0.4.</span> <span class="toc-text">下载文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BD%E9%99%85%E5%8C%96%E8%AF%AD%E8%A8%80"><span class="toc-number">3.0.5.</span> <span class="toc-text">国际化语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Echarts%E9%80%82%E9%85%8D"><span class="toc-number">3.0.6.</span> <span class="toc-text">Echarts适配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Echarts3-x%E4%B8%8EEcharts2-x%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.0.7.</span> <span class="toc-text">Echarts3.x与Echarts2.x的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98%E5%92%8Crestful-Api"><span class="toc-number">3.0.8.</span> <span class="toc-text">切换主题和restful Api</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mock-js%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">Mock.js是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E5%AD%97%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.1.</span> <span class="toc-text">大数字遇到的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC"><span class="toc-number">3.2.</span> <span class="toc-text">页面跳转</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6"><span class="toc-number">3.2.1.</span> <span class="toc-text">递归组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E5%9B%BEAPI"><span class="toc-number">3.3.</span> <span class="toc-text">地图API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.4.</span> <span class="toc-text">Promise执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.5.</span> <span class="toc-text">业务相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E4%B8%9A%E5%8A%A1%E3%80%91%E8%B7%AF%E7%94%B1%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9D%83%E9%99%90%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F"><span class="toc-number">3.5.1.</span> <span class="toc-text">【业务】路由级别的权限你是怎么做的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%8D%8F%E4%BD%9C%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3"><span class="toc-number">3.5.2.</span> <span class="toc-text">前后端协作接口文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E4%B8%9A%E5%8A%A1%E3%80%91%E6%8C%89%E9%92%AE%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9D%83%E9%99%90%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F"><span class="toc-number">3.5.3.</span> <span class="toc-text">【业务】按钮级别的权限你是怎么做的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85%EF%BC%9F"><span class="toc-number">3.5.4.</span> <span class="toc-text">上传二次封装？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-number">3.5.4.1.</span> <span class="toc-text">文件上传</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%EF%BC%88%E5%88%87%E5%89%B2%E6%96%87%E4%BB%B6%EF%BC%89"><span class="toc-number">3.5.5.</span> <span class="toc-text">前端大文件上传（切割文件）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mixin%E4%BB%A3%E7%A0%81%E6%B7%B7%E5%85%A5"><span class="toc-number">3.5.6.</span> <span class="toc-text">mixin代码混入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%8F%B8%E8%BF%AD%E4%BB%A3%E6%97%B6%E9%97%B4"><span class="toc-number">3.5.7.</span> <span class="toc-text">公司迭代时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.5.8.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E6%95%B0%E7%BB%84%E8%BD%AC%E7%9C%9F%E6%95%B0%E7%BB%84%EF%BC%8CArray-from-%E5%92%8C-%E4%B8%89%E4%B8%AA%E7%82%B9%E9%83%BD%E5%8F%AF%E4%BB%A5%EF%BC%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.5.9.</span> <span class="toc-text">伪数组转真数组，Array.from 和 三个点都可以，区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weakset-%E5%92%8C-weakmap"><span class="toc-number">3.5.10.</span> <span class="toc-text">weakset 和 weakmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%8E%BB%E9%87%8D"><span class="toc-number">3.5.11.</span> <span class="toc-text">对象去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.5.12.</span> <span class="toc-text">模块化规范都有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E5%88%97%E8%A1%A8%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">3.5.13.</span> <span class="toc-text">长列表优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%BA%A6%E6%9D%A1"><span class="toc-number">3.5.14.</span> <span class="toc-text">进度条</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F"><span class="toc-number">3.5.15.</span> <span class="toc-text">界面访问控制怎么做的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#H5%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%EF%BC%9FQQ%E7%99%BB%E5%BD%95%E3%80%81%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95%EF%BC%9F"><span class="toc-number">3.5.16.</span> <span class="toc-text">H5三方登录流程？QQ登录、微信登录？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%8E%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="toc-number">3.5.17.</span> <span class="toc-text">什么是低代码？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86"><span class="toc-number">3.5.18.</span> <span class="toc-text">浏览器渲染原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%B7%E5%93%A5%E8%AE%B2%E9%9D%A2%E8%AF%95"><span class="toc-number">4.</span> <span class="toc-text">康哥讲面试</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/23/2023/8%E6%9C%88%E6%96%87%E7%AB%A0/3-%E5%B7%A5%E5%85%B7%E9%93%BE/" title="工具链">工具链</a><time datetime="2023-08-23T07:25:48.000Z" title="发表于 2023-08-23 15:25:48">2023-08-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/05/2023/8%E6%9C%88%E6%96%87%E7%AB%A0/2-TS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="TS数据类型">TS数据类型</a><time datetime="2023-08-05T04:21:20.000Z" title="发表于 2023-08-05 12:21:20">2023-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/03/2023/8%E6%9C%88%E6%96%87%E7%AB%A0/1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" title="垃圾回收机制">垃圾回收机制</a><time datetime="2023-08-03T14:15:25.000Z" title="发表于 2023-08-03 22:15:25">2023-08-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/31/2023/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E5%BF%85%E4%BC%9A%EF%BC%8C%E4%B8%8D%E4%BC%9A%E6%89%BE%E5%B7%A5%E4%BD%9C%E9%9A%BE/" title="前端面试题">前端面试题</a><time datetime="2023-07-31T13:40:20.000Z" title="发表于 2023-07-31 21:40:20">2023-07-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/29/2023/7%E6%9C%88%E6%96%87%E7%AB%A0/1_%E5%8F%91%E5%B8%83github404/" title="github部署网站404">github部署网站404</a><time datetime="2023-07-29T03:52:30.000Z" title="发表于 2023-07-29 11:52:30">2023-07-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 微风</div><div class="footer_custom_text">本网站基于<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo框架</a>和butterfly主题搭建而成</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script defer src="/live2d-widget/autoload.js"></script><canvas async id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="/js/title.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="爱国,和谐,富强,友善,敬业,诚信,民主,文明,自由,平等,公正,公平,法治,社会" data-fontsize="15px" data-random="true" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":true,"model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>